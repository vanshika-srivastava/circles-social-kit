// node_modules/sha256-uint8array/dist/sha256-uint8array.mjs
var K = [
  1116352408 | 0,
  1899447441 | 0,
  3049323471 | 0,
  3921009573 | 0,
  961987163 | 0,
  1508970993 | 0,
  2453635748 | 0,
  2870763221 | 0,
  3624381080 | 0,
  310598401 | 0,
  607225278 | 0,
  1426881987 | 0,
  1925078388 | 0,
  2162078206 | 0,
  2614888103 | 0,
  3248222580 | 0,
  3835390401 | 0,
  4022224774 | 0,
  264347078 | 0,
  604807628 | 0,
  770255983 | 0,
  1249150122 | 0,
  1555081692 | 0,
  1996064986 | 0,
  2554220882 | 0,
  2821834349 | 0,
  2952996808 | 0,
  3210313671 | 0,
  3336571891 | 0,
  3584528711 | 0,
  113926993 | 0,
  338241895 | 0,
  666307205 | 0,
  773529912 | 0,
  1294757372 | 0,
  1396182291 | 0,
  1695183700 | 0,
  1986661051 | 0,
  2177026350 | 0,
  2456956037 | 0,
  2730485921 | 0,
  2820302411 | 0,
  3259730800 | 0,
  3345764771 | 0,
  3516065817 | 0,
  3600352804 | 0,
  4094571909 | 0,
  275423344 | 0,
  430227734 | 0,
  506948616 | 0,
  659060556 | 0,
  883997877 | 0,
  958139571 | 0,
  1322822218 | 0,
  1537002063 | 0,
  1747873779 | 0,
  1955562222 | 0,
  2024104815 | 0,
  2227730452 | 0,
  2361852424 | 0,
  2428436474 | 0,
  2756734187 | 0,
  3204031479 | 0,
  3329325298 | 0
];
var algorithms = {
  sha256: 1
};
function createHash(algorithm) {
  if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {
    throw new Error("Digest method not supported");
  }
  return new Hash();
}
var Hash = class {
  constructor() {
    this.A = 1779033703 | 0;
    this.B = 3144134277 | 0;
    this.C = 1013904242 | 0;
    this.D = 2773480762 | 0;
    this.E = 1359893119 | 0;
    this.F = 2600822924 | 0;
    this.G = 528734635 | 0;
    this.H = 1541459225 | 0;
    this._size = 0;
    this._sp = 0;
    if (!sharedBuffer || sharedOffset >= 8e3) {
      sharedBuffer = new ArrayBuffer(
        8e3
        /* N.allocTotal */
      );
      sharedOffset = 0;
    }
    this._byte = new Uint8Array(
      sharedBuffer,
      sharedOffset,
      80
      /* N.allocBytes */
    );
    this._word = new Int32Array(
      sharedBuffer,
      sharedOffset,
      20
      /* N.allocWords */
    );
    sharedOffset += 80;
  }
  update(data) {
    if ("string" === typeof data) {
      return this._utf8(data);
    }
    if (data == null) {
      throw new TypeError("Invalid type: " + typeof data);
    }
    const byteOffset = data.byteOffset;
    const length = data.byteLength;
    let blocks = length / 64 | 0;
    let offset = 0;
    if (blocks && !(byteOffset & 3) && !(this._size % 64)) {
      const block = new Int32Array(
        data.buffer,
        byteOffset,
        blocks * 16
        /* N.inputWords */
      );
      while (blocks--) {
        this._int32(block, offset >> 2);
        offset += 64;
      }
      this._size += offset;
    }
    const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
    if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
      const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);
      return this._uint8(rest);
    }
    if (offset === length)
      return this;
    return this._uint8(data, offset);
  }
  _uint8(data, offset) {
    const { _byte, _word } = this;
    const length = data.length;
    offset = offset | 0;
    while (offset < length) {
      const start = this._size % 64;
      let index = start;
      while (offset < length && index < 64) {
        _byte[index++] = data[offset++];
      }
      if (index >= 64) {
        this._int32(_word);
      }
      this._size += index - start;
    }
    return this;
  }
  _utf8(text) {
    const { _byte, _word } = this;
    const length = text.length;
    let surrogate = this._sp;
    for (let offset = 0; offset < length; ) {
      const start = this._size % 64;
      let index = start;
      while (offset < length && index < 64) {
        let code = text.charCodeAt(offset++) | 0;
        if (code < 128) {
          _byte[index++] = code;
        } else if (code < 2048) {
          _byte[index++] = 192 | code >>> 6;
          _byte[index++] = 128 | code & 63;
        } else if (code < 55296 || code > 57343) {
          _byte[index++] = 224 | code >>> 12;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
        } else if (surrogate) {
          code = ((surrogate & 1023) << 10) + (code & 1023) + 65536;
          _byte[index++] = 240 | code >>> 18;
          _byte[index++] = 128 | code >>> 12 & 63;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
          surrogate = 0;
        } else {
          surrogate = code;
        }
      }
      if (index >= 64) {
        this._int32(_word);
        _word[0] = _word[
          16
          /* N.inputWords */
        ];
      }
      this._size += index - start;
    }
    this._sp = surrogate;
    return this;
  }
  _int32(data, offset) {
    let { A, B, C, D, E, F, G, H } = this;
    let i = 0;
    offset = offset | 0;
    while (i < 16) {
      W[i++] = swap32(data[offset++]);
    }
    for (i = 16; i < 64; i++) {
      W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    }
    for (i = 0; i < 64; i++) {
      const T1 = H + sigma1(E) + ch(E, F, G) + K[i] + W[i] | 0;
      const T2 = sigma0(A) + maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    this.A = A + this.A | 0;
    this.B = B + this.B | 0;
    this.C = C + this.C | 0;
    this.D = D + this.D | 0;
    this.E = E + this.E | 0;
    this.F = F + this.F | 0;
    this.G = G + this.G | 0;
    this.H = H + this.H | 0;
  }
  digest(encoding) {
    const { _byte, _word } = this;
    let i = this._size % 64 | 0;
    _byte[i++] = 128;
    while (i & 3) {
      _byte[i++] = 0;
    }
    i >>= 2;
    if (i > 14) {
      while (i < 16) {
        _word[i++] = 0;
      }
      i = 0;
      this._int32(_word);
    }
    while (i < 16) {
      _word[i++] = 0;
    }
    const bits64 = this._size * 8;
    const low32 = (bits64 & 4294967295) >>> 0;
    const high32 = (bits64 - low32) / 4294967296;
    if (high32)
      _word[
        14
        /* N.highIndex */
      ] = swap32(high32);
    if (low32)
      _word[
        15
        /* N.lowIndex */
      ] = swap32(low32);
    this._int32(_word);
    return encoding === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A, B, C, D, E, F, G, H } = this;
    return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);
  }
  _bin() {
    const { A, B, C, D, E, F, G, H, _byte, _word } = this;
    _word[0] = swap32(A);
    _word[1] = swap32(B);
    _word[2] = swap32(C);
    _word[3] = swap32(D);
    _word[4] = swap32(E);
    _word[5] = swap32(F);
    _word[6] = swap32(G);
    _word[7] = swap32(H);
    return _byte.slice(0, 32);
  }
};
var W = new Int32Array(
  64
  /* N.workWords */
);
var sharedBuffer;
var sharedOffset = 0;
var hex32 = (num) => (num + 4294967296).toString(16).substr(-8);
var swapLE = (c) => c << 24 & 4278190080 | c << 8 & 16711680 | c >> 8 & 65280 | c >> 24 & 255;
var swapBE = (c) => c;
var swap32 = isBE() ? swapBE : swapLE;
var ch = (x, y, z) => z ^ x & (y ^ z);
var maj = (x, y, z) => x & y | z & (x | y);
var sigma0 = (x) => (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
var sigma1 = (x) => (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
var gamma0 = (x) => (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
var gamma1 = (x) => (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
function isBE() {
  const buf = new Uint8Array(new Uint16Array([65279]).buffer);
  return buf[0] === 254;
}

export {
  createHash
};
//# sourceMappingURL=chunk-WQM4IR34.js.map
