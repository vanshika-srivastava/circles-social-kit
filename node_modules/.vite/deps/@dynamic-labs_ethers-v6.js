"use client";
import {
  BrowserProvider,
  FallbackProvider,
  JsonRpcProvider
} from "./chunk-HUHAEXZ5.js";
import {
  isEthereumWallet
} from "./chunk-G64M34PN.js";
import "./chunk-L6ZWYHMX.js";
import "./chunk-UHISGVIX.js";
import "./chunk-ENDQD4WG.js";
import "./chunk-NEJQ34NE.js";
import "./chunk-7SNDHR3H.js";
import "./chunk-256EKJAK.js";

// node_modules/@dynamic-labs/ethers-v6/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/ethers-v6/src/getRpcProvider/getRpcProvider.js
var getRpcProvider = (wallet) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  if (!isEthereumWallet(wallet))
    throw new Error(`getRpcProvider must be called with an Ethereum wallet, but wallet was of chain ${wallet.chain}`);
  const publicClient = yield wallet.getPublicClient();
  const { chain, transport } = publicClient;
  const network = {
    chainId: chain === null || chain === void 0 ? void 0 : chain.id,
    ensAddress: (_b = (_a = chain === null || chain === void 0 ? void 0 : chain.contracts) === null || _a === void 0 ? void 0 : _a.ensRegistry) === null || _b === void 0 ? void 0 : _b.address,
    name: chain === null || chain === void 0 ? void 0 : chain.name
  };
  if (transport.type !== "fallback") {
    return new JsonRpcProvider(transport.url, network);
  }
  const providers = transport.transports.map(({ value }) => new JsonRpcProvider(value === null || value === void 0 ? void 0 : value.url, network));
  if (providers.length === 1)
    return providers[0];
  return new FallbackProvider(providers);
});

// node_modules/@dynamic-labs/ethers-v6/src/getWeb3Provider/getWeb3Provider.js
var getWeb3Provider = (wallet) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  if (!isEthereumWallet(wallet)) {
    throw new Error(`getWeb3Provider must be called with an Ethereum wallet, but wallet was of chain ${wallet.chain}`);
  }
  const publicClient = yield wallet.getPublicClient();
  const walletClient = yield wallet.getWalletClient();
  if (!publicClient || !walletClient) {
    throw new Error("Wallet is not connected, cannot create ethers provider");
  }
  const { chain } = publicClient;
  const network = {
    chainId: chain === null || chain === void 0 ? void 0 : chain.id,
    ensAddress: (_b = (_a = chain === null || chain === void 0 ? void 0 : chain.contracts) === null || _a === void 0 ? void 0 : _a.ensRegistry) === null || _b === void 0 ? void 0 : _b.address,
    name: chain === null || chain === void 0 ? void 0 : chain.name
  };
  return new BrowserProvider(walletClient.transport, network);
});

// node_modules/@dynamic-labs/ethers-v6/src/getSigner/getSigner.js
var getSigner = (wallet) => __awaiter(void 0, void 0, void 0, function* () {
  if (!isEthereumWallet(wallet))
    throw new Error(`getSigner must be called with an Ethereum wallet, but wallet was of chain ${wallet.chain}`);
  const provider = yield getWeb3Provider(wallet);
  return provider.getSigner(wallet.address);
});
export {
  getRpcProvider,
  getSigner,
  getWeb3Provider
};
//# sourceMappingURL=@dynamic-labs_ethers-v6.js.map
