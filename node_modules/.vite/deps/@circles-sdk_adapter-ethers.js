import {
  BrowserProvider,
  Wallet
} from "./chunk-HUHAEXZ5.js";
import "./chunk-256EKJAK.js";

// node_modules/@circles-sdk/adapter-ethers/dist/index.js
var EthersContractRunner = class {
};
var PrivateKeyContractRunner = class {
  constructor(provider, privateKey) {
    this.provider = provider;
    this.privateKey = privateKey;
    this.estimateGas = async (tx) => {
      return this.ensureWallet().estimateGas(tx);
    };
    this.call = async (tx) => {
      return this.ensureWallet().call(tx);
    };
    this.resolveName = async (name) => {
      return this.ensureWallet().resolveName(name);
    };
    this.sendTransaction = async (tx) => {
      return this.ensureWallet().sendTransaction(tx);
    };
  }
  async init() {
    this._wallet = new Wallet(this.privateKey, this.provider);
    this.address = await this._wallet.getAddress();
  }
  ensureWallet() {
    if (!this._wallet) {
      throw new Error("Not initialized");
    }
    return this._wallet;
  }
};
var BrowserProviderContractRunner = class {
  constructor() {
    this.estimateGas = async (tx) => this.provider.estimateGas(tx);
    this.call = async (tx) => this.provider.call(tx);
    this.resolveName = async (name) => this.provider.resolveName(name);
    this.sendTransaction = async (tx) => {
      const signer = await this.provider.getSigner();
      return signer.sendTransaction(tx);
    };
    const w = window;
    const ethereumObject = w.ethereum;
    if (!ethereumObject) {
      throw new Error("No provider found on window.ethereum");
    }
    this.provider = new BrowserProvider(ethereumObject);
  }
  async init() {
    this.address = await this.provider.getSigner().then((signer) => signer.getAddress());
  }
};
var SdkContractRunnerWrapper = class {
  /**
   * Creates a new EthersContractRunner. The provider is used to fetch the transaction details and the sdkContractRunner is used to execute the transactions.
   * @param provider The ethers6 provider
   * @param address The address of the account that signs transactions
   * @param sdkContractRunner The sdk contract runner
   */
  constructor(provider, address, sdkContractRunner) {
    this.provider = provider;
    this.address = address;
    this.sdkContractRunner = sdkContractRunner;
    this.estimateGas = async (tx) => {
      if (!this.sdkContractRunner.estimateGas) {
        throw new Error("estimateGas not supported");
      }
      if (!tx.to) {
        throw new Error("to is required");
      }
      if (!tx.data && !tx.value) {
        throw new Error("data or value is required");
      }
      return this.sdkContractRunner.estimateGas({
        to: await this.addressLikeToString(tx.to),
        data: tx.data ?? "0x",
        value: this.bignumberishToBigInt(tx.value)
      });
    };
    this.call = async (tx) => {
      if (!this.sdkContractRunner.call) {
        throw new Error("call not supported");
      }
      if (!tx.to) {
        throw new Error("to is required");
      }
      if (!tx.data && !tx.value) {
        throw new Error("data or value is required");
      }
      return this.sdkContractRunner.call({
        to: await this.addressLikeToString(tx.to),
        data: tx.data ?? "0x",
        value: this.bignumberishToBigInt(tx.value)
      });
    };
    this.sendTransaction = async (tx) => {
      if (!this.sdkContractRunner.sendTransaction) {
        throw new Error("sendTransaction not supported");
      }
      if (!tx.to) {
        throw new Error("to is required");
      }
      if (!tx.data && !tx.value) {
        throw new Error("data or value is required");
      }
      const response = await this.sdkContractRunner.sendTransaction({
        to: await this.addressLikeToString(tx.to),
        data: tx.data ?? "0x",
        value: this.bignumberishToBigInt(tx.value)
      });
      const transactionResponse = await this.provider.getTransaction(response.hash);
      if (!transactionResponse) {
        throw new Error("Transaction not found");
      }
      return transactionResponse;
    };
  }
  async init() {
  }
  async addressLikeToString(addressLike) {
    if (typeof addressLike === "string") {
      return addressLike;
    }
    if (addressLike instanceof Promise) {
      return addressLike;
    }
    return addressLike.getAddress();
  }
  bignumberishToBigInt(value) {
    if (!value) {
      return BigInt(0);
    }
    if (typeof value === "bigint") {
      return value;
    }
    return BigInt(value);
  }
};
export {
  BrowserProviderContractRunner,
  EthersContractRunner,
  PrivateKeyContractRunner,
  SdkContractRunnerWrapper
};
//# sourceMappingURL=@circles-sdk_adapter-ethers.js.map
