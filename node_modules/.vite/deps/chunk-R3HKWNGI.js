import {
  require_react
} from "./chunk-7SNDHR3H.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@dynamic-labs/sdk-api-core/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/sdk-api-core/src/runtime.js
var BASE_PATH = "https://app.dynamicauth.com/api/v0".replace(/\/+$/, "");
var isBlob = (value) => typeof Blob !== "undefined" && value instanceof Blob;
var BaseAPI = class {
  constructor(configuration = new Configuration()) {
    this.configuration = configuration;
    this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
        }
      }
      let response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (yield middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  request(context, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const { url, init } = this.createFetchParams(context, initOverrides);
      const response = yield this.fetchApi(url, init);
      if (response.status >= 200 && response.status < 300) {
        return response;
      }
      throw response;
    });
  }
  createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const body = typeof FormData !== "undefined" && context.body instanceof FormData || context.body instanceof URLSearchParams || isBlob(context.body) ? context.body : JSON.stringify(context.body);
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    const init = Object.assign({ method: context.method, headers, body, credentials: this.configuration.credentials }, initOverrides);
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => __awaiter(this, void 0, void 0, function* () {
        return accessToken;
      });
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => {
    const fullKey = prefix + (prefix.length ? `[${key}]` : key);
    const value = params[key];
    if (value instanceof Array) {
      const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
      return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Date) {
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
      return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
  }).filter((part) => part.length > 0).join("&");
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  value() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.transformer(yield this.raw.json());
    });
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __awaiter(this, void 0, void 0, function* () {
      return void 0;
    });
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.raw.text();
    });
  }
};

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameServiceData.js
function NameServiceDataFromJSON(json) {
  return NameServiceDataFromJSONTyped(json);
}
function NameServiceDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "avatar": !exists(json, "avatar") ? void 0 : json["avatar"],
    "name": !exists(json, "name") ? void 0 : json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletProviderEnum.js
var WalletProviderEnum;
(function(WalletProviderEnum2) {
  WalletProviderEnum2["BrowserExtension"] = "browserExtension";
  WalletProviderEnum2["CustodialService"] = "custodialService";
  WalletProviderEnum2["WalletConnect"] = "walletConnect";
  WalletProviderEnum2["QrCode"] = "qrCode";
  WalletProviderEnum2["DeepLink"] = "deepLink";
  WalletProviderEnum2["EmbeddedWallet"] = "embeddedWallet";
  WalletProviderEnum2["SmartContractWallet"] = "smartContractWallet";
})(WalletProviderEnum || (WalletProviderEnum = {}));
function WalletProviderEnumFromJSON(json) {
  return WalletProviderEnumFromJSONTyped(json);
}
function WalletProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function WalletProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtBlockchainAccount.js
function JwtBlockchainAccountFromJSON(json) {
  return JwtBlockchainAccountFromJSONTyped(json);
}
function JwtBlockchainAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "chain": json["chain"],
    "id": json["id"],
    "nameService": !exists(json, "name_service") ? void 0 : NameServiceDataFromJSON(json["name_service"]),
    "walletName": json["wallet_name"],
    "walletProvider": WalletProviderEnumFromJSON(json["wallet_provider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ChainEnum.js
var ChainEnum;
(function(ChainEnum2) {
  ChainEnum2["Eth"] = "ETH";
  ChainEnum2["Evm"] = "EVM";
  ChainEnum2["Flow"] = "FLOW";
  ChainEnum2["Sol"] = "SOL";
  ChainEnum2["Algo"] = "ALGO";
  ChainEnum2["Stark"] = "STARK";
  ChainEnum2["Cosmos"] = "COSMOS";
  ChainEnum2["Btc"] = "BTC";
})(ChainEnum || (ChainEnum = {}));
function ChainEnumFromJSON(json) {
  return ChainEnumFromJSONTyped(json);
}
function ChainEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ChainEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtPayloadDeprecatedInfo.js
function JwtPayloadDeprecatedInfoFromJSON(json) {
  return JwtPayloadDeprecatedInfoFromJSONTyped(json);
}
function JwtPayloadDeprecatedInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "chain": !exists(json, "chain") ? void 0 : ChainEnumFromJSON(json["chain"]),
    "email": !exists(json, "email") ? void 0 : json["email"],
    "ens": !exists(json, "ens") ? void 0 : NameServiceDataFromJSON(json["ens"]),
    "environmentId": json["environmentId"],
    "firstName": !exists(json, "firstName") ? void 0 : json["firstName"],
    "jobTitle": !exists(json, "jobTitle") ? void 0 : json["jobTitle"],
    "lastName": !exists(json, "lastName") ? void 0 : json["lastName"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "tShirtSize": !exists(json, "tShirtSize") ? void 0 : json["tShirtSize"],
    "userId": !exists(json, "userId") ? void 0 : json["userId"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "wallet": !exists(json, "wallet") ? void 0 : json["wallet"],
    "walletPublicKey": !exists(json, "walletPublicKey") ? void 0 : json["walletPublicKey"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtVerifiedCredentialFormatEnum.js
var JwtVerifiedCredentialFormatEnum;
(function(JwtVerifiedCredentialFormatEnum2) {
  JwtVerifiedCredentialFormatEnum2["Blockchain"] = "blockchain";
  JwtVerifiedCredentialFormatEnum2["Email"] = "email";
  JwtVerifiedCredentialFormatEnum2["Oauth"] = "oauth";
  JwtVerifiedCredentialFormatEnum2["Passkey"] = "passkey";
  JwtVerifiedCredentialFormatEnum2["PhoneNumber"] = "phoneNumber";
  JwtVerifiedCredentialFormatEnum2["ExternalUser"] = "externalUser";
})(JwtVerifiedCredentialFormatEnum || (JwtVerifiedCredentialFormatEnum = {}));
function JwtVerifiedCredentialFormatEnumFromJSON(json) {
  return JwtVerifiedCredentialFormatEnumFromJSONTyped(json);
}
function JwtVerifiedCredentialFormatEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderEnum.js
var ProviderEnum;
(function(ProviderEnum2) {
  ProviderEnum2["EmailOnly"] = "emailOnly";
  ProviderEnum2["MagicLink"] = "magicLink";
  ProviderEnum2["Apple"] = "apple";
  ProviderEnum2["Bitbucket"] = "bitbucket";
  ProviderEnum2["Coinbasesocial"] = "coinbasesocial";
  ProviderEnum2["Discord"] = "discord";
  ProviderEnum2["Facebook"] = "facebook";
  ProviderEnum2["Farcaster"] = "farcaster";
  ProviderEnum2["Github"] = "github";
  ProviderEnum2["Gitlab"] = "gitlab";
  ProviderEnum2["Google"] = "google";
  ProviderEnum2["Instagram"] = "instagram";
  ProviderEnum2["Linkedin"] = "linkedin";
  ProviderEnum2["Microsoft"] = "microsoft";
  ProviderEnum2["Twitch"] = "twitch";
  ProviderEnum2["Twitter"] = "twitter";
  ProviderEnum2["Blocto"] = "blocto";
  ProviderEnum2["Banxa"] = "banxa";
  ProviderEnum2["Dynamic"] = "dynamic";
  ProviderEnum2["Alchemy"] = "alchemy";
  ProviderEnum2["Zerodev"] = "zerodev";
  ProviderEnum2["Telegram"] = "telegram";
  ProviderEnum2["Turnkey"] = "turnkey";
  ProviderEnum2["CoinbaseWaas"] = "coinbaseWaas";
  ProviderEnum2["Sms"] = "sms";
})(ProviderEnum || (ProviderEnum = {}));
function ProviderEnumFromJSON(json) {
  return ProviderEnumFromJSONTyped(json);
}
function ProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletAddressType.js
var WalletAddressType;
(function(WalletAddressType2) {
  WalletAddressType2["Ordinals"] = "ordinals";
  WalletAddressType2["Payment"] = "payment";
})(WalletAddressType || (WalletAddressType = {}));
function WalletAddressTypeFromJSON(json) {
  return WalletAddressTypeFromJSONTyped(json);
}
function WalletAddressTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function WalletAddressTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletAdditionalAddress.js
function WalletAdditionalAddressFromJSON(json) {
  return WalletAdditionalAddressFromJSONTyped(json);
}
function WalletAdditionalAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "publicKey": !exists(json, "publicKey") ? void 0 : json["publicKey"],
    "type": WalletAddressTypeFromJSON(json["type"])
  };
}
function WalletAdditionalAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "publicKey": value.publicKey,
    "type": WalletAddressTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletVersionEnum.js
var EmbeddedWalletVersionEnum;
(function(EmbeddedWalletVersionEnum2) {
  EmbeddedWalletVersionEnum2["V1"] = "V1";
  EmbeddedWalletVersionEnum2["V2"] = "V2";
})(EmbeddedWalletVersionEnum || (EmbeddedWalletVersionEnum = {}));
function EmbeddedWalletVersionEnumFromJSON(json) {
  return EmbeddedWalletVersionEnumFromJSONTyped(json);
}
function EmbeddedWalletVersionEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HardwareWalletEnum.js
var HardwareWalletEnum;
(function(HardwareWalletEnum2) {
  HardwareWalletEnum2["Ledger"] = "ledger";
})(HardwareWalletEnum || (HardwareWalletEnum = {}));
function HardwareWalletEnumFromJSON(json) {
  return HardwareWalletEnumFromJSONTyped(json);
}
function HardwareWalletEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasswordSourceTypeEnum.js
var PasswordSourceTypeEnum;
(function(PasswordSourceTypeEnum2) {
  PasswordSourceTypeEnum2["Dynamic"] = "dynamic";
  PasswordSourceTypeEnum2["User"] = "user";
})(PasswordSourceTypeEnum || (PasswordSourceTypeEnum = {}));
function PasswordSourceTypeEnumFromJSON(json) {
  return PasswordSourceTypeEnumFromJSONTyped(json);
}
function PasswordSourceTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PasswordSourceTypeEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletProperties.js
function WalletPropertiesFromJSON(json) {
  return WalletPropertiesFromJSONTyped(json);
}
function WalletPropertiesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeySubOrganizationId": !exists(json, "turnkeySubOrganizationId") ? void 0 : json["turnkeySubOrganizationId"],
    "turnkeyPrivateKeyId": !exists(json, "turnkeyPrivateKeyId") ? void 0 : json["turnkeyPrivateKeyId"],
    "turnkeyHDWalletId": !exists(json, "turnkeyHDWalletId") ? void 0 : json["turnkeyHDWalletId"],
    "isAuthenticatorAttached": !exists(json, "isAuthenticatorAttached") ? void 0 : json["isAuthenticatorAttached"],
    "turnkeyUserId": !exists(json, "turnkeyUserId") ? void 0 : json["turnkeyUserId"],
    "isSessionKeyCompatible": !exists(json, "isSessionKeyCompatible") ? void 0 : json["isSessionKeyCompatible"],
    "version": !exists(json, "version") ? void 0 : EmbeddedWalletVersionEnumFromJSON(json["version"]),
    "hardwareWallet": !exists(json, "hardwareWallet") ? void 0 : HardwareWalletEnumFromJSON(json["hardwareWallet"]),
    "claimed": !exists(json, "claimed") ? void 0 : json["claimed"],
    "source": !exists(json, "source") ? void 0 : PasswordSourceTypeEnumFromJSON(json["source"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtVerifiedCredential.js
function JwtVerifiedCredentialFromJSON(json) {
  return JwtVerifiedCredentialFromJSONTyped(json);
}
function JwtVerifiedCredentialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": !exists(json, "address") ? void 0 : json["address"],
    "chain": !exists(json, "chain") ? void 0 : json["chain"],
    "refId": !exists(json, "refId") ? void 0 : json["refId"],
    "signerRefId": !exists(json, "signerRefId") ? void 0 : json["signerRefId"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "id": json["id"],
    "nameService": !exists(json, "name_service") ? void 0 : NameServiceDataFromJSON(json["name_service"]),
    "publicIdentifier": !exists(json, "public_identifier") ? void 0 : json["public_identifier"],
    "walletName": !exists(json, "wallet_name") ? void 0 : json["wallet_name"],
    "walletProvider": !exists(json, "wallet_provider") ? void 0 : WalletProviderEnumFromJSON(json["wallet_provider"]),
    "walletProperties": !exists(json, "wallet_properties") ? void 0 : WalletPropertiesFromJSON(json["wallet_properties"]),
    "format": JwtVerifiedCredentialFormatEnumFromJSON(json["format"]),
    "oauthProvider": !exists(json, "oauth_provider") ? void 0 : ProviderEnumFromJSON(json["oauth_provider"]),
    "oauthUsername": !exists(json, "oauth_username") ? void 0 : json["oauth_username"],
    "oauthDisplayName": !exists(json, "oauth_display_name") ? void 0 : json["oauth_display_name"],
    "oauthAccountId": !exists(json, "oauth_account_id") ? void 0 : json["oauth_account_id"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "phoneCountryCode": !exists(json, "phoneCountryCode") ? void 0 : json["phoneCountryCode"],
    "isoCountryCode": !exists(json, "isoCountryCode") ? void 0 : json["isoCountryCode"],
    "oauthAccountPhotos": !exists(json, "oauth_account_photos") ? void 0 : json["oauth_account_photos"],
    "oauthEmails": !exists(json, "oauth_emails") ? void 0 : json["oauth_emails"],
    "oauthMetadata": !exists(json, "oauth_metadata") ? void 0 : json["oauth_metadata"],
    "previousUsers": !exists(json, "previous_users") ? void 0 : json["previous_users"],
    "embeddedWalletId": !exists(json, "embedded_wallet_id") ? void 0 : json["embedded_wallet_id"],
    "walletAdditionalAddresses": !exists(json, "wallet_additional_addresses") ? void 0 : json["wallet_additional_addresses"].map(WalletAdditionalAddressFromJSON),
    "lastSelectedAt": !exists(json, "lastSelectedAt") ? void 0 : new Date(json["lastSelectedAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldType.js
var CustomFieldType;
(function(CustomFieldType2) {
  CustomFieldType2["Text"] = "text";
  CustomFieldType2["Checkbox"] = "checkbox";
  CustomFieldType2["Select"] = "select";
})(CustomFieldType || (CustomFieldType = {}));
function CustomFieldTypeFromJSON(json) {
  return CustomFieldTypeFromJSONTyped(json);
}
function CustomFieldTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldValidValue.js
function CustomFieldValidValueFromJSON(json) {
  return CustomFieldValidValueFromJSONTyped(json);
}
function CustomFieldValidValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "label": json["label"],
    "key": !exists(json, "key") ? void 0 : json["key"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldValidationRules.js
function CustomFieldValidationRulesFromJSON(json) {
  return CustomFieldValidationRulesFromJSONTyped(json);
}
function CustomFieldValidationRulesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "unique": !exists(json, "unique") ? void 0 : json["unique"],
    "regex": !exists(json, "regex") ? void 0 : json["regex"],
    "validOptions": !exists(json, "validOptions") ? void 0 : json["validOptions"].map(CustomFieldValidValueFromJSON),
    "checkboxText": !exists(json, "checkboxText") ? void 0 : json["checkboxText"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/KycFieldType.js
var KycFieldType;
(function(KycFieldType2) {
  KycFieldType2["Standard"] = "standard";
  KycFieldType2["Custom"] = "custom";
})(KycFieldType || (KycFieldType = {}));
function KycFieldTypeFromJSON(json) {
  return KycFieldTypeFromJSONTyped(json);
}
function KycFieldTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function KycFieldTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsKyc.js
function ProjectSettingsKycFromJSON(json) {
  return ProjectSettingsKycFromJSONTyped(json);
}
function ProjectSettingsKycFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "required": json["required"],
    "enabled": json["enabled"],
    "unique": json["unique"],
    "verify": json["verify"],
    "type": !exists(json, "type") ? void 0 : KycFieldTypeFromJSON(json["type"]),
    "validationRules": !exists(json, "validationRules") ? void 0 : CustomFieldValidationRulesFromJSON(json["validationRules"]),
    "validationType": !exists(json, "validationType") ? void 0 : CustomFieldTypeFromJSON(json["validationType"]),
    "label": !exists(json, "label") ? void 0 : json["label"],
    "position": !exists(json, "position") ? void 0 : json["position"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DynamicJwt.js
function DynamicJwtFromJSON(json) {
  return DynamicJwtFromJSONTyped(json);
}
function DynamicJwtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "kid": json["kid"],
    "aud": json["aud"],
    "iss": json["iss"],
    "sub": json["sub"],
    "exp": !exists(json, "exp") ? void 0 : json["exp"],
    "iat": !exists(json, "iat") ? void 0 : json["iat"],
    "sid": json["sid"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "blockchainAccounts": !exists(json, "blockchain_accounts") ? void 0 : json["blockchain_accounts"].map(JwtBlockchainAccountFromJSON),
    "country": !exists(json, "country") ? void 0 : json["country"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "environmentId": json["environment_id"],
    "familyName": !exists(json, "family_name") ? void 0 : json["family_name"],
    "givenName": !exists(json, "given_name") ? void 0 : json["given_name"],
    "jobTitle": !exists(json, "job_title") ? void 0 : json["job_title"],
    "lastAuthenticatedAccountId": !exists(json, "last_authenticated_account_id") ? void 0 : json["last_authenticated_account_id"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "phoneNumber": !exists(json, "phone_number") ? void 0 : json["phone_number"],
    "missingFields": json["missing_fields"].map(ProjectSettingsKycFromJSON),
    "scope": !exists(json, "scope") ? void 0 : json["scope"],
    "tShirtSize": !exists(json, "t_shirt_size") ? void 0 : json["t_shirt_size"],
    "team": !exists(json, "team") ? void 0 : json["team"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "policiesConsent": !exists(json, "policies_consent") ? void 0 : json["policies_consent"],
    "verifiedAccount": !exists(json, "verified_account") ? void 0 : JwtBlockchainAccountFromJSON(json["verified_account"]),
    "verifiedCredentials": json["verified_credentials"].map(JwtVerifiedCredentialFromJSON),
    "lastVerifiedCredentialId": json["last_verified_credential_id"],
    "firstVisit": !exists(json, "first_visit") ? void 0 : new Date(json["first_visit"]),
    "lastVisit": !exists(json, "last_visit") ? void 0 : new Date(json["last_visit"]),
    "newUser": !exists(json, "new_user") ? void 0 : json["new_user"],
    "btcWallet": !exists(json, "btc_wallet") ? void 0 : json["btc_wallet"],
    "kdaWallet": !exists(json, "kda_wallet") ? void 0 : json["kda_wallet"],
    "ltcWallet": !exists(json, "ltc_wallet") ? void 0 : json["ltc_wallet"],
    "ckbWallet": !exists(json, "ckb_wallet") ? void 0 : json["ckb_wallet"],
    "kasWallet": !exists(json, "kas_wallet") ? void 0 : json["kas_wallet"],
    "dogeWallet": !exists(json, "doge_wallet") ? void 0 : json["doge_wallet"],
    "emailNotification": !exists(json, "email_notification") ? void 0 : json["email_notification"],
    "discordNotification": !exists(json, "discord_notification") ? void 0 : json["discord_notification"],
    "newsletterNotification": !exists(json, "newsletter_notification") ? void 0 : json["newsletter_notification"],
    "metadata": !exists(json, "metadata") ? void 0 : json["metadata"],
    "info": !exists(json, "info") ? void 0 : JwtPayloadDeprecatedInfoFromJSON(json["info"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AttestationConveyancePreference.js
var AttestationConveyancePreference;
(function(AttestationConveyancePreference2) {
  AttestationConveyancePreference2["Direct"] = "direct";
  AttestationConveyancePreference2["Enterprise"] = "enterprise";
  AttestationConveyancePreference2["Indirect"] = "indirect";
  AttestationConveyancePreference2["None"] = "none";
})(AttestationConveyancePreference || (AttestationConveyancePreference = {}));
function AttestationConveyancePreferenceFromJSON(json) {
  return AttestationConveyancePreferenceFromJSONTyped(json);
}
function AttestationConveyancePreferenceFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthModeEnum.js
var AuthModeEnum;
(function(AuthModeEnum2) {
  AuthModeEnum2["Only"] = "connect-only";
  AuthModeEnum2["AndSign"] = "connect-and-sign";
})(AuthModeEnum || (AuthModeEnum = {}));
function AuthModeEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthStorageEnum.js
var AuthStorageEnum;
(function(AuthStorageEnum2) {
  AuthStorageEnum2["Localstorage"] = "localstorage";
  AuthStorageEnum2["Cookie"] = "cookie";
})(AuthStorageEnum || (AuthStorageEnum = {}));
function AuthStorageEnumFromJSON(json) {
  return AuthStorageEnumFromJSONTyped(json);
}
function AuthStorageEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAttachment.js
var AuthenticatorAttachment;
(function(AuthenticatorAttachment2) {
  AuthenticatorAttachment2["CrossPlatform"] = "cross-platform";
  AuthenticatorAttachment2["Platform"] = "platform";
})(AuthenticatorAttachment || (AuthenticatorAttachment = {}));
function AuthenticatorAttachmentFromJSON(json) {
  return AuthenticatorAttachmentFromJSONTyped(json);
}
function AuthenticatorAttachmentFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AuthenticatorAttachmentToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ResidentKeyRequirement.js
var ResidentKeyRequirement;
(function(ResidentKeyRequirement2) {
  ResidentKeyRequirement2["Discouraged"] = "discouraged";
  ResidentKeyRequirement2["Preferred"] = "preferred";
  ResidentKeyRequirement2["Required"] = "required";
})(ResidentKeyRequirement || (ResidentKeyRequirement = {}));
function ResidentKeyRequirementFromJSON(json) {
  return ResidentKeyRequirementFromJSONTyped(json);
}
function ResidentKeyRequirementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserVerificationRequirement.js
var UserVerificationRequirement;
(function(UserVerificationRequirement2) {
  UserVerificationRequirement2["Discouraged"] = "discouraged";
  UserVerificationRequirement2["Preferred"] = "preferred";
  UserVerificationRequirement2["Required"] = "required";
})(UserVerificationRequirement || (UserVerificationRequirement = {}));
function UserVerificationRequirementFromJSON(json) {
  return UserVerificationRequirementFromJSONTyped(json);
}
function UserVerificationRequirementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorTransportProtocol.js
var AuthenticatorTransportProtocol;
(function(AuthenticatorTransportProtocol2) {
  AuthenticatorTransportProtocol2["Internal"] = "AUTHENTICATOR_TRANSPORT_INTERNAL";
  AuthenticatorTransportProtocol2["Usb"] = "AUTHENTICATOR_TRANSPORT_USB";
  AuthenticatorTransportProtocol2["Nfc"] = "AUTHENTICATOR_TRANSPORT_NFC";
  AuthenticatorTransportProtocol2["Ble"] = "AUTHENTICATOR_TRANSPORT_BLE";
  AuthenticatorTransportProtocol2["Hybrid"] = "AUTHENTICATOR_TRANSPORT_HYBRID";
})(AuthenticatorTransportProtocol || (AuthenticatorTransportProtocol = {}));
function AuthenticatorTransportProtocolToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MfaBackupCodeAcknowledgement.js
var MfaBackupCodeAcknowledgement;
(function(MfaBackupCodeAcknowledgement2) {
  MfaBackupCodeAcknowledgement2["Pending"] = "pending";
  MfaBackupCodeAcknowledgement2["Complete"] = "complete";
})(MfaBackupCodeAcknowledgement || (MfaBackupCodeAcknowledgement = {}));
function MfaBackupCodeAcknowledgementFromJSON(json) {
  return MfaBackupCodeAcknowledgementFromJSONTyped(json);
}
function MfaBackupCodeAcknowledgementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function MfaBackupCodeAcknowledgementToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegistrationCredential.js
function PasskeyRegistrationCredentialToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "attestationObject": value.attestationObject,
    "clientDataJson": value.clientDataJson,
    "credentialId": value.credentialId,
    "transports": value.transports.map(AuthenticatorTransportProtocolToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CompletePasskeyRecoveryRequest.js
function CompletePasskeyRecoveryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "attestation": PasskeyRegistrationCredentialToJSON(value.attestation),
    "challenge": value.challenge
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ConnectRequest.js
function ConnectRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "chain": ChainEnumToJSON(value.chain),
    "provider": WalletProviderEnumToJSON(value.provider),
    "walletName": value.walletName,
    "authMode": AuthModeEnumToJSON(value.authMode)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletChainEnum.js
var EmbeddedWalletChainEnum;
(function(EmbeddedWalletChainEnum2) {
  EmbeddedWalletChainEnum2["Evm"] = "EVM";
  EmbeddedWalletChainEnum2["Sol"] = "SOL";
})(EmbeddedWalletChainEnum || (EmbeddedWalletChainEnum = {}));
function EmbeddedWalletChainEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletProviderEnum.js
var EmbeddedWalletProviderEnum;
(function(EmbeddedWalletProviderEnum2) {
  EmbeddedWalletProviderEnum2["Turnkey"] = "turnkey";
  EmbeddedWalletProviderEnum2["Turnkeyhd"] = "turnkeyhd";
})(EmbeddedWalletProviderEnum || (EmbeddedWalletProviderEnum = {}));
function EmbeddedWalletProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateTurnkeyEmbeddedWalletSpecificOpts.js
function CreateTurnkeyEmbeddedWalletSpecificOptsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "attestation": PasskeyRegistrationCredentialToJSON(value.attestation),
    "challenge": value.challenge
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletSpecificOpts.js
function CreateEmbeddedWalletSpecificOptsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return Object.assign({}, CreateTurnkeyEmbeddedWalletSpecificOptsToJSON(value));
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletParams.js
function CreateEmbeddedWalletParamsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chains": value.chains === void 0 ? void 0 : value.chains.map(EmbeddedWalletChainEnumToJSON),
    "chain": EmbeddedWalletChainEnumToJSON(value.chain),
    "embeddedWalletProvider": EmbeddedWalletProviderEnumToJSON(value.embeddedWalletProvider),
    "embeddedWalletSpecificOpts": CreateEmbeddedWalletSpecificOptsToJSON(value.embeddedWalletSpecificOpts),
    "isAuthenticatorAttached": value.isAuthenticatorAttached,
    "passkeyAlias": value.passkeyAlias
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletsRequest.js
function CreateEmbeddedWalletsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "embeddedWallets": value.embeddedWallets.map(CreateEmbeddedWalletParamsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserIdentifierTypeEnum.js
var UserIdentifierTypeEnum;
(function(UserIdentifierTypeEnum2) {
  UserIdentifierTypeEnum2["Email"] = "email";
  UserIdentifierTypeEnum2["Id"] = "id";
  UserIdentifierTypeEnum2["ExternalUserId"] = "externalUserId";
  UserIdentifierTypeEnum2["PhoneNumber"] = "phoneNumber";
  UserIdentifierTypeEnum2["SocialUsername"] = "socialUsername";
})(UserIdentifierTypeEnum || (UserIdentifierTypeEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyStamp.js
function TurnkeyStampToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "stampHeaderName": value.stampHeaderName,
    "stampHeaderValue": value.stampHeaderValue
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeySignedRequest.js
function TurnkeySignedRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "body": value.body,
    "stamp": TurnkeyStampToJSON(value.stamp),
    "url": value.url
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateWalletAccountRequest.js
function CreateWalletAccountRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "turnkeySignedRequest": TurnkeySignedRequestToJSON(value.turnkeySignedRequest)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CurrencyType.js
var CurrencyType;
(function(CurrencyType2) {
  CurrencyType2["Fiat"] = "fiat";
  CurrencyType2["Crypto"] = "crypto";
})(CurrencyType || (CurrencyType = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/TimeUnitEnum.js
var TimeUnitEnum;
(function(TimeUnitEnum2) {
  TimeUnitEnum2["Days"] = "days";
  TimeUnitEnum2["Hours"] = "hours";
  TimeUnitEnum2["Minutes"] = "minutes";
})(TimeUnitEnum || (TimeUnitEnum = {}));
function TimeUnitEnumFromJSON(json) {
  return TimeUnitEnumFromJSONTyped(json);
}
function TimeUnitEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EcdsaValidatorOptions.js
var EcdsaValidatorOptions;
(function(EcdsaValidatorOptions2) {
  EcdsaValidatorOptions2["SignerToEcdsa"] = "zerodev_signer_to_ecdsa";
  EcdsaValidatorOptions2["MultiChain"] = "zerodev_multi_chain";
})(EcdsaValidatorOptions || (EcdsaValidatorOptions = {}));
function EcdsaValidatorOptionsFromJSON(json) {
  return EcdsaValidatorOptionsFromJSONTyped(json);
}
function EcdsaValidatorOptionsFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailProviderResponse.js
function EmailProviderResponseFromJSON(json) {
  return EmailProviderResponseFromJSONTyped(json);
}
function EmailProviderResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "emailProvider": ProviderEnumFromJSON(json["emailProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationCreateRequest.js
function EmailVerificationCreateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "email": value.email,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationCreateResponse.js
function EmailVerificationCreateResponseFromJSON(json) {
  return EmailVerificationCreateResponseFromJSONTyped(json);
}
function EmailVerificationCreateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "verificationUUID": json["verificationUUID"],
    "email": json["email"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationRetryRequest.js
function EmailVerificationRetryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "email": value.email,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationVerifyRequest.js
function EmailVerificationVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "verificationToken": value.verificationToken,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletAuthToken.js
function EmbeddedWalletAuthTokenFromJSON(json) {
  return EmbeddedWalletAuthTokenFromJSONTyped(json);
}
function EmbeddedWalletAuthTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "token": json["token"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletAuthType.js
var EmbeddedWalletAuthType;
(function(EmbeddedWalletAuthType2) {
  EmbeddedWalletAuthType2["Mpc"] = "mpc";
})(EmbeddedWalletAuthType || (EmbeddedWalletAuthType = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletPasscodeClaimRequest.js
function EmbeddedWalletPasscodeClaimRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletSecret.js
function EmbeddedWalletSecretFromJSON(json) {
  return EmbeddedWalletSecretFromJSONTyped(json);
}
function EmbeddedWalletSecretFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletId": json["walletId"],
    "secret": json["secret"],
    "source": !exists(json, "source") ? void 0 : PasswordSourceTypeEnumFromJSON(json["source"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkUser.js
function SdkUserFromJSON(json) {
  return SdkUserFromJSONTyped(json);
}
function SdkUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "projectEnvironmentId": json["projectEnvironmentId"],
    "verifiedCredentials": json["verifiedCredentials"].map(JwtVerifiedCredentialFromJSON),
    "lastVerifiedCredentialId": !exists(json, "lastVerifiedCredentialId") ? void 0 : json["lastVerifiedCredentialId"],
    "sessionId": !exists(json, "sessionId") ? void 0 : json["sessionId"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "country": !exists(json, "country") ? void 0 : json["country"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "firstName": !exists(json, "firstName") ? void 0 : json["firstName"],
    "jobTitle": !exists(json, "jobTitle") ? void 0 : json["jobTitle"],
    "lastName": !exists(json, "lastName") ? void 0 : json["lastName"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "policiesConsent": !exists(json, "policiesConsent") ? void 0 : json["policiesConsent"],
    "tShirtSize": !exists(json, "tShirtSize") ? void 0 : json["tShirtSize"],
    "team": !exists(json, "team") ? void 0 : json["team"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "firstVisit": !exists(json, "firstVisit") ? void 0 : new Date(json["firstVisit"]),
    "lastVisit": !exists(json, "lastVisit") ? void 0 : new Date(json["lastVisit"]),
    "newUser": !exists(json, "newUser") ? void 0 : json["newUser"],
    "metadata": !exists(json, "metadata") ? void 0 : json["metadata"],
    "mfaBackupCodeAcknowledgement": !exists(json, "mfaBackupCodeAcknowledgement") ? void 0 : MfaBackupCodeAcknowledgementFromJSON(json["mfaBackupCodeAcknowledgement"]),
    "btcWallet": !exists(json, "btcWallet") ? void 0 : json["btcWallet"],
    "kdaWallet": !exists(json, "kdaWallet") ? void 0 : json["kdaWallet"],
    "ltcWallet": !exists(json, "ltcWallet") ? void 0 : json["ltcWallet"],
    "ckbWallet": !exists(json, "ckbWallet") ? void 0 : json["ckbWallet"],
    "kasWallet": !exists(json, "kasWallet") ? void 0 : json["kasWallet"],
    "dogeWallet": !exists(json, "dogeWallet") ? void 0 : json["dogeWallet"],
    "emailNotification": !exists(json, "emailNotification") ? void 0 : json["emailNotification"],
    "discordNotification": !exists(json, "discordNotification") ? void 0 : json["discordNotification"],
    "newsletterNotification": !exists(json, "newsletterNotification") ? void 0 : json["newsletterNotification"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "scope": !exists(json, "scope") ? void 0 : json["scope"],
    "missingFields": !exists(json, "missingFields") ? void 0 : json["missingFields"].map(ProjectSettingsKycFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletSecurityMethod.js
var EmbeddedWalletSecurityMethod;
(function(EmbeddedWalletSecurityMethod2) {
  EmbeddedWalletSecurityMethod2["Passkey"] = "passkey";
  EmbeddedWalletSecurityMethod2["Passphrase"] = "passphrase";
})(EmbeddedWalletSecurityMethod || (EmbeddedWalletSecurityMethod = {}));
function EmbeddedWalletSecurityMethodFromJSON(json) {
  return EmbeddedWalletSecurityMethodFromJSONTyped(json);
}
function EmbeddedWalletSecurityMethodFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EnvironmentEnum.js
var EnvironmentEnum;
(function(EnvironmentEnum2) {
  EnvironmentEnum2["Sandbox"] = "sandbox";
  EnvironmentEnum2["Live"] = "live";
})(EnvironmentEnum || (EnvironmentEnum = {}));
function EnvironmentEnumFromJSON(json) {
  return EnvironmentEnumFromJSONTyped(json);
}
function EnvironmentEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExportEmbeddedWalletResponse.js
function ExportEmbeddedWalletResponseFromJSON(json) {
  return ExportEmbeddedWalletResponseFromJSONTyped(json);
}
function ExportEmbeddedWalletResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "exportBundle": json["exportBundle"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalAuthSigninRequest.js
function ExternalAuthSigninRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "jwt": value.jwt,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FarcasterSignInRequest.js
function FarcasterSignInRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "domain": value.domain,
    "nonce": value.nonce,
    "message": value.message,
    "signature": value.signature,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyStorage.js
function PasskeyStorageFromJSON(json) {
  return PasskeyStorageFromJSONTyped(json);
}
function PasskeyStorageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "icon": json["icon"],
    "updatedAt": !exists(json, "updatedAt") ? void 0 : new Date(json["updatedAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserPasskey.js
function UserPasskeyFromJSON(json) {
  return UserPasskeyFromJSONTyped(json);
}
function UserPasskeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "userAgent": !exists(json, "userAgent") ? void 0 : json["userAgent"],
    "origin": !exists(json, "origin") ? void 0 : json["origin"],
    "credentialId": json["credentialId"],
    "createdAt": new Date(json["createdAt"]),
    "updatedAt": !exists(json, "updatedAt") ? void 0 : new Date(json["updatedAt"]),
    "storage": !exists(json, "storage") ? void 0 : PasskeyStorageFromJSON(json["storage"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GetUserPasskeysResponse.js
function GetUserPasskeysResponseFromJSON(json) {
  return GetUserPasskeysResponseFromJSONTyped(json);
}
function GetUserPasskeysResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "passkeys": json["passkeys"].map(UserPasskeyFromJSON),
    "count": json["count"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HealthcheckStatus.js
var HealthcheckStatus;
(function(HealthcheckStatus2) {
  HealthcheckStatus2["Healthy"] = "healthy";
  HealthcheckStatus2["Unhealthy"] = "unhealthy";
})(HealthcheckStatus || (HealthcheckStatus = {}));
function HealthcheckStatusFromJSON(json) {
  return HealthcheckStatusFromJSONTyped(json);
}
function HealthcheckStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HealthcheckResponse.js
function HealthcheckResponseFromJSON(json) {
  return HealthcheckResponseFromJSONTyped(json);
}
function HealthcheckResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "status": HealthcheckStatusFromJSON(json["status"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitEmailAuthRequest.js
function InitEmailAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "turnkeyEmailAuthTargetPublicKey": value.turnkeyEmailAuthTargetPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitEmailAuthResponse.js
function InitEmailAuthResponseFromJSON(json) {
  return InitEmailAuthResponseFromJSONTyped(json);
}
function InitEmailAuthResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeyUserId": json["turnkeyUserId"],
    "turnkeyApiKeyId": json["turnkeyApiKeyId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitPasskeyRecoveryRequest.js
function InitPasskeyRecoveryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "turnkeyRecoveryTargetPublicKey": value.turnkeyRecoveryTargetPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitPasskeyRecoveryResponse.js
function InitPasskeyRecoveryResponseFromJSON(json) {
  return InitPasskeyRecoveryResponseFromJSONTyped(json);
}
function InitPasskeyRecoveryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeyRecoveryUserId": json["turnkeyRecoveryUserId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwksKey.js
function JwksKeyFromJSON(json) {
  return JwksKeyFromJSONTyped(json);
}
function JwksKeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "kid": !exists(json, "kid") ? void 0 : json["kid"],
    "alg": !exists(json, "alg") ? void 0 : json["alg"],
    "kty": !exists(json, "kty") ? void 0 : json["kty"],
    "use": !exists(json, "use") ? void 0 : json["use"],
    "e": !exists(json, "e") ? void 0 : json["e"],
    "n": !exists(json, "n") ? void 0 : json["n"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwksResponse.js
function JwksResponseFromJSON(json) {
  return JwksResponseFromJSONTyped(json);
}
function JwksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keys": json["keys"].map(JwksKeyFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticationExtensionsClientInputs.js
function AuthenticationExtensionsClientInputsFromJSON(json) {
  return AuthenticationExtensionsClientInputsFromJSONTyped(json);
}
function AuthenticationExtensionsClientInputsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "appid": !exists(json, "appid") ? void 0 : json["appid"],
    "credProps": !exists(json, "credProps") ? void 0 : json["credProps"],
    "hmacCreateSecret": !exists(json, "hmacCreateSecret") ? void 0 : json["hmacCreateSecret"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialType.js
var PublicKeyCredentialType;
(function(PublicKeyCredentialType2) {
  PublicKeyCredentialType2["PublicKey"] = "public-key";
})(PublicKeyCredentialType || (PublicKeyCredentialType = {}));
function PublicKeyCredentialTypeFromJSON(json) {
  return PublicKeyCredentialTypeFromJSONTyped(json);
}
function PublicKeyCredentialTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PublicKeyCredentialTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialDescriptor.js
function PublicKeyCredentialDescriptorFromJSON(json) {
  return PublicKeyCredentialDescriptorFromJSONTyped(json);
}
function PublicKeyCredentialDescriptorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": PublicKeyCredentialTypeFromJSON(json["type"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthPasskeyDeviceGetResponseAssertion.js
function MFAAuthPasskeyDeviceGetResponseAssertionFromJSON(json) {
  return MFAAuthPasskeyDeviceGetResponseAssertionFromJSONTyped(json);
}
function MFAAuthPasskeyDeviceGetResponseAssertionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rpId": !exists(json, "rpId") ? void 0 : json["rpId"],
    "challenge": json["challenge"],
    "timeout": !exists(json, "timeout") ? void 0 : json["timeout"],
    "userVerification": !exists(json, "userVerification") ? void 0 : UserVerificationRequirementFromJSON(json["userVerification"]),
    "allowCredentials": !exists(json, "allowCredentials") ? void 0 : json["allowCredentials"].map(PublicKeyCredentialDescriptorFromJSON),
    "extensions": !exists(json, "extensions") ? void 0 : AuthenticationExtensionsClientInputsFromJSON(json["extensions"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFADeviceType.js
var MFADeviceType;
(function(MFADeviceType2) {
  MFADeviceType2["Totp"] = "totp";
  MFADeviceType2["Passkey"] = "passkey";
})(MFADeviceType || (MFADeviceType = {}));
function MFADeviceTypeFromJSON(json) {
  return MFADeviceTypeFromJSONTyped(json);
}
function MFADeviceTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function MFADeviceTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthPasskeyDeviceGetResponse.js
function MFAAuthPasskeyDeviceGetResponseFromJSON(json) {
  return MFAAuthPasskeyDeviceGetResponseFromJSONTyped(json);
}
function MFAAuthPasskeyDeviceGetResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": MFADeviceTypeFromJSON(json["type"]),
    "assertion": MFAAuthPasskeyDeviceGetResponseAssertionFromJSON(json["assertion"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticationExtensionsClientOutputs.js
function AuthenticationExtensionsClientOutputsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "appid": value.appid,
    "credProps": value.credProps,
    "hmacCreateSecret": value.hmacCreateSecret
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAssertionResponse.js
function AuthenticatorAssertionResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "clientDataJSON": value.clientDataJSON,
    "authenticatorData": value.authenticatorData,
    "signature": value.signature,
    "userHandle": value.userHandle
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyAuthRequest.js
function PasskeyAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "rawId": value.rawId,
    "response": AuthenticatorAssertionResponseToJSON(value.response),
    "authenticatorAttachment": AuthenticatorAttachmentToJSON(value.authenticatorAttachment),
    "clientExtensionResults": AuthenticationExtensionsClientOutputsToJSON(value.clientExtensionResults),
    "type": PublicKeyCredentialTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthPasskeyDevicePostRequest.js
function MFAAuthPasskeyDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "assertion": PasskeyAuthRequestToJSON(value.assertion)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateMfaToken.js
function CreateMfaTokenToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "singleUse": value.singleUse
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthRecoveryDevicePostRequest.js
function MFAAuthRecoveryDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthTotpDevicePostRequest.js
function MFAAuthTotpDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFADevice.js
function MFADeviceFromJSON(json) {
  return MFADeviceFromJSONTyped(json);
}
function MFADeviceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": !exists(json, "type") ? void 0 : MFADeviceTypeFromJSON(json["type"]),
    "verified": !exists(json, "verified") ? void 0 : json["verified"],
    "id": !exists(json, "id") ? void 0 : json["id"],
    "createdAt": !exists(json, "createdAt") ? void 0 : new Date(json["createdAt"]),
    "verifiedAt": !exists(json, "verifiedAt") ? void 0 : json["verifiedAt"] === null ? null : new Date(json["verifiedAt"]),
    "_default": !exists(json, "default") ? void 0 : json["default"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAGetRecoveryCodesResponse.js
function MFAGetRecoveryCodesResponseFromJSON(json) {
  return MFAGetRecoveryCodesResponseFromJSONTyped(json);
}
function MFAGetRecoveryCodesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "recoveryCodes": json["recoveryCodes"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAListDevicesResponse.js
function MFAListDevicesResponseFromJSON(json) {
  return MFAListDevicesResponseFromJSONTyped(json);
}
function MFAListDevicesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "devices": json["devices"].map(MFADeviceFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegenRecoveryCodesResponse.js
function MFARegenRecoveryCodesResponseFromJSON(json) {
  return MFARegenRecoveryCodesResponseFromJSONTyped(json);
}
function MFARegenRecoveryCodesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "recoveryCodes": json["recoveryCodes"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorSelectionCriteria.js
function AuthenticatorSelectionCriteriaFromJSON(json) {
  return AuthenticatorSelectionCriteriaFromJSONTyped(json);
}
function AuthenticatorSelectionCriteriaFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "authenticatorAttachment": !exists(json, "authenticatorAttachment") ? void 0 : AuthenticatorAttachmentFromJSON(json["authenticatorAttachment"]),
    "requireResidentKey": !exists(json, "requireResidentKey") ? void 0 : json["requireResidentKey"],
    "residentKey": !exists(json, "residentKey") ? void 0 : ResidentKeyRequirementFromJSON(json["residentKey"]),
    "userVerification": !exists(json, "userVerification") ? void 0 : UserVerificationRequirementFromJSON(json["userVerification"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialParameters.js
function PublicKeyCredentialParametersFromJSON(json) {
  return PublicKeyCredentialParametersFromJSONTyped(json);
}
function PublicKeyCredentialParametersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "alg": json["alg"],
    "type": PublicKeyCredentialTypeFromJSON(json["type"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialRpEntity.js
function PublicKeyCredentialRpEntityFromJSON(json) {
  return PublicKeyCredentialRpEntityFromJSONTyped(json);
}
function PublicKeyCredentialRpEntityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": !exists(json, "id") ? void 0 : json["id"],
    "name": json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialUserEntity.js
function PublicKeyCredentialUserEntityFromJSON(json) {
  return PublicKeyCredentialUserEntityFromJSONTyped(json);
}
function PublicKeyCredentialUserEntityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "displayName": json["displayName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDeviceGetResponseRegistration.js
function MFARegisterPasskeyDeviceGetResponseRegistrationFromJSON(json) {
  return MFARegisterPasskeyDeviceGetResponseRegistrationFromJSONTyped(json);
}
function MFARegisterPasskeyDeviceGetResponseRegistrationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "attestation": !exists(json, "attestation") ? void 0 : AttestationConveyancePreferenceFromJSON(json["attestation"]),
    "rp": PublicKeyCredentialRpEntityFromJSON(json["rp"]),
    "user": PublicKeyCredentialUserEntityFromJSON(json["user"]),
    "challenge": json["challenge"],
    "pubKeyCredParams": json["pubKeyCredParams"].map(PublicKeyCredentialParametersFromJSON),
    "timeout": !exists(json, "timeout") ? void 0 : json["timeout"],
    "authenticatorSelection": !exists(json, "authenticatorSelection") ? void 0 : AuthenticatorSelectionCriteriaFromJSON(json["authenticatorSelection"]),
    "excludeCredentials": !exists(json, "excludeCredentials") ? void 0 : json["excludeCredentials"].map(PublicKeyCredentialDescriptorFromJSON),
    "extensions": !exists(json, "extensions") ? void 0 : AuthenticationExtensionsClientInputsFromJSON(json["extensions"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDeviceGetResponse.js
function MFARegisterPasskeyDeviceGetResponseFromJSON(json) {
  return MFARegisterPasskeyDeviceGetResponseFromJSONTyped(json);
}
function MFARegisterPasskeyDeviceGetResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": MFADeviceTypeFromJSON(json["type"]),
    "registration": MFARegisterPasskeyDeviceGetResponseRegistrationFromJSON(json["registration"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAttestationResponse.js
function AuthenticatorAttestationResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "clientDataJSON": value.clientDataJSON,
    "attestationObject": value.attestationObject,
    "authenticatorData": value.authenticatorData,
    "publicKeyAlgorithm": value.publicKeyAlgorithm,
    "publicKey": value.publicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegisterVerifyRequest.js
function PasskeyRegisterVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "rawId": value.rawId,
    "response": AuthenticatorAttestationResponseToJSON(value.response),
    "authenticatorAttachment": AuthenticatorAttachmentToJSON(value.authenticatorAttachment),
    "clientExtensionResults": AuthenticationExtensionsClientOutputsToJSON(value.clientExtensionResults),
    "type": PublicKeyCredentialTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDevicePostRequest.js
function MFARegisterPasskeyDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "attestation": PasskeyRegisterVerifyRequestToJSON(value.attestation)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterTotpDeviceGetResponse.js
function MFARegisterTotpDeviceGetResponseFromJSON(json) {
  return MFARegisterTotpDeviceGetResponseFromJSONTyped(json);
}
function MFARegisterTotpDeviceGetResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": MFADeviceTypeFromJSON(json["type"]),
    "secret": json["secret"],
    "uri": json["uri"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterTotpDevicePostRequest.js
function MFARegisterTotpDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": MFADeviceTypeToJSON(value.type),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAUpdateDeviceRequest.js
function MFAUpdateDeviceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "default": value._default
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MergeUserConflictResolution.js
function MergeUserConflictResolutionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "userId": value.userId,
    "fieldKey": value.fieldKey,
    "type": KycFieldTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MergeUserConflictResolutions.js
function MergeUserConflictResolutionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mergeUserResolutions": value.mergeUserResolutions === void 0 ? void 0 : value.mergeUserResolutions.map(MergeUserConflictResolutionToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameService.js
function NameServiceFromJSON(json) {
  return NameServiceFromJSONTyped(json);
}
function NameServiceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "registry": !exists(json, "registry") ? void 0 : json["registry"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NativeCurrency.js
function NativeCurrencyFromJSON(json) {
  return NativeCurrencyFromJSONTyped(json);
}
function NativeCurrencyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "decimals": json["decimals"],
    "name": json["name"],
    "symbol": json["symbol"],
    "denom": !exists(json, "denom") ? void 0 : json["denom"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NetworkConfiguration.js
function NetworkConfigurationFromJSON(json) {
  return NetworkConfigurationFromJSONTyped(json);
}
function NetworkConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "lcdUrl": !exists(json, "lcdUrl") ? void 0 : json["lcdUrl"],
    "chainName": !exists(json, "chainName") ? void 0 : json["chainName"],
    "name": json["name"],
    "shortName": json["shortName"],
    "chain": json["chain"],
    "chainId": json["chainId"],
    "nameService": !exists(json, "nameService") ? void 0 : NameServiceFromJSON(json["nameService"]),
    "networkId": json["networkId"],
    "iconUrls": json["iconUrls"],
    "nativeCurrency": NativeCurrencyFromJSON(json["nativeCurrency"]),
    "rpcUrls": json["rpcUrls"],
    "privateCustomerRpcUrls": !exists(json, "privateCustomerRpcUrls") ? void 0 : json["privateCustomerRpcUrls"],
    "blockExplorerUrls": json["blockExplorerUrls"],
    "vanityName": !exists(json, "vanityName") ? void 0 : json["vanityName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NetworkConfigurationResponse.js
function NetworkConfigurationResponseFromJSON(json) {
  return NetworkConfigurationResponseFromJSONTyped(json);
}
function NetworkConfigurationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainName": !exists(json, "chainName") ? void 0 : json["chainName"],
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkConfigurationFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NextViewEnum.js
var NextViewEnum;
(function(NextViewEnum2) {
  NextViewEnum2["Done"] = "done";
  NextViewEnum2["VerifyEmail"] = "verify-email";
  NextViewEnum2["VerifiedAndTransferred"] = "verified-and-transferred";
  NextViewEnum2["VerifySms"] = "verify-sms";
})(NextViewEnum || (NextViewEnum = {}));
function NextViewEnumFromJSON(json) {
  return NextViewEnumFromJSONTyped(json);
}
function NextViewEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NonceResponse.js
function NonceResponseFromJSON(json) {
  return NonceResponseFromJSONTyped(json);
}
function NonceResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nonce": !exists(json, "nonce") ? void 0 : json["nonce"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthInitAuthRequest.js
function OauthInitAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "redirectUrl": value.redirectUrl
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthProviderLoginUrl.js
function OauthProviderLoginUrlFromJSON(json) {
  return OauthProviderLoginUrlFromJSONTyped(json);
}
function OauthProviderLoginUrlFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "url": json["url"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthRequest.js
function OauthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "code": value.code,
    "codeVerifier": value.codeVerifier,
    "state": value.state,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultRequest.js
function OauthResultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "telegramAuthToken": value.telegramAuthToken,
    "code": value.code,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultStatus.js
var OauthResultStatus;
(function(OauthResultStatus2) {
  OauthResultStatus2["Pending"] = "pending";
  OauthResultStatus2["Completed"] = "completed";
})(OauthResultStatus || (OauthResultStatus = {}));
function OauthResultStatusFromJSON(json) {
  return OauthResultStatusFromJSONTyped(json);
}
function OauthResultStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultResponse.js
function OauthResultResponseFromJSON(json) {
  return OauthResultResponseFromJSONTyped(json);
}
function OauthResultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "code": !exists(json, "code") ? void 0 : json["code"],
    "error": !exists(json, "error") ? void 0 : json["error"],
    "status": OauthResultStatusFromJSON(json["status"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PrefetchRequest.js
function PrefetchRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": ChainEnumToJSON(value.chain),
    "publicWalletAddress": value.publicWalletAddress
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Network.js
function NetworkFromJSON(json) {
  return NetworkFromJSONTyped(json);
}
function NetworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "networkId": json["networkId"],
    "chainName": json["chainName"],
    "enabled": json["enabled"],
    "rpcUrl": !exists(json, "rpcUrl") ? void 0 : json["rpcUrl"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsChains.js
function ProjectSettingsChainsFromJSON(json) {
  return ProjectSettingsChainsFromJSONTyped(json);
}
function ProjectSettingsChainsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "enabled": json["enabled"],
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignButton.js
function ProjectSettingsDesignButtonFromJSON(json) {
  return ProjectSettingsDesignButtonFromJSONTyped(json);
}
function ProjectSettingsDesignButtonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "background": !exists(json, "background") ? void 0 : json["background"],
    "fontColor": !exists(json, "fontColor") ? void 0 : json["fontColor"],
    "paddingHeight": !exists(json, "paddingHeight") ? void 0 : json["paddingHeight"],
    "paddingWidth": !exists(json, "paddingWidth") ? void 0 : json["paddingWidth"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignModal.js
function ProjectSettingsDesignModalFromJSON(json) {
  return ProjectSettingsDesignModalFromJSONTyped(json);
}
function ProjectSettingsDesignModalFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "border": !exists(json, "border") ? void 0 : json["border"],
    "brand": !exists(json, "brand") ? void 0 : json["brand"],
    "primaryColor": !exists(json, "primaryColor") ? void 0 : json["primaryColor"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"],
    "theme": !exists(json, "theme") ? void 0 : json["theme"],
    "view": !exists(json, "view") ? void 0 : json["view"],
    "template": !exists(json, "template") ? void 0 : json["template"],
    "displayOrder": !exists(json, "displayOrder") ? void 0 : json["displayOrder"],
    "emailOnly": !exists(json, "emailOnly") ? void 0 : json["emailOnly"],
    "showWalletsButton": !exists(json, "showWalletsButton") ? void 0 : json["showWalletsButton"],
    "emailSubmitButtonInsideInput": !exists(json, "emailSubmitButtonInsideInput") ? void 0 : json["emailSubmitButtonInsideInput"],
    "splitEmailAndSocial": !exists(json, "splitEmailAndSocial") ? void 0 : json["splitEmailAndSocial"],
    "socialAboveEmail": !exists(json, "socialAboveEmail") ? void 0 : json["socialAboveEmail"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignWidget.js
function ProjectSettingsDesignWidgetFromJSON(json) {
  return ProjectSettingsDesignWidgetFromJSONTyped(json);
}
function ProjectSettingsDesignWidgetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "backgroundColor": !exists(json, "backgroundColor") ? void 0 : json["backgroundColor"],
    "border": !exists(json, "border") ? void 0 : json["border"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"],
    "textColor": !exists(json, "textColor") ? void 0 : json["textColor"],
    "theme": !exists(json, "theme") ? void 0 : json["theme"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesign.js
function ProjectSettingsDesignFromJSON(json) {
  return ProjectSettingsDesignFromJSONTyped(json);
}
function ProjectSettingsDesignFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "modal": !exists(json, "modal") ? void 0 : ProjectSettingsDesignModalFromJSON(json["modal"]),
    "button": !exists(json, "button") ? void 0 : ProjectSettingsDesignButtonFromJSON(json["button"]),
    "widget": !exists(json, "widget") ? void 0 : ProjectSettingsDesignWidgetFromJSON(json["widget"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsGeneral.js
function ProjectSettingsGeneralFromJSON(json) {
  return ProjectSettingsGeneralFromJSONTyped(json);
}
function ProjectSettingsGeneralFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "displayName": !exists(json, "displayName") ? void 0 : json["displayName"],
    "supportEmail": !exists(json, "supportEmail") ? void 0 : json["supportEmail"],
    "supportText": !exists(json, "supportText") ? void 0 : json["supportText"],
    "appLogo": !exists(json, "appLogo") ? void 0 : json["appLogo"],
    "imageUserNotInAccessList": !exists(json, "imageUserNotInAccessList") ? void 0 : json["imageUserNotInAccessList"],
    "imageUserInAccessList": !exists(json, "imageUserInAccessList") ? void 0 : json["imageUserInAccessList"],
    "supportUrls": !exists(json, "supportUrls") ? void 0 : json["supportUrls"],
    "collectUserDataWelcomeHeader": !exists(json, "collectUserDataWelcomeHeader") ? void 0 : json["collectUserDataWelcomeHeader"],
    "collectUserDataWelcomeMessage": !exists(json, "collectUserDataWelcomeMessage") ? void 0 : json["collectUserDataWelcomeMessage"],
    "skipOptionalKYCFieldDuringOnboarding": !exists(json, "skipOptionalKYCFieldDuringOnboarding") ? void 0 : json["skipOptionalKYCFieldDuringOnboarding"],
    "emailCompanyName": !exists(json, "emailCompanyName") ? void 0 : json["emailCompanyName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsPrivacy.js
function ProjectSettingsPrivacyFromJSON(json) {
  return ProjectSettingsPrivacyFromJSONTyped(json);
}
function ProjectSettingsPrivacyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "collectIp": !exists(json, "collectIp") ? void 0 : json["collectIp"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MobileSettings.js
function MobileSettingsFromJSON(json) {
  return MobileSettingsFromJSONTyped(json);
}
function MobileSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "deeplinkUrlsEnabled": !exists(json, "deeplinkUrlsEnabled") ? void 0 : json["deeplinkUrlsEnabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkAccountAbstraction.js
function ProjectSettingsSdkAccountAbstractionFromJSON(json) {
  return ProjectSettingsSdkAccountAbstractionFromJSONTyped(json);
}
function ProjectSettingsSdkAccountAbstractionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "allWallets": !exists(json, "allWallets") ? void 0 : json["allWallets"],
    "allUsers": !exists(json, "allUsers") ? void 0 : json["allUsers"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignInProviderEnum.js
var SignInProviderEnum;
(function(SignInProviderEnum2) {
  SignInProviderEnum2["Dynamic"] = "dynamic";
  SignInProviderEnum2["MagicLink"] = "magicLink";
  SignInProviderEnum2["Blocto"] = "blocto";
  SignInProviderEnum2["Turnkey"] = "turnkey";
  SignInProviderEnum2["CoinbaseWaas"] = "coinbaseWaas";
})(SignInProviderEnum || (SignInProviderEnum = {}));
function SignInProviderEnumFromJSON(json) {
  return SignInProviderEnumFromJSONTyped(json);
}
function SignInProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkEmailSignIn.js
function ProjectSettingsSdkEmailSignInFromJSON(json) {
  return ProjectSettingsSdkEmailSignInFromJSONTyped(json);
}
function ProjectSettingsSdkEmailSignInFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signInProvider": !exists(json, "signInProvider") ? void 0 : SignInProviderEnumFromJSON(json["signInProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ChainConfiguration.js
function ChainConfigurationFromJSON(json) {
  return ChainConfigurationFromJSONTyped(json);
}
function ChainConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "enabled": json["enabled"],
    "primary": json["primary"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Duration.js
function DurationFromJSON(json) {
  return DurationFromJSONTyped(json);
}
function DurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "unit": TimeUnitEnumFromJSON(json["unit"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedSecurityMethod.js
function SupportedSecurityMethodFromJSON(json) {
  return SupportedSecurityMethodFromJSONTyped(json);
}
function SupportedSecurityMethodFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isDefault": json["isDefault"],
    "isEnabled": json["isEnabled"],
    "isPermanentAuthenticator": json["isPermanentAuthenticator"],
    "listPosition": json["listPosition"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedSecurityMethods.js
function SupportedSecurityMethodsFromJSON(json) {
  return SupportedSecurityMethodsFromJSONTyped(json);
}
function SupportedSecurityMethodsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "passkey": !exists(json, "passkey") ? void 0 : SupportedSecurityMethodFromJSON(json["passkey"]),
    "email": !exists(json, "email") ? void 0 : SupportedSecurityMethodFromJSON(json["email"]),
    "password": !exists(json, "password") ? void 0 : SupportedSecurityMethodFromJSON(json["password"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkEmbeddedWallets.js
function ProjectSettingsSdkEmbeddedWalletsFromJSON(json) {
  return ProjectSettingsSdkEmbeddedWalletsFromJSONTyped(json);
}
function ProjectSettingsSdkEmbeddedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "automaticEmbeddedWalletCreation": !exists(json, "automaticEmbeddedWalletCreation") ? void 0 : json["automaticEmbeddedWalletCreation"],
    "showEmbeddedWalletActionsUI": !exists(json, "showEmbeddedWalletActionsUI") ? void 0 : json["showEmbeddedWalletActionsUI"],
    "emailRecoveryEnabled": !exists(json, "emailRecoveryEnabled") ? void 0 : json["emailRecoveryEnabled"],
    "forceAuthenticatorAtSignup": !exists(json, "forceAuthenticatorAtSignup") ? void 0 : json["forceAuthenticatorAtSignup"],
    "allowSkippingAuthenticatorAtSignup": !exists(json, "allowSkippingAuthenticatorAtSignup") ? void 0 : json["allowSkippingAuthenticatorAtSignup"],
    "sessionKeyDuration": !exists(json, "sessionKeyDuration") ? void 0 : DurationFromJSON(json["sessionKeyDuration"]),
    "supportedSecurityMethods": !exists(json, "supportedSecurityMethods") ? void 0 : SupportedSecurityMethodsFromJSON(json["supportedSecurityMethods"]),
    "chainConfigurations": !exists(json, "chainConfigurations") ? void 0 : json["chainConfigurations"].map(ChainConfigurationFromJSON),
    "domainEnabledByProvider": !exists(json, "domainEnabledByProvider") ? void 0 : json["domainEnabledByProvider"],
    "defaultWalletVersion": !exists(json, "defaultWalletVersion") ? void 0 : EmbeddedWalletVersionEnumFromJSON(json["defaultWalletVersion"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SocialSignInProviderEnum.js
var SocialSignInProviderEnum;
(function(SocialSignInProviderEnum2) {
  SocialSignInProviderEnum2["Apple"] = "apple";
  SocialSignInProviderEnum2["Bitbucket"] = "bitbucket";
  SocialSignInProviderEnum2["Coinbasesocial"] = "coinbasesocial";
  SocialSignInProviderEnum2["Discord"] = "discord";
  SocialSignInProviderEnum2["Facebook"] = "facebook";
  SocialSignInProviderEnum2["Farcaster"] = "farcaster";
  SocialSignInProviderEnum2["Github"] = "github";
  SocialSignInProviderEnum2["Gitlab"] = "gitlab";
  SocialSignInProviderEnum2["Google"] = "google";
  SocialSignInProviderEnum2["Instagram"] = "instagram";
  SocialSignInProviderEnum2["Linkedin"] = "linkedin";
  SocialSignInProviderEnum2["Microsoft"] = "microsoft";
  SocialSignInProviderEnum2["Twitch"] = "twitch";
  SocialSignInProviderEnum2["Twitter"] = "twitter";
  SocialSignInProviderEnum2["Telegram"] = "telegram";
})(SocialSignInProviderEnum || (SocialSignInProviderEnum = {}));
function SocialSignInProviderEnumFromJSON(json) {
  return SocialSignInProviderEnumFromJSONTyped(json);
}
function SocialSignInProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SocialSignInProvider.js
function SocialSignInProviderFromJSON(json) {
  return SocialSignInProviderFromJSONTyped(json);
}
function SocialSignInProviderFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": SocialSignInProviderEnumFromJSON(json["provider"]),
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkSocialSignIn.js
function ProjectSettingsSdkSocialSignInFromJSON(json) {
  return ProjectSettingsSdkSocialSignInFromJSONTyped(json);
}
function ProjectSettingsSdkSocialSignInFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signInProvider": !exists(json, "signInProvider") ? void 0 : SignInProviderEnumFromJSON(json["signInProvider"]),
    "providers": !exists(json, "providers") ? void 0 : json["providers"].map(SocialSignInProviderFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkWalletConnect.js
function ProjectSettingsSdkWalletConnectFromJSON(json) {
  return ProjectSettingsSdkWalletConnectFromJSONTyped(json);
}
function ProjectSettingsSdkWalletConnectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "projectId": !exists(json, "projectId") ? void 0 : json["projectId"],
    "v2Enabled": !exists(json, "v2Enabled") ? void 0 : json["v2Enabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSectionAlignment.js
var SdkViewSectionAlignment;
(function(SdkViewSectionAlignment2) {
  SdkViewSectionAlignment2["Center"] = "center";
  SdkViewSectionAlignment2["Left"] = "left";
  SdkViewSectionAlignment2["Right"] = "right";
})(SdkViewSectionAlignment || (SdkViewSectionAlignment = {}));
function SdkViewSectionAlignmentFromJSON(json) {
  return SdkViewSectionAlignmentFromJSONTyped(json);
}
function SdkViewSectionAlignmentFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSectionType.js
var SdkViewSectionType;
(function(SdkViewSectionType2) {
  SdkViewSectionType2["Email"] = "email";
  SdkViewSectionType2["EmailAndPhone"] = "emailAndPhone";
  SdkViewSectionType2["Phone"] = "phone";
  SdkViewSectionType2["Separator"] = "separator";
  SdkViewSectionType2["Social"] = "social";
  SdkViewSectionType2["Text"] = "text";
  SdkViewSectionType2["Wallet"] = "wallet";
})(SdkViewSectionType || (SdkViewSectionType = {}));
function SdkViewSectionTypeFromJSON(json) {
  return SdkViewSectionTypeFromJSONTyped(json);
}
function SdkViewSectionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSection.js
function SdkViewSectionFromJSON(json) {
  return SdkViewSectionFromJSONTyped(json);
}
function SdkViewSectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": SdkViewSectionTypeFromJSON(json["type"]),
    "label": !exists(json, "label") ? void 0 : json["label"],
    "numOfItemsToDisplay": !exists(json, "numOfItemsToDisplay") ? void 0 : json["numOfItemsToDisplay"],
    "defaultItem": !exists(json, "defaultItem") ? void 0 : json["defaultItem"],
    "alignment": !exists(json, "alignment") ? void 0 : SdkViewSectionAlignmentFromJSON(json["alignment"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewType.js
var SdkViewType;
(function(SdkViewType2) {
  SdkViewType2["Login"] = "login";
})(SdkViewType || (SdkViewType = {}));
function SdkViewTypeFromJSON(json) {
  return SdkViewTypeFromJSONTyped(json);
}
function SdkViewTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkView.js
function SdkViewFromJSON(json) {
  return SdkViewFromJSONTyped(json);
}
function SdkViewFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": SdkViewTypeFromJSON(json["type"]),
    "sections": !exists(json, "sections") ? void 0 : json["sections"].map(SdkViewSectionFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdk.js
function ProjectSettingsSdkFromJSON(json) {
  return ProjectSettingsSdkFromJSONTyped(json);
}
function ProjectSettingsSdkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "emailSignIn": !exists(json, "emailSignIn") ? void 0 : ProjectSettingsSdkEmailSignInFromJSON(json["emailSignIn"]),
    "socialSignIn": !exists(json, "socialSignIn") ? void 0 : ProjectSettingsSdkSocialSignInFromJSON(json["socialSignIn"]),
    "multiWallet": !exists(json, "multiWallet") ? void 0 : json["multiWallet"],
    "multiWalletUnlinkDisabled": !exists(json, "multiWalletUnlinkDisabled") ? void 0 : json["multiWalletUnlinkDisabled"],
    "mobile": !exists(json, "mobile") ? void 0 : MobileSettingsFromJSON(json["mobile"]),
    "confirmWalletTransfers": !exists(json, "confirmWalletTransfers") ? void 0 : json["confirmWalletTransfers"],
    "onrampFunding": !exists(json, "onrampFunding") ? void 0 : json["onrampFunding"],
    "passkeyEmbeddedWalletEnabled": !exists(json, "passkeyEmbeddedWalletEnabled") ? void 0 : json["passkeyEmbeddedWalletEnabled"],
    "automaticEmbeddedWalletCreation": !exists(json, "automaticEmbeddedWalletCreation") ? void 0 : json["automaticEmbeddedWalletCreation"],
    "passkeyEmbeddedWalletRecoveryEnabled": !exists(json, "passkeyEmbeddedWalletRecoveryEnabled") ? void 0 : json["passkeyEmbeddedWalletRecoveryEnabled"],
    "embeddedWalletSecurityMethods": !exists(json, "embeddedWalletSecurityMethods") ? void 0 : json["embeddedWalletSecurityMethods"].map(EmbeddedWalletSecurityMethodFromJSON),
    "embeddedWallets": !exists(json, "embeddedWallets") ? void 0 : ProjectSettingsSdkEmbeddedWalletsFromJSON(json["embeddedWallets"]),
    "walletConnect": !exists(json, "walletConnect") ? void 0 : ProjectSettingsSdkWalletConnectFromJSON(json["walletConnect"]),
    "confirmEmailProviderForVerify": !exists(json, "confirmEmailProviderForVerify") ? void 0 : json["confirmEmailProviderForVerify"],
    "displayDynamicMessaging": !exists(json, "displayDynamicMessaging") ? void 0 : json["displayDynamicMessaging"],
    "hideNetworkInDynamicWidget": !exists(json, "hideNetworkInDynamicWidget") ? void 0 : json["hideNetworkInDynamicWidget"],
    "preventOrphanedAccounts": !exists(json, "preventOrphanedAccounts") ? void 0 : json["preventOrphanedAccounts"],
    "views": !exists(json, "views") ? void 0 : json["views"].map(SdkViewFromJSON),
    "accountAbstraction": !exists(json, "accountAbstraction") ? void 0 : ProjectSettingsSdkAccountAbstractionFromJSON(json["accountAbstraction"]),
    "enableMultiAsset": !exists(json, "enableMultiAsset") ? void 0 : json["enableMultiAsset"],
    "showFiat": !exists(json, "showFiat") ? void 0 : json["showFiat"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthSettings.js
function AuthSettingsFromJSON(json) {
  return AuthSettingsFromJSONTyped(json);
}
function AuthSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "storage": json["storage"].map(AuthStorageEnumFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalAuth.js
function ExternalAuthFromJSON(json) {
  return ExternalAuthFromJSONTyped(json);
}
function ExternalAuthFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "iss": !exists(json, "iss") ? void 0 : json["iss"],
    "aud": !exists(json, "aud") ? void 0 : json["aud"],
    "jwksUrl": !exists(json, "jwksUrl") ? void 0 : json["jwksUrl"],
    "cookieName": !exists(json, "cookieName") ? void 0 : json["cookieName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HCaptchaSettings.js
function HCaptchaSettingsFromJSON(json) {
  return HCaptchaSettingsFromJSONTyped(json);
}
function HCaptchaSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "secretKey": !exists(json, "secretKey") ? void 0 : json["secretKey"],
    "siteKey": !exists(json, "siteKey") ? void 0 : json["siteKey"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFASettings.js
function MFASettingsFromJSON(json) {
  return MFASettingsFromJSONTyped(json);
}
function MFASettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "required": !exists(json, "required") ? void 0 : json["required"],
    "availableMethods": !exists(json, "availableMethods") ? void 0 : json["availableMethods"].map(MFADeviceTypeFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSecurity.js
function ProjectSettingsSecurityFromJSON(json) {
  return ProjectSettingsSecurityFromJSONTyped(json);
}
function ProjectSettingsSecurityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "jwtDuration": !exists(json, "jwtDuration") ? void 0 : DurationFromJSON(json["jwtDuration"]),
    "hCaptcha": !exists(json, "hCaptcha") ? void 0 : HCaptchaSettingsFromJSON(json["hCaptcha"]),
    "mfa": !exists(json, "mfa") ? void 0 : MFASettingsFromJSON(json["mfa"]),
    "auth": !exists(json, "auth") ? void 0 : AuthSettingsFromJSON(json["auth"]),
    "externalAuth": !exists(json, "externalAuth") ? void 0 : ExternalAuthFromJSON(json["externalAuth"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderAgreement.js
function ProviderAgreementFromJSON(json) {
  return ProviderAgreementFromJSONTyped(json);
}
function ProviderAgreementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "termsUrl": json["termsUrl"],
    "email": json["email"],
    "userId": json["userId"],
    "createdAt": new Date(json["createdAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsCountryCode.js
function SmsCountryCodeFromJSON(json) {
  return SmsCountryCodeFromJSONTyped(json);
}
function SmsCountryCodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isoCountryCode": json["isoCountryCode"],
    "phoneCountryCode": json["phoneCountryCode"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Provider.js
var ProviderEntryPointVersionEnum;
(function(ProviderEntryPointVersionEnum2) {
  ProviderEntryPointVersionEnum2["V6"] = "v6";
  ProviderEntryPointVersionEnum2["V7"] = "v7";
})(ProviderEntryPointVersionEnum || (ProviderEntryPointVersionEnum = {}));
var ProviderKernelVersionEnum;
(function(ProviderKernelVersionEnum2) {
  ProviderKernelVersionEnum2["V24"] = "v2_4";
  ProviderKernelVersionEnum2["V30"] = "v3_0";
  ProviderKernelVersionEnum2["V31"] = "v3_1";
})(ProviderKernelVersionEnum || (ProviderKernelVersionEnum = {}));
function ProviderFromJSON(json) {
  return ProviderFromJSONTyped(json);
}
function ProviderFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": !exists(json, "id") ? void 0 : json["id"],
    "provider": ProviderEnumFromJSON(json["provider"]),
    "enabledAt": !exists(json, "enabledAt") ? void 0 : json["enabledAt"] === null ? null : new Date(json["enabledAt"]),
    "clientId": !exists(json, "clientId") ? void 0 : json["clientId"],
    "clientSecret": !exists(json, "clientSecret") ? void 0 : json["clientSecret"],
    "providerProjectId": !exists(json, "providerProjectId") ? void 0 : json["providerProjectId"],
    "authorizationUrl": !exists(json, "authorizationUrl") ? void 0 : json["authorizationUrl"],
    "redirectUrl": !exists(json, "redirectUrl") ? void 0 : json["redirectUrl"],
    "defaultChainId": !exists(json, "defaultChainId") ? void 0 : json["defaultChainId"],
    "defaultChain": !exists(json, "defaultChain") ? void 0 : json["defaultChain"],
    "keyExportUrl": !exists(json, "keyExportUrl") ? void 0 : json["keyExportUrl"],
    "termsAcceptedByUser": !exists(json, "termsAcceptedByUser") ? void 0 : ProviderAgreementFromJSON(json["termsAcceptedByUser"]),
    "appleKeyId": !exists(json, "appleKeyId") ? void 0 : json["appleKeyId"],
    "appleTeamId": !exists(json, "appleTeamId") ? void 0 : json["appleTeamId"],
    "accountSid": !exists(json, "accountSid") ? void 0 : json["accountSid"],
    "twilioNumber": !exists(json, "twilioNumber") ? void 0 : json["twilioNumber"],
    "enabledCountries": !exists(json, "enabledCountries") ? void 0 : json["enabledCountries"].map(SmsCountryCodeFromJSON),
    "entryPointVersion": !exists(json, "entryPointVersion") ? void 0 : json["entryPointVersion"],
    "kernelVersion": !exists(json, "kernelVersion") ? void 0 : json["kernelVersion"],
    "ecdsaProviderType": !exists(json, "ecdsaProviderType") ? void 0 : EcdsaValidatorOptionsFromJSON(json["ecdsaProviderType"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettings.js
function ProjectSettingsFromJSON(json) {
  return ProjectSettingsFromJSONTyped(json);
}
function ProjectSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "environmentName": !exists(json, "environmentName") ? void 0 : EnvironmentEnumFromJSON(json["environmentName"]),
    "chains": json["chains"].map(ProjectSettingsChainsFromJSON),
    "customFields": !exists(json, "customFields") ? void 0 : json["customFields"].map(ProjectSettingsKycFromJSON),
    "kyc": json["kyc"].map(ProjectSettingsKycFromJSON),
    "design": ProjectSettingsDesignFromJSON(json["design"]),
    "general": ProjectSettingsGeneralFromJSON(json["general"]),
    "privacy": ProjectSettingsPrivacyFromJSON(json["privacy"]),
    "providers": !exists(json, "providers") ? void 0 : json["providers"].map(ProviderFromJSON),
    "sdk": ProjectSettingsSdkFromJSON(json["sdk"]),
    "security": ProjectSettingsSecurityFromJSON(json["security"]),
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkConfigurationResponseFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublishEventsEvents.js
var PublishEventsEventsTypeEnum;
(function(PublishEventsEventsTypeEnum2) {
  PublishEventsEventsTypeEnum2["Track"] = "track";
})(PublishEventsEventsTypeEnum || (PublishEventsEventsTypeEnum = {}));
function PublishEventsEventsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "anonymousId": value.anonymousId,
    "event": value.event,
    "properties": value.properties,
    "type": value.type
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublishEvents.js
function PublishEventsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "events": value.events.map(PublishEventsEventsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RegisterEmbeddedWalletSessionKeyResponse.js
function RegisterEmbeddedWalletSessionKeyResponseFromJSON(json) {
  return RegisterEmbeddedWalletSessionKeyResponseFromJSONTyped(json);
}
function RegisterEmbeddedWalletSessionKeyResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "publicKey": json["publicKey"],
    "expiresAt": json["expiresAt"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RegisterSessionKeyRequest.js
function RegisterSessionKeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "publicKey": value.publicKey,
    "prevSessionKeySignature": value.prevSessionKeySignature
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ScanWebsiteUrlRequest.js
function ScanWebsiteUrlRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "url": value.url
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ScanWebsiteUrlResponse.js
function ScanWebsiteUrlResponseFromJSON(json) {
  return ScanWebsiteUrlResponseFromJSONTyped(json);
}
function ScanWebsiteUrlResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isMalicious": json["isMalicious"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NextJsSettings.js
function NextJsSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": value.version
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ReactSettings.js
function ReactSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": value.version
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FrameworkSettings.js
function FrameworkSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "react": ReactSettingsToJSON(value.react),
    "nextjs": NextJsSettingsToJSON(value.nextjs)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkSettingsRequest.js
function SdkSettingsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "dynamicContextProps": value.dynamicContextProps,
    "dynamicWagmiSettings": value.dynamicWagmiSettings,
    "frameworkSettings": FrameworkSettingsToJSON(value.frameworkSettings)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationCreateRequest.js
function SmsVerificationCreateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "phoneCountryCode": value.phoneCountryCode,
    "phoneNumber": value.phoneNumber,
    "isoCountryCode": value.isoCountryCode,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationCreateResponse.js
function SmsVerificationCreateResponseFromJSON(json) {
  return SmsVerificationCreateResponseFromJSONTyped(json);
}
function SmsVerificationCreateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "verificationUUID": json["verificationUUID"],
    "phoneNumber": json["phoneNumber"],
    "phoneCountryCode": json["phoneCountryCode"],
    "isoCountryCode": json["isoCountryCode"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationRetryRequest.js
function SmsVerificationRetryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "phoneCountryCode": value.phoneCountryCode,
    "phoneNumber": value.phoneNumber,
    "isoCountryCode": value.isoCountryCode,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationVerifyRequest.js
function SmsVerificationVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "verificationToken": value.verificationToken,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SolanaTransactionOptimizationRequest.js
function SolanaTransactionOptimizationRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "transaction": value.transaction,
    "address": value.address
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SolanaTransactionOptimizationResponse.js
function SolanaTransactionOptimizationResponseFromJSON(json) {
  return SolanaTransactionOptimizationResponseFromJSONTyped(json);
}
function SolanaTransactionOptimizationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transaction": json["transaction"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OnrampConfiguration.js
function OnrampConfigurationFromJSON(json) {
  return OnrampConfigurationFromJSONTyped(json);
}
function OnrampConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": !exists(json, "provider") ? void 0 : ProviderEnumFromJSON(json["provider"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "iconUrl": !exists(json, "iconUrl") ? void 0 : json["iconUrl"],
    "url": !exists(json, "url") ? void 0 : json["url"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedOnrampsResponse.js
function SupportedOnrampsResponseFromJSON(json) {
  return SupportedOnrampsResponseFromJSONTyped(json);
}
function SupportedOnrampsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "onramps": !exists(json, "onramps") ? void 0 : json["onramps"].map(OnrampConfigurationFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TelegramUser.js
function TelegramUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "firstName": value.firstName,
    "lastName": value.lastName,
    "hash": value.hash,
    "photoURL": value.photoURL,
    "username": value.username,
    "authDate": value.authDate
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TelegramPostRequest.js
function TelegramPostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "telegramUser": TelegramUserToJSON(value.telegramUser)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TokenBalance.js
function TokenBalanceFromJSON(json) {
  return TokenBalanceFromJSONTyped(json);
}
function TokenBalanceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "networkId": !exists(json, "networkId") ? void 0 : json["networkId"],
    "address": json["address"],
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoURI": json["logoURI"],
    "balance": json["balance"],
    "rawBalance": json["rawBalance"],
    "price": !exists(json, "price") ? void 0 : json["price"],
    "marketValue": !exists(json, "marketValue") ? void 0 : json["marketValue"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyWalletAccount.js
function TurnkeyWalletAccountFromJSON(json) {
  return TurnkeyWalletAccountFromJSONTyped(json);
}
function TurnkeyWalletAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "curve": json["curve"],
    "pathFormat": json["pathFormat"],
    "path": json["path"],
    "addressFormat": json["addressFormat"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyCreateWalletAccountsRequestBodyParameters.js
function TurnkeyCreateWalletAccountsRequestBodyParametersFromJSON(json) {
  return TurnkeyCreateWalletAccountsRequestBodyParametersFromJSONTyped(json);
}
function TurnkeyCreateWalletAccountsRequestBodyParametersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletId": json["walletId"],
    "accounts": json["accounts"].map(TurnkeyWalletAccountFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyCreateWalletAccountsRequestBody.js
function TurnkeyCreateWalletAccountsRequestBodyFromJSON(json) {
  return TurnkeyCreateWalletAccountsRequestBodyFromJSONTyped(json);
}
function TurnkeyCreateWalletAccountsRequestBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "organizationId": json["organizationId"],
    "parameters": TurnkeyCreateWalletAccountsRequestBodyParametersFromJSON(json["parameters"]),
    "timestampMs": json["timestampMs"],
    "type": json["type"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UnprocessableEntityErrorCode.js
var UnprocessableEntityErrorCode;
(function(UnprocessableEntityErrorCode2) {
  UnprocessableEntityErrorCode2["EmailAlreadyExists"] = "email_already_exists";
  UnprocessableEntityErrorCode2["AllowlistAlreadyExists"] = "allowlist_already_exists";
  UnprocessableEntityErrorCode2["AllowlistEntryAlreadyExists"] = "allowlist_entry_already_exists";
  UnprocessableEntityErrorCode2["ReassignWalletError"] = "reassign_wallet_error";
  UnprocessableEntityErrorCode2["ReassignWalletConfirm"] = "reassign_wallet_confirm";
  UnprocessableEntityErrorCode2["MembersCannotDeleteThemself"] = "members_cannot_delete_themself";
  UnprocessableEntityErrorCode2["UsernameAlreadyExists"] = "username_already_exists";
  UnprocessableEntityErrorCode2["WrongEmailVerificationToken"] = "wrong_email_verification_token";
  UnprocessableEntityErrorCode2["WrongSmsVerificationToken"] = "wrong_sms_verification_token";
  UnprocessableEntityErrorCode2["InvalidEmailVerification"] = "invalid_email_verification";
  UnprocessableEntityErrorCode2["InvalidSmsVerification"] = "invalid_sms_verification";
  UnprocessableEntityErrorCode2["InvalidVerification"] = "invalid_verification";
  UnprocessableEntityErrorCode2["InvalidPosition"] = "invalid_position";
  UnprocessableEntityErrorCode2["TooManySmsVerificationAttempts"] = "too_many_sms_verification_attempts";
  UnprocessableEntityErrorCode2["TooManyEmailVerificationAttempts"] = "too_many_email_verification_attempts";
  UnprocessableEntityErrorCode2["TooManyVerificationAttempts"] = "too_many_verification_attempts";
  UnprocessableEntityErrorCode2["OrganizationNameAlreadyExists"] = "organization_name_already_exists";
  UnprocessableEntityErrorCode2["ProjectNameAlreadyExists"] = "project_name_already_exists";
  UnprocessableEntityErrorCode2["WalletNotDeployed"] = "wallet_not_deployed";
  UnprocessableEntityErrorCode2["EmailVerificationRequired"] = "email_verification_required";
  UnprocessableEntityErrorCode2["PhoneVerificationRequired"] = "phone_verification_required";
  UnprocessableEntityErrorCode2["InviteAddressRequired"] = "invite_address_required";
  UnprocessableEntityErrorCode2["ProviderNotAvailable"] = "provider_not_available";
  UnprocessableEntityErrorCode2["ForbiddenUnlinkRequest"] = "forbidden_unlink_request";
  UnprocessableEntityErrorCode2["InvalidUnlinkRequest"] = "invalid_unlink_request";
  UnprocessableEntityErrorCode2["TooManyApiTokens"] = "too_many_api_tokens";
  UnprocessableEntityErrorCode2["LockTimeout"] = "lock_timeout";
  UnprocessableEntityErrorCode2["LockTooManyAttempts"] = "lock_too_many_attempts";
  UnprocessableEntityErrorCode2["NftTokenGatingNotSupportedForChain"] = "nft_token_gating_not_supported_for_chain";
  UnprocessableEntityErrorCode2["EmptyChainName"] = "empty_chain_name";
  UnprocessableEntityErrorCode2["NoEnabledEmailProvider"] = "no_enabled_email_provider";
  UnprocessableEntityErrorCode2["NoEnabledSmsProvider"] = "no_enabled_sms_provider";
  UnprocessableEntityErrorCode2["InvalidKeyExportUrl"] = "invalid_key_export_url";
  UnprocessableEntityErrorCode2["InvalidDynamicProps"] = "invalid_dynamic_props";
  UnprocessableEntityErrorCode2["TooManyRequests"] = "too_many_requests";
  UnprocessableEntityErrorCode2["TooManyOrganizationsForUser"] = "too_many_organizations_for_user";
  UnprocessableEntityErrorCode2["TooManyProjectsForOrganization"] = "too_many_projects_for_organization";
  UnprocessableEntityErrorCode2["EmailAssociatedWithDifferentProvider"] = "email_associated_with_different_provider";
  UnprocessableEntityErrorCode2["UserHasAlreadyAccountWithEmail"] = "user_has_already_account_with_email";
  UnprocessableEntityErrorCode2["UserHasAlreadyAccountWithPhoneNumber"] = "user_has_already_account_with_phone_number";
  UnprocessableEntityErrorCode2["OtherVerifyFailure"] = "other_verify_failure";
  UnprocessableEntityErrorCode2["EmailTiedToEmbeddedWallet"] = "email_tied_to_embedded_wallet";
  UnprocessableEntityErrorCode2["InvalidInvite"] = "invalid_invite";
  UnprocessableEntityErrorCode2["SocialAccountAlreadyExists"] = "social_account_already_exists";
  UnprocessableEntityErrorCode2["InvalidEmailAddress"] = "invalid_email_address";
  UnprocessableEntityErrorCode2["InvalidGate"] = "invalid_gate";
  UnprocessableEntityErrorCode2["ConflictingEmbeddedWalletProviders"] = "conflicting_embedded_wallet_providers";
  UnprocessableEntityErrorCode2["InvalidUser"] = "invalid_user";
  UnprocessableEntityErrorCode2["InvalidCorsOrigins"] = "invalid_cors_origins";
  UnprocessableEntityErrorCode2["InvalidMobileDeeplinkUrls"] = "invalid_mobile_deeplink_urls";
  UnprocessableEntityErrorCode2["UnauthorizedMobileDeeplinkUrl"] = "unauthorized_mobile_deeplink_url";
  UnprocessableEntityErrorCode2["InvalidPrivateKeyFormat"] = "invalid_private_key_format";
  UnprocessableEntityErrorCode2["InvalidEmbeddedWalletSettings"] = "invalid_embedded_wallet_settings";
  UnprocessableEntityErrorCode2["WalletNotSupportPasskey"] = "wallet_not_support_passkey";
  UnprocessableEntityErrorCode2["RecoveryEmailUnavailableOrInvalid"] = "recovery_email_unavailable_or_invalid";
  UnprocessableEntityErrorCode2["ConnectError"] = "connect_error";
  UnprocessableEntityErrorCode2["InvalidWalletName"] = "invalid_wallet_name";
  UnprocessableEntityErrorCode2["InvalidWalletAddress"] = "invalid_wallet_address";
  UnprocessableEntityErrorCode2["EmailRecoveryDisabled"] = "email_recovery_disabled";
  UnprocessableEntityErrorCode2["NoCompatibleWalletServiceEnabled"] = "no_compatible_wallet_service_enabled";
  UnprocessableEntityErrorCode2["MissingAaProjectId"] = "missing_aa_project_id";
  UnprocessableEntityErrorCode2["LinkedEmbeddedWallet"] = "linked_embedded_wallet";
  UnprocessableEntityErrorCode2["InvalidMpcEnvironment"] = "invalid_mpc_environment";
  UnprocessableEntityErrorCode2["InvalidRegex"] = "invalid_regex";
  UnprocessableEntityErrorCode2["RepeatedOptions"] = "repeated_options";
  UnprocessableEntityErrorCode2["MissingPhoneNumberOrEmail"] = "missing_phone_number_or_email";
  UnprocessableEntityErrorCode2["DuplicateExists"] = "duplicate_exists";
  UnprocessableEntityErrorCode2["MfaDeviceNotFound"] = "mfa_device_not_found";
  UnprocessableEntityErrorCode2["MfaInvalidCode"] = "mfa_invalid_code";
  UnprocessableEntityErrorCode2["MfaInvalidRequest"] = "mfa_invalid_request";
  UnprocessableEntityErrorCode2["InvalidPhone"] = "invalid_phone";
  UnprocessableEntityErrorCode2["GateExists"] = "gate_exists";
  UnprocessableEntityErrorCode2["InvalidEmbeddedWalletChainsConfiguration"] = "invalid_embedded_wallet_chains_configuration";
  UnprocessableEntityErrorCode2["MergeAccountsConfirmation"] = "merge_accounts_confirmation";
  UnprocessableEntityErrorCode2["MergeAccountsInvalid"] = "merge_accounts_invalid";
  UnprocessableEntityErrorCode2["InvalidWalletId"] = "invalid_wallet_id";
  UnprocessableEntityErrorCode2["UnableToFetchBalances"] = "unable_to_fetch_balances";
  UnprocessableEntityErrorCode2["CannotSwitchToUnique"] = "cannot_switch_to_unique";
  UnprocessableEntityErrorCode2["CustomFieldDataNotUnique"] = "custom_field_data_not_unique";
  UnprocessableEntityErrorCode2["MetadataSizeExceeded"] = "metadata_size_exceeded";
  UnprocessableEntityErrorCode2["InvalidCustomHostname"] = "invalid_custom_hostname";
  UnprocessableEntityErrorCode2["BlockedUserCannotTransferWallet"] = "blocked_user_cannot_transfer_wallet";
  UnprocessableEntityErrorCode2["FeatureNotEnabledInSuborg"] = "feature_not_enabled_in_suborg";
  UnprocessableEntityErrorCode2["InvalidUsername"] = "invalid_username";
  UnprocessableEntityErrorCode2["InvalidExternalAuth"] = "invalid_external_auth";
  UnprocessableEntityErrorCode2["InvalidChainAddressMatch"] = "invalid_chain_address_match";
  UnprocessableEntityErrorCode2["InvalidUpdate"] = "invalid_update";
  UnprocessableEntityErrorCode2["CannotDeleteLastProject"] = "cannot_delete_last_project";
  UnprocessableEntityErrorCode2["NoHdWalletFound"] = "no_hd_wallet_found";
  UnprocessableEntityErrorCode2["WalletAccountExistsForChain"] = "wallet_account_exists_for_chain";
  UnprocessableEntityErrorCode2["TooManyEmbeddedWalletsForUser"] = "too_many_embedded_wallets_for_user";
  UnprocessableEntityErrorCode2["TooManyEmbeddedWalletsPerChainForUser"] = "too_many_embedded_wallets_per_chain_for_user";
  UnprocessableEntityErrorCode2["InvalidSessionPublicKey"] = "invalid_session_public_key";
})(UnprocessableEntityErrorCode || (UnprocessableEntityErrorCode = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateRecoveryEmailRequest.js
function UpdateRecoveryEmailRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "turnkeySignedRequest": TurnkeySignedRequestToJSON(value.turnkeySignedRequest)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateSelfResponse.js
function UpdateSelfResponseFromJSON(json) {
  return UpdateSelfResponseFromJSONTyped(json);
}
function UpdateSelfResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mfaToken": !exists(json, "mfaToken") ? void 0 : json["mfaToken"],
    "jwt": !exists(json, "jwt") ? void 0 : json["jwt"],
    "user": SdkUserFromJSON(json["user"]),
    "minifiedJwt": !exists(json, "minifiedJwt") ? void 0 : json["minifiedJwt"],
    "expiresAt": json["expiresAt"],
    "nextView": NextViewEnumFromJSON(json["nextView"]),
    "emailVerification": !exists(json, "emailVerification") ? void 0 : EmailVerificationCreateResponseFromJSON(json["emailVerification"]),
    "smsVerification": !exists(json, "smsVerification") ? void 0 : SmsVerificationCreateResponseFromJSON(json["smsVerification"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateUserPasskeyRequest.js
function UpdateUserPasskeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "alias": value.alias
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserFields.js
function UserFieldsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "email": value.email,
    "alias": value.alias,
    "firstName": value.firstName,
    "lastName": value.lastName,
    "jobTitle": value.jobTitle,
    "phoneNumber": value.phoneNumber,
    "tShirtSize": value.tShirtSize,
    "team": value.team,
    "policiesConsent": value.policiesConsent,
    "country": value.country,
    "username": value.username,
    "captchaToken": value.captchaToken,
    "metadata": value.metadata,
    "mfaBackupCodeAcknowledgement": MfaBackupCodeAcknowledgementToJSON(value.mfaBackupCodeAcknowledgement),
    "btcWallet": value.btcWallet,
    "kdaWallet": value.kdaWallet,
    "ltcWallet": value.ltcWallet,
    "ckbWallet": value.ckbWallet,
    "kasWallet": value.kasWallet,
    "dogeWallet": value.dogeWallet,
    "emailNotification": value.emailNotification,
    "discordNotification": value.discordNotification,
    "newsletterNotification": value.newsletterNotification
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserWalletSelectionRequest.js
function UserWalletSelectionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthProviderRequest.js
function OauthProviderRequestFromJSON(json) {
  return OauthProviderRequestFromJSONTyped(json);
}
function OauthProviderRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": !exists(json, "provider") ? void 0 : ProviderEnumFromJSON(json["provider"]),
    "accessToken": !exists(json, "accessToken") ? void 0 : json["accessToken"],
    "didToken": !exists(json, "didToken") ? void 0 : json["didToken"]
  };
}
function OauthProviderRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "provider": ProviderEnumToJSON(value.provider),
    "accessToken": value.accessToken,
    "didToken": value.didToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyRequest.js
function VerifyRequestFromJSON(json) {
  return VerifyRequestFromJSONTyped(json);
}
function VerifyRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "oauth": !exists(json, "oauth") ? void 0 : OauthProviderRequestFromJSON(json["oauth"]),
    "signedMessage": json["signedMessage"],
    "messageToSign": json["messageToSign"],
    "publicWalletAddress": json["publicWalletAddress"],
    "chain": ChainEnumFromJSON(json["chain"]),
    "walletName": json["walletName"],
    "walletProvider": WalletProviderEnumFromJSON(json["walletProvider"]),
    "skipEmptyAccountCheck": !exists(json, "skipEmptyAccountCheck") ? void 0 : json["skipEmptyAccountCheck"],
    "captchaToken": !exists(json, "captchaToken") ? void 0 : json["captchaToken"],
    "network": !exists(json, "network") ? void 0 : json["network"],
    "additionalWalletAddresses": !exists(json, "additionalWalletAddresses") ? void 0 : json["additionalWalletAddresses"].map(WalletAdditionalAddressFromJSON),
    "backup": !exists(json, "backup") ? void 0 : json["backup"],
    "password": !exists(json, "password") ? void 0 : json["password"],
    "passwordSource": !exists(json, "passwordSource") ? void 0 : PasswordSourceTypeEnumFromJSON(json["passwordSource"]),
    "sessionPublicKey": !exists(json, "sessionPublicKey") ? void 0 : json["sessionPublicKey"]
  };
}
function VerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "oauth": OauthProviderRequestToJSON(value.oauth),
    "signedMessage": value.signedMessage,
    "messageToSign": value.messageToSign,
    "publicWalletAddress": value.publicWalletAddress,
    "chain": ChainEnumToJSON(value.chain),
    "walletName": value.walletName,
    "walletProvider": WalletProviderEnumToJSON(value.walletProvider),
    "skipEmptyAccountCheck": value.skipEmptyAccountCheck,
    "captchaToken": value.captchaToken,
    "network": value.network,
    "additionalWalletAddresses": value.additionalWalletAddresses === void 0 ? void 0 : value.additionalWalletAddresses.map(WalletAdditionalAddressToJSON),
    "backup": value.backup,
    "password": value.password,
    "passwordSource": PasswordSourceTypeEnumToJSON(value.passwordSource),
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyResponse.js
function VerifyResponseFromJSON(json) {
  return VerifyResponseFromJSONTyped(json);
}
function VerifyResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mfaToken": !exists(json, "mfaToken") ? void 0 : json["mfaToken"],
    "jwt": !exists(json, "jwt") ? void 0 : json["jwt"],
    "user": SdkUserFromJSON(json["user"]),
    "minifiedJwt": !exists(json, "minifiedJwt") ? void 0 : json["minifiedJwt"],
    "expiresAt": json["expiresAt"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyUnlinkRequest.js
function VerifyUnlinkRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "verifiedCrentialId": value.verifiedCrentialId,
    "primaryWalletId": value.primaryWalletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/apis/SDKApi.js
var SDKApi = class extends BaseAPI {
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaPasskeyDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaPasskeyDevice.");
      }
      if (requestParameters.mFAAuthPasskeyDevicePostRequest === null || requestParameters.mFAAuthPasskeyDevicePostRequest === void 0) {
        throw new RequiredError("mFAAuthPasskeyDevicePostRequest", "Required parameter requestParameters.mFAAuthPasskeyDevicePostRequest was null or undefined when calling authMfaPasskeyDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFAAuthPasskeyDevicePostRequestToJSON(requestParameters.mFAAuthPasskeyDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaPasskeyDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.authMfaPasskeyDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Auth Passkey MFA device
   */
  authMfaPasskeyDeviceChallengeRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaPasskeyDeviceChallenge.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAAuthPasskeyDeviceGetResponseFromJSON(jsonValue));
    });
  }
  /**
   * Auth Passkey MFA device
   */
  authMfaPasskeyDeviceChallenge(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.authMfaPasskeyDeviceChallengeRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaPasskeyDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaPasskeyDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaPasskeyDeviceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.authMfaPasskeyDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaRecovery.");
      }
      if (requestParameters.mFAAuthRecoveryDevicePostRequest === null || requestParameters.mFAAuthRecoveryDevicePostRequest === void 0) {
        throw new RequiredError("mFAAuthRecoveryDevicePostRequest", "Required parameter requestParameters.mFAAuthRecoveryDevicePostRequest was null or undefined when calling authMfaRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFAAuthRecoveryDevicePostRequestToJSON(requestParameters.mFAAuthRecoveryDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaRecovery(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.authMfaRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaRecoveryOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaRecoveryOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaRecoveryOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.authMfaRecoveryOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaTotpDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaTotpDevice.");
      }
      if (requestParameters.mFAAuthTotpDevicePostRequest === null || requestParameters.mFAAuthTotpDevicePostRequest === void 0) {
        throw new RequiredError("mFAAuthTotpDevicePostRequest", "Required parameter requestParameters.mFAAuthTotpDevicePostRequest was null or undefined when calling authMfaTotpDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFAAuthTotpDevicePostRequestToJSON(requestParameters.mFAAuthTotpDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaTotpDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.authMfaTotpDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaTotpDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaTotpDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaTotpDeviceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.authMfaTotpDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Claim a pregenerated embedded wallet
   */
  claimEmbeddedWalletRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling claimEmbeddedWallet.");
      }
      if (requestParameters.embeddedWalletPasscodeClaimRequest === null || requestParameters.embeddedWalletPasscodeClaimRequest === void 0) {
        throw new RequiredError("embeddedWalletPasscodeClaimRequest", "Required parameter requestParameters.embeddedWalletPasscodeClaimRequest was null or undefined when calling claimEmbeddedWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode/claim`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: EmbeddedWalletPasscodeClaimRequestToJSON(requestParameters.embeddedWalletPasscodeClaimRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Claim a pregenerated embedded wallet
   */
  claimEmbeddedWallet(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.claimEmbeddedWalletRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  claimEmbeddedWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling claimEmbeddedWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode/claim`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  claimEmbeddedWalletOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.claimEmbeddedWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   */
  completePasskeyRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling completePasskeyRecovery.");
      }
      if (requestParameters.completePasskeyRecoveryRequest === null || requestParameters.completePasskeyRecoveryRequest === void 0) {
        throw new RequiredError("completePasskeyRecoveryRequest", "Required parameter requestParameters.completePasskeyRecoveryRequest was null or undefined when calling completePasskeyRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: CompletePasskeyRecoveryRequestToJSON(requestParameters.completePasskeyRecoveryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   */
  completePasskeyRecovery(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.completePasskeyRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize email verification process
   */
  createEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmailVerification.");
      }
      if (requestParameters.emailVerificationCreateRequest === null || requestParameters.emailVerificationCreateRequest === void 0) {
        throw new RequiredError("emailVerificationCreateRequest", "Required parameter requestParameters.emailVerificationCreateRequest was null or undefined when calling createEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationCreateRequestToJSON(requestParameters.emailVerificationCreateRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize email verification process
   */
  createEmailVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.createEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.createEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Create one or more embedded wallets for a user
   * Create one or more new embedded wallets for a user
   */
  createEmbeddedWalletsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmbeddedWallets.");
      }
      if (requestParameters.createEmbeddedWalletsRequest === null || requestParameters.createEmbeddedWalletsRequest === void 0) {
        throw new RequiredError("createEmbeddedWalletsRequest", "Required parameter requestParameters.createEmbeddedWalletsRequest was null or undefined when calling createEmbeddedWallets.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateEmbeddedWalletsRequestToJSON(requestParameters.createEmbeddedWalletsRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create one or more embedded wallets for a user
   * Create one or more new embedded wallets for a user
   */
  createEmbeddedWallets(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.createEmbeddedWalletsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmbeddedWalletsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmbeddedWalletsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmbeddedWalletsOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.createEmbeddedWalletsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Generate new recovery codes for user
   */
  createNewRecoveryCodesRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createNewRecoveryCodes.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegenRecoveryCodesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Generate new recovery codes for user
   */
  createNewRecoveryCodes(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.createNewRecoveryCodesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize sms verification process
   */
  createSmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createSmsVerification.");
      }
      if (requestParameters.smsVerificationCreateRequest === null || requestParameters.smsVerificationCreateRequest === void 0) {
        throw new RequiredError("smsVerificationCreateRequest", "Required parameter requestParameters.smsVerificationCreateRequest was null or undefined when calling createSmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationCreateRequestToJSON(requestParameters.smsVerificationCreateRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SmsVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize sms verification process
   */
  createSmsVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.createSmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createSmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createSmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createSmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.createSmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to send minimal wallet information for a connect-only or connect-first visitor.
   * Create a visit
   */
  createVisitRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createVisit.");
      }
      if (requestParameters.connectRequest === null || requestParameters.connectRequest === void 0) {
        throw new RequiredError("connectRequest", "Required parameter requestParameters.connectRequest was null or undefined when calling createVisit.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/connect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ConnectRequestToJSON(requestParameters.connectRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Endpoint to send minimal wallet information for a connect-only or connect-first visitor.
   * Create a visit
   */
  createVisit(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.createVisitRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   */
  createWalletAccountRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createWalletAccount.");
      }
      if (requestParameters.createWalletAccountRequest === null || requestParameters.createWalletAccountRequest === void 0) {
        throw new RequiredError("createWalletAccountRequest", "Required parameter requestParameters.createWalletAccountRequest was null or undefined when calling createWalletAccount.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateWalletAccountRequestToJSON(requestParameters.createWalletAccountRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   */
  createWalletAccount(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.createWalletAccountRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Delete a device (if not default device)
   */
  deleteMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deleteMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling deleteMfaDevice.");
      }
      if (requestParameters.xMfaAuthToken === null || requestParameters.xMfaAuthToken === void 0) {
        throw new RequiredError("xMfaAuthToken", "Required parameter requestParameters.xMfaAuthToken was null or undefined when calling deleteMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (requestParameters.xMfaAuthToken !== void 0 && requestParameters.xMfaAuthToken !== null) {
        headerParameters["x-mfa-auth-token"] = String(requestParameters.xMfaAuthToken);
      }
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Delete a device (if not default device)
   */
  deleteMfaDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.deleteMfaDeviceRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling emailAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/emailAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailAuthOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.emailAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailProviderOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling emailProviderOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailProvider`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailProviderOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.emailProviderOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Requests an export of an embedded wallet
   * Requests an export of an embedded wallet
   */
  embeddedWalletExportRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling embeddedWalletExport.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling embeddedWalletExport.");
      }
      if (requestParameters.activityId === null || requestParameters.activityId === void 0) {
        throw new RequiredError("activityId", "Required parameter requestParameters.activityId was null or undefined when calling embeddedWalletExport.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/activities/{activityId}/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))).replace(`{${"activityId"}}`, encodeURIComponent(String(requestParameters.activityId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ExportEmbeddedWalletResponseFromJSON(jsonValue));
    });
  }
  /**
   * Requests an export of an embedded wallet
   * Requests an export of an embedded wallet
   */
  embeddedWalletExport(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.embeddedWalletExportRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletExportOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling embeddedWalletExportOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling embeddedWalletExportOptions.");
      }
      if (requestParameters.activityId === null || requestParameters.activityId === void 0) {
        throw new RequiredError("activityId", "Required parameter requestParameters.activityId was null or undefined when calling embeddedWalletExportOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/activities/{activityId}/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))).replace(`{${"activityId"}}`, encodeURIComponent(String(requestParameters.activityId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletExportOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.embeddedWalletExportOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   */
  eventsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling eventsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/events`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   */
  eventsOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.eventsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to sign-in using a token issued by an external auth provider
   */
  externalAuthSigninRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthSignin.");
      }
      if (requestParameters.externalAuthSigninRequest === null || requestParameters.externalAuthSigninRequest === void 0) {
        throw new RequiredError("externalAuthSigninRequest", "Required parameter requestParameters.externalAuthSigninRequest was null or undefined when calling externalAuthSignin.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ExternalAuthSigninRequestToJSON(requestParameters.externalAuthSigninRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Endpoint to sign-in using a token issued by an external auth provider
   */
  externalAuthSignin(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.externalAuthSigninRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthSigninOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthSigninOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthSigninOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.externalAuthSigninOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to verify using a token issued by an external auth provider
   */
  externalAuthVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthVerify.");
      }
      if (requestParameters.externalAuthSigninRequest === null || requestParameters.externalAuthSigninRequest === void 0) {
        throw new RequiredError("externalAuthSigninRequest", "Required parameter requestParameters.externalAuthSigninRequest was null or undefined when calling externalAuthVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ExternalAuthSigninRequestToJSON(requestParameters.externalAuthSigninRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Endpoint to verify using a token issued by an external auth provider
   */
  externalAuthVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.externalAuthVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthVerifyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.externalAuthVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Farcaster SignIn endpoint to exchange SIWF data
   * Farcaster provider SignIn endpoint
   */
  farcasterSignInRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: FarcasterSignInRequestToJSON(requestParameters.farcasterSignInRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Farcaster SignIn endpoint to exchange SIWF data
   * Farcaster provider SignIn endpoint
   */
  farcasterSignIn(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.farcasterSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterSignInOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.farcasterSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Farcaster Verify endpoint to exchange SIWF data
   * Farcaster provider Verify endpoint
   */
  farcasterVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: FarcasterSignInRequestToJSON(requestParameters.farcasterSignInRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Farcaster Verify endpoint to exchange SIWF data
   * Farcaster provider Verify endpoint
   */
  farcasterVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.farcasterVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterVerifyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.farcasterVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the token balances for an account
   */
  getAccountBalancesRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAccountBalances.");
      }
      if (requestParameters.chainName === null || requestParameters.chainName === void 0) {
        throw new RequiredError("chainName", "Required parameter requestParameters.chainName was null or undefined when calling getAccountBalances.");
      }
      if (requestParameters.accountAddress === null || requestParameters.accountAddress === void 0) {
        throw new RequiredError("accountAddress", "Required parameter requestParameters.accountAddress was null or undefined when calling getAccountBalances.");
      }
      const queryParameters = {};
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.accountAddress !== void 0) {
        queryParameters["accountAddress"] = requestParameters.accountAddress;
      }
      if (requestParameters.includePrices !== void 0) {
        queryParameters["includePrices"] = requestParameters.includePrices;
      }
      if (requestParameters.includeNative !== void 0) {
        queryParameters["includeNative"] = requestParameters.includeNative;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/chains/{chainName}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"chainName"}}`, encodeURIComponent(String(requestParameters.chainName))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenBalanceFromJSON));
    });
  }
  /**
   * Get the token balances for an account
   */
  getAccountBalances(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getAccountBalancesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getAccountBalancesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.chainName === null || requestParameters.chainName === void 0) {
        throw new RequiredError("chainName", "Required parameter requestParameters.chainName was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.networkId === null || requestParameters.networkId === void 0) {
        throw new RequiredError("networkId", "Required parameter requestParameters.networkId was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.accountAddress === null || requestParameters.accountAddress === void 0) {
        throw new RequiredError("accountAddress", "Required parameter requestParameters.accountAddress was null or undefined when calling getAccountBalancesOptions.");
      }
      const queryParameters = {};
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.accountAddress !== void 0) {
        queryParameters["accountAddress"] = requestParameters.accountAddress;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/chains/{chainName}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"chainName"}}`, encodeURIComponent(String(requestParameters.chainName))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getAccountBalancesOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getAccountBalancesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get auth token for given embedded wallet type
   */
  getAuthTokenRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthToken.");
      }
      const queryParameters = {};
      if (requestParameters.type !== void 0) {
        queryParameters["type"] = requestParameters.type;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/authToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletAuthTokenFromJSON(jsonValue));
    });
  }
  /**
   * Get auth token for given embedded wallet type
   */
  getAuthToken(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getAuthTokenRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getAuthTokenOptsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthTokenOpts.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/authToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getAuthTokenOpts(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getAuthTokenOptsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Fetch user profile for the current authenticated user
   */
  getAuthenticatedUserRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthenticatedUser.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SdkUserFromJSON(jsonValue));
    });
  }
  /**
   * Fetch user profile for the current authenticated user
   */
  getAuthenticatedUser(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getAuthenticatedUserRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Generates the turnkey request body for a user\'s create wallet account request
   * Generates the turnkey request body for a user\'s create wallet account request
   */
  getCreateWalletAccountRequestRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getCreateWalletAccountRequest.");
      }
      if (requestParameters.chain === null || requestParameters.chain === void 0) {
        throw new RequiredError("chain", "Required parameter requestParameters.chain was null or undefined when calling getCreateWalletAccountRequest.");
      }
      const queryParameters = {};
      if (requestParameters.chain !== void 0) {
        queryParameters["chain"] = requestParameters.chain;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts/createRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => TurnkeyCreateWalletAccountsRequestBodyFromJSON(jsonValue));
    });
  }
  /**
   * Generates the turnkey request body for a user\'s create wallet account request
   * Generates the turnkey request body for a user\'s create wallet account request
   */
  getCreateWalletAccountRequest(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getCreateWalletAccountRequestRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Return the email provider to be used for signing in with a given email. If an external provider such as magicLink is disabled, this endpoint would return emailOnly. If an external provider such as magicLink is enabled, it will return emailOnly when the email already exists in Dynamic and it is associated with a wallet, otherwise it will return magicLink.
   * Get signin email provider
   */
  getEmailProviderRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmailProvider.");
      }
      if (requestParameters.email === null || requestParameters.email === void 0) {
        throw new RequiredError("email", "Required parameter requestParameters.email was null or undefined when calling getEmailProvider.");
      }
      const queryParameters = {};
      if (requestParameters.email !== void 0) {
        queryParameters["email"] = requestParameters.email;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailProvider`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailProviderResponseFromJSON(jsonValue));
    });
  }
  /**
   * Return the email provider to be used for signing in with a given email. If an external provider such as magicLink is disabled, this endpoint would return emailOnly. If an external provider such as magicLink is enabled, it will return emailOnly when the email already exists in Dynamic and it is associated with a wallet, otherwise it will return magicLink.
   * Get signin email provider
   */
  getEmailProvider(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getEmailProviderRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletBackupOptionRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletBackupOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletBackupOption(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getEmbeddedWalletBackupOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Return the backup key for the embedded wallet of the authenticated user
   */
  getEmbeddedWalletBackupsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletBackups.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletSecretFromJSON(jsonValue));
    });
  }
  /**
   * Return the backup key for the embedded wallet of the authenticated user
   */
  getEmbeddedWalletBackups(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getEmbeddedWalletBackupsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Return the passcode for the pregenerated embedded wallet of the authenticated user
   */
  getEmbeddedWalletPasscodeRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletPasscode.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletSecretFromJSON(jsonValue));
    });
  }
  /**
   * Return the passcode for the pregenerated embedded wallet of the authenticated user
   */
  getEmbeddedWalletPasscode(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getEmbeddedWalletPasscodeRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletPasscodeOptionRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletPasscodeOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletPasscodeOption(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getEmbeddedWalletPasscodeOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the environment\'s settings
   */
  getEnvironmentSettingsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEnvironmentSettings.");
      }
      const queryParameters = {};
      if (requestParameters.sdkVersion !== void 0) {
        queryParameters["sdkVersion"] = requestParameters.sdkVersion;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ProjectSettingsFromJSON(jsonValue));
    });
  }
  /**
   * Get the environment\'s settings
   */
  getEnvironmentSettings(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getEnvironmentSettingsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Health check endpoint to check for uptime of API.
   */
  getHealthcheckRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getHealthcheck.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/healthcheck`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => HealthcheckResponseFromJSON(jsonValue));
    });
  }
  /**
   * Health check endpoint to check for uptime of API.
   */
  getHealthcheck(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getHealthcheckRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getHealthcheckOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getHealthcheckOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/healthcheck`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getHealthcheckOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getHealthcheckOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Find jwks for public key
   */
  getJwksByEnvironmentIdRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getJwksByEnvironmentId.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/.well-known/jwks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => JwksResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find jwks for public key
   */
  getJwksByEnvironmentId(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getJwksByEnvironmentIdRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the current user\'s MFA by device id
   */
  getMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling getMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFADeviceFromJSON(jsonValue));
    });
  }
  /**
   * Get the current user\'s MFA by device id
   */
  getMfaDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getMfaDeviceOptions.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling getMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Find the configuration for the enabled networks associated to an environment
   */
  getNetworksConfigurationByEnvIdRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getNetworksConfigurationByEnvId.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(NetworkConfigurationResponseFromJSON));
    });
  }
  /**
   * Find the configuration for the enabled networks associated to an environment
   */
  getNetworksConfigurationByEnvId(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getNetworksConfigurationByEnvIdRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Create nonce for authentication flow
   */
  getNonceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getNonce.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/nonce`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => NonceResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create nonce for authentication flow
   */
  getNonce(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getNonceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get recovery codes
   */
  getRecoveryCodesRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getRecoveryCodes.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAGetRecoveryCodesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get recovery codes
   */
  getRecoveryCodes(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getRecoveryCodesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Find the configuration for the enabled onramps associated to an environment
   * Configuration for enabled onramps
   */
  getSupportedOnrampsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getSupportedOnramps.");
      }
      if (requestParameters.walletAddress === null || requestParameters.walletAddress === void 0) {
        throw new RequiredError("walletAddress", "Required parameter requestParameters.walletAddress was null or undefined when calling getSupportedOnramps.");
      }
      if (requestParameters.chain === null || requestParameters.chain === void 0) {
        throw new RequiredError("chain", "Required parameter requestParameters.chain was null or undefined when calling getSupportedOnramps.");
      }
      const queryParameters = {};
      if (requestParameters.walletAddress !== void 0) {
        queryParameters["walletAddress"] = requestParameters.walletAddress;
      }
      if (requestParameters.chain !== void 0) {
        queryParameters["chain"] = requestParameters.chain;
      }
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.token !== void 0) {
        queryParameters["token"] = requestParameters.token;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SupportedOnrampsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find the configuration for the enabled onramps associated to an environment
   * Configuration for enabled onramps
   */
  getSupportedOnramps(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getSupportedOnrampsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get HTML with rendered Telegram login widget
   */
  getTelegramAuthRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getTelegramAuth.");
      }
      if (requestParameters.state === null || requestParameters.state === void 0) {
        throw new RequiredError("state", "Required parameter requestParameters.state was null or undefined when calling getTelegramAuth.");
      }
      const queryParameters = {};
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Get HTML with rendered Telegram login widget
   */
  getTelegramAuth(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getTelegramAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the current user\'s MFA Devices
   */
  getUserMfaDevicesRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserMfaDevices.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAListDevicesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get the current user\'s MFA Devices
   */
  getUserMfaDevices(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getUserMfaDevicesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getUserPasskeysRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserPasskeys.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GetUserPasskeysResponseFromJSON(jsonValue));
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getUserPasskeys(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.getUserPasskeysRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * This endpoint initializes a secure oauth authentication sequence by providing the state and current url path to the API.
   * Initialize oauth auth sequence
   */
  initAuthRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initAuth.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling initAuth.");
      }
      if (requestParameters.oauthInitAuthRequest === null || requestParameters.oauthInitAuthRequest === void 0) {
        throw new RequiredError("oauthInitAuthRequest", "Required parameter requestParameters.oauthInitAuthRequest was null or undefined when calling initAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/initAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthInitAuthRequestToJSON(requestParameters.oauthInitAuthRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * This endpoint initializes a secure oauth authentication sequence by providing the state and current url path to the API.
   * Initialize oauth auth sequence
   */
  initAuth(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initAuthRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  initAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initAuthOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling initAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/initAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  initAuthOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Initialize the email authentication process for a user\'s embedded wallet
   * Initialize the email authentication process for a user\'s embedded wallet
   */
  initEmailAuthRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initEmailAuth.");
      }
      if (requestParameters.initEmailAuthRequest === null || requestParameters.initEmailAuthRequest === void 0) {
        throw new RequiredError("initEmailAuthRequest", "Required parameter requestParameters.initEmailAuthRequest was null or undefined when calling initEmailAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/emailAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: InitEmailAuthRequestToJSON(requestParameters.initEmailAuthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => InitEmailAuthResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize the email authentication process for a user\'s embedded wallet
   * Initialize the email authentication process for a user\'s embedded wallet
   */
  initEmailAuth(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.initEmailAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   */
  initPasskeyRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initPasskeyRecovery.");
      }
      if (requestParameters.initPasskeyRecoveryRequest === null || requestParameters.initPasskeyRecoveryRequest === void 0) {
        throw new RequiredError("initPasskeyRecoveryRequest", "Required parameter requestParameters.initPasskeyRecoveryRequest was null or undefined when calling initPasskeyRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: InitPasskeyRecoveryRequestToJSON(requestParameters.initPasskeyRecoveryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => InitPasskeyRecoveryResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   */
  initPasskeyRecovery(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.initPasskeyRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  jwksOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling jwksOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/.well-known/jwks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  jwksOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.jwksOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaDevicesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling listMfaDevicesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaDevicesOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.listMfaDevicesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update SDK settings for a specific environment
   */
  logDynamicSdkSettingsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling logDynamicSdkSettings.");
      }
      if (requestParameters.sdkSettingsRequest === null || requestParameters.sdkSettingsRequest === void 0) {
        throw new RequiredError("sdkSettingsRequest", "Required parameter requestParameters.sdkSettingsRequest was null or undefined when calling logDynamicSdkSettings.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/sdkSettings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SdkSettingsRequestToJSON(requestParameters.sdkSettingsRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update SDK settings for a specific environment
   */
  logDynamicSdkSettings(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.logDynamicSdkSettingsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to merge two owned accounts connected by email address
   * After successful verification allow to merge two owned accounts
   */
  mergeUsersRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling mergeUsers.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to merge two owned accounts connected by email address
   * After successful verification allow to merge two owned accounts
   */
  mergeUsers(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.mergeUsersRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  mergeUsersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling mergeUsersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  mergeUsersOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.mergeUsersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  networksOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling networksOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  networksOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.networksOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  nonceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling nonceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/nonce`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  nonceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.nonceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint where an oauth provider would return authorization HTML used for mobile-friendly login, such as Apple ID with Touch ID on enabled devices.
   * Oauth provider authorization endpoint
   */
  oauthAuthorizeHtmlRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthAuthorizeHtml.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthAuthorizeHtml.");
      }
      const queryParameters = {};
      if (requestParameters.scope !== void 0) {
        queryParameters["scope"] = requestParameters.scope;
      }
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      if (requestParameters.redirectUri !== void 0) {
        queryParameters["redirect_uri"] = requestParameters.redirectUri;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/authorizeHtml`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would return authorization HTML used for mobile-friendly login, such as Apple ID with Touch ID on enabled devices.
   * Oauth provider authorization endpoint
   */
  oauthAuthorizeHtml(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthAuthorizeHtmlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthAuthorizeHtmlOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthAuthorizeHtmlOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthAuthorizeHtmlOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/authorizeHtml`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthAuthorizeHtmlOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthAuthorizeHtmlOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get redirect URL for Oauth provider login
   */
  oauthLoginRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLogin.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLogin.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/login`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Get redirect URL for Oauth provider login
   */
  oauthLogin(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthLoginRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/login`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthLoginOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get redirect URL for Oauth provider login. This will return a string that the SDK can manipulate before redirecting the browser to.
   */
  oauthLoginUrlRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginUrl.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginUrl.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/loginUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OauthProviderLoginUrlFromJSON(jsonValue));
    });
  }
  /**
   * Get redirect URL for Oauth provider login. This will return a string that the SDK can manipulate before redirecting the browser to.
   */
  oauthLoginUrl(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthLoginUrlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginUrlOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginUrlOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginUrlOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/loginUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginUrlOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthLoginUrlOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint for apple ID
   */
  oauthRedirectRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirect.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthRedirect.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const consumes = [
        { contentType: "application/x-www-form-urlencoded" }
      ];
      canConsumeForm(consumes);
      let formParams;
      {
        formParams = new URLSearchParams();
      }
      if (requestParameters.code !== void 0) {
        formParams.append("code", requestParameters.code);
      }
      if (requestParameters.state !== void 0) {
        formParams.append("state", requestParameters.state);
      }
      if (requestParameters.idToken !== void 0) {
        formParams.append("id_token", requestParameters.idToken);
      }
      if (requestParameters.error !== void 0) {
        formParams.append("error", requestParameters.error);
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint for apple ID
   */
  oauthRedirect(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthRedirectRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint
   */
  oauthRedirectCodeRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectCode.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthRedirectCode.");
      }
      const queryParameters = {};
      if (requestParameters.code !== void 0) {
        queryParameters["code"] = requestParameters.code;
      }
      if (requestParameters.scope !== void 0) {
        queryParameters["scope"] = requestParameters.scope;
      }
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      if (requestParameters.authuser !== void 0) {
        queryParameters["authuser"] = requestParameters.authuser;
      }
      if (requestParameters.prompt !== void 0) {
        queryParameters["prompt"] = requestParameters.prompt;
      }
      if (requestParameters.error !== void 0) {
        queryParameters["error"] = requestParameters.error;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint
   */
  oauthRedirectCode(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthRedirectCodeRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthRedirectOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthRedirectOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Returns the authorization code or error retuned by oauth provider
   */
  oauthResultRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthResult.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthResult.");
      }
      if (requestParameters.oauthResultRequest === null || requestParameters.oauthResultRequest === void 0) {
        throw new RequiredError("oauthResultRequest", "Required parameter requestParameters.oauthResultRequest was null or undefined when calling oauthResult.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/oauthResult`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OauthResultResponseFromJSON(jsonValue));
    });
  }
  /**
   * Returns the authorization code or error retuned by oauth provider
   */
  oauthResult(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthResultRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthResultOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthResultOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthResultOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/oauthResult`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthResultOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthResultOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Standard OAuth SignIn callback to exchange temproary code for oauth access and return a valid Dynamic JWT and user
   * Oauth provider SignIn endpoint
   */
  oauthSignInRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthSignIn.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthSignIn.");
      }
      if (requestParameters.oauthRequest === null || requestParameters.oauthRequest === void 0) {
        throw new RequiredError("oauthRequest", "Required parameter requestParameters.oauthRequest was null or undefined when calling oauthSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/signIn`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthRequestToJSON(requestParameters.oauthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Standard OAuth SignIn callback to exchange temproary code for oauth access and return a valid Dynamic JWT and user
   * Oauth provider SignIn endpoint
   */
  oauthSignIn(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthSignInOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/signIn`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthSignInOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Standard OAuth verify callback to exchange temproary code for oauth access
   * Oauth provider verify endpoint
   */
  oauthVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthVerify.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthVerify.");
      }
      if (requestParameters.oauthRequest === null || requestParameters.oauthRequest === void 0) {
        throw new RequiredError("oauthRequest", "Required parameter requestParameters.oauthRequest was null or undefined when calling oauthVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthRequestToJSON(requestParameters.oauthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Standard OAuth verify callback to exchange temproary code for oauth access
   * Oauth provider verify endpoint
   */
  oauthVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.oauthVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthVerifyOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthVerifyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.oauthVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  onrampsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling onrampsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  onrampsOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.onrampsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Add fees to a Solana transaction
   */
  optimizeTransactionRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optimizeTransaction.");
      }
      if (requestParameters.solanaTransactionOptimizationRequest === null || requestParameters.solanaTransactionOptimizationRequest === void 0) {
        throw new RequiredError("solanaTransactionOptimizationRequest", "Required parameter requestParameters.solanaTransactionOptimizationRequest was null or undefined when calling optimizeTransaction.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/optimizeTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SolanaTransactionOptimizationRequestToJSON(requestParameters.solanaTransactionOptimizationRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SolanaTransactionOptimizationResponseFromJSON(jsonValue));
    });
  }
  /**
   * Add fees to a Solana transaction
   */
  optimizeTransaction(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.optimizeTransactionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  optimizeTransactionOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optimizeTransactionOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/optimizeTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  optimizeTransactionOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.optimizeTransactionOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  optionsConnectRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optionsConnect.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/connect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  optionsConnect(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.optionsConnectRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  passkeyRecoveryOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling passkeyRecoveryOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  passkeyRecoveryOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.passkeyRecoveryOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Handle Telegram authentication
   */
  postTelegramAuthRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postTelegramAuth.");
      }
      if (requestParameters.telegramPostRequest === null || requestParameters.telegramPostRequest === void 0) {
        throw new RequiredError("telegramPostRequest", "Required parameter requestParameters.telegramPostRequest was null or undefined when calling postTelegramAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: TelegramPostRequestToJSON(requestParameters.telegramPostRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Handle Telegram authentication
   */
  postTelegramAuth(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.postTelegramAuthRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to send minimal wallet information to the API to prefetch name service information for an address.
   * prefetch information for wallet address
   */
  prefetchRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling prefetch.");
      }
      if (requestParameters.prefetchRequest === null || requestParameters.prefetchRequest === void 0) {
        throw new RequiredError("prefetchRequest", "Required parameter requestParameters.prefetchRequest was null or undefined when calling prefetch.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/prefetch`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PrefetchRequestToJSON(requestParameters.prefetchRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Endpoint to send minimal wallet information to the API to prefetch name service information for an address.
   * prefetch information for wallet address
   */
  prefetch(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.prefetchRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Publish events for SDK
   */
  publishEventRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling publishEvent.");
      }
      if (requestParameters.publishEvents === null || requestParameters.publishEvents === void 0) {
        throw new RequiredError("publishEvents", "Required parameter requestParameters.publishEvents was null or undefined when calling publishEvent.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/events`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublishEventsToJSON(requestParameters.publishEvents)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Publish events for SDK
   */
  publishEvent(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.publishEventRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryCodesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoveryCodesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryCodesOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.recoveryCodesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryEmailOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoveryEmailOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/recoveryEmail`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryEmailOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.recoveryEmailOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to refresh the JWT auth token using the current valid JWT auth token in the authorization header
   */
  refreshAuthRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Endpoint to refresh the JWT auth token using the current valid JWT auth token in the authorization header
   */
  refreshAuth(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.refreshAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.refreshOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Register a new Passkey MFA device
   */
  registerPasskeyMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegisterPasskeyDeviceGetResponseFromJSON(jsonValue));
    });
  }
  /**
   * Register a new Passkey MFA device
   */
  registerPasskeyMfaDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.registerPasskeyMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  registerPasskeyMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  registerPasskeyMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.registerPasskeyMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify Passkey MFA device
   */
  registerPasskeyMfaDeviceVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDeviceVerify.");
      }
      if (requestParameters.mFARegisterPasskeyDevicePostRequest === null || requestParameters.mFARegisterPasskeyDevicePostRequest === void 0) {
        throw new RequiredError("mFARegisterPasskeyDevicePostRequest", "Required parameter requestParameters.mFARegisterPasskeyDevicePostRequest was null or undefined when calling registerPasskeyMfaDeviceVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFARegisterPasskeyDevicePostRequestToJSON(requestParameters.mFARegisterPasskeyDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify Passkey MFA device
   */
  registerPasskeyMfaDeviceVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.registerPasskeyMfaDeviceVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Registers a session key for an embedded wallet
   * Registers a session key for an embedded wallet
   */
  registerSessionKeyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerSessionKey.");
      }
      if (requestParameters.registerSessionKeyRequest === null || requestParameters.registerSessionKeyRequest === void 0) {
        throw new RequiredError("registerSessionKeyRequest", "Required parameter requestParameters.registerSessionKeyRequest was null or undefined when calling registerSessionKey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/sessionKey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSessionKeyRequestToJSON(requestParameters.registerSessionKeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => RegisterEmbeddedWalletSessionKeyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Registers a session key for an embedded wallet
   * Registers a session key for an embedded wallet
   */
  registerSessionKey(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.registerSessionKeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Register a new TOTP MFA device and get Totp Secret
   */
  registerTotpMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegisterTotpDeviceGetResponseFromJSON(jsonValue));
    });
  }
  /**
   * Register a new TOTP MFA device and get Totp Secret
   */
  registerTotpMfaDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.registerTotpMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  registerTotpMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  registerTotpMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.registerTotpMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify TOTP MFA device
   */
  registerTotpMfaDeviceVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDeviceVerify.");
      }
      if (requestParameters.mFARegisterTotpDevicePostRequest === null || requestParameters.mFARegisterTotpDevicePostRequest === void 0) {
        throw new RequiredError("mFARegisterTotpDevicePostRequest", "Required parameter requestParameters.mFARegisterTotpDevicePostRequest was null or undefined when calling registerTotpMfaDeviceVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFARegisterTotpDevicePostRequestToJSON(requestParameters.mFARegisterTotpDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFADeviceFromJSON(jsonValue));
    });
  }
  /**
   * Verify TOTP MFA device
   */
  registerTotpMfaDeviceVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.registerTotpMfaDeviceVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Send new code for email verification
   */
  retryEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retryEmailVerification.");
      }
      if (requestParameters.emailVerificationRetryRequest === null || requestParameters.emailVerificationRetryRequest === void 0) {
        throw new RequiredError("emailVerificationRetryRequest", "Required parameter requestParameters.emailVerificationRetryRequest was null or undefined when calling retryEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationRetryRequestToJSON(requestParameters.emailVerificationRetryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Send new code for email verification
   */
  retryEmailVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.retryEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  retryEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retryEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  retryEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.retryEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Send new code for sms verification
   */
  retrySmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retrySmsVerification.");
      }
      if (requestParameters.smsVerificationRetryRequest === null || requestParameters.smsVerificationRetryRequest === void 0) {
        throw new RequiredError("smsVerificationRetryRequest", "Required parameter requestParameters.smsVerificationRetryRequest was null or undefined when calling retrySmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationRetryRequestToJSON(requestParameters.smsVerificationRetryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SmsVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Send new code for sms verification
   */
  retrySmsVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.retrySmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  retrySmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retrySmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  retrySmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.retrySmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Revoke a session
   */
  revokeSessionRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling revokeSession.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/revoke`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Revoke a session
   */
  revokeSession(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.revokeSessionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  revokeSessionOptionRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling revokeSessionOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/revoke`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  revokeSessionOption(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.revokeSessionOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Scan a URL for potential malicious activity
   */
  scanUrlRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling scanUrl.");
      }
      if (requestParameters.scanWebsiteUrlRequest === null || requestParameters.scanWebsiteUrlRequest === void 0) {
        throw new RequiredError("scanWebsiteUrlRequest", "Required parameter requestParameters.scanWebsiteUrlRequest was null or undefined when calling scanUrl.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/scan/websiteUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ScanWebsiteUrlRequestToJSON(requestParameters.scanWebsiteUrlRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ScanWebsiteUrlResponseFromJSON(jsonValue));
    });
  }
  /**
   * Scan a URL for potential malicious activity
   */
  scanUrl(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.scanUrlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   */
  sdkSettingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sdkSettingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/sdkSettings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   */
  sdkSettingsOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sdkSettingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * When a user selects a wallet to be the primary wallet in a multi-wallet enabled environment, this endpoint is called to record this on the backend.
   */
  selectUserWalletRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling selectUserWallet.");
      }
      if (requestParameters.userWalletSelectionRequest === null || requestParameters.userWalletSelectionRequest === void 0) {
        throw new RequiredError("userWalletSelectionRequest", "Required parameter requestParameters.userWalletSelectionRequest was null or undefined when calling selectUserWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/wallets/selection`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UserWalletSelectionRequestToJSON(requestParameters.userWalletSelectionRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * When a user selects a wallet to be the primary wallet in a multi-wallet enabled environment, this endpoint is called to record this on the backend.
   */
  selectUserWallet(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.selectUserWalletRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  selectUserWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling selectUserWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/wallets/selection`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  selectUserWalletOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.selectUserWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Check that session is valid
   */
  sessionCheckRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionCheck.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/session`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Check that session is valid
   */
  sessionCheck(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sessionCheckRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionCheckOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionCheckOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/session`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionCheckOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sessionCheckOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionKeyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionKeyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/sessionKey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionKeyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sessionKeyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  settingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling settingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  settingsOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.settingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify an email and sign in user
   */
  signInWithEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithEmailVerification.");
      }
      if (requestParameters.emailVerificationVerifyRequest === null || requestParameters.emailVerificationVerifyRequest === void 0) {
        throw new RequiredError("emailVerificationVerifyRequest", "Required parameter requestParameters.emailVerificationVerifyRequest was null or undefined when calling signInWithEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationVerifyRequestToJSON(requestParameters.emailVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify an email and sign in user
   */
  signInWithEmailVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.signInWithEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.signInWithEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify an sms and sign in user
   */
  signInWithSmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithSmsVerification.");
      }
      if (requestParameters.smsVerificationVerifyRequest === null || requestParameters.smsVerificationVerifyRequest === void 0) {
        throw new RequiredError("smsVerificationVerifyRequest", "Required parameter requestParameters.smsVerificationVerifyRequest was null or undefined when calling signInWithSmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationVerifyRequestToJSON(requestParameters.smsVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify an sms and sign in user
   */
  signInWithSmsVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.signInWithSmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithSmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithSmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithSmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.signInWithSmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramAuthOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.telegramAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Telegram provider SignIn endpoint
   */
  telegramSignInRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Telegram provider SignIn endpoint
   */
  telegramSignIn(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.telegramSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramSignInOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.telegramSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Telegram provider Verify endpoint
   */
  telegramVerifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Telegram provider Verify endpoint
   */
  telegramVerify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.telegramVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramVerifyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.telegramVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update a user\'s Turnkey recovery email
   */
  updateEmbeddedWalletRecoveryEmailRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateEmbeddedWalletRecoveryEmail.");
      }
      if (requestParameters.updateRecoveryEmailRequest === null || requestParameters.updateRecoveryEmailRequest === void 0) {
        throw new RequiredError("updateRecoveryEmailRequest", "Required parameter requestParameters.updateRecoveryEmailRequest was null or undefined when calling updateEmbeddedWalletRecoveryEmail.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/recoveryEmail`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateRecoveryEmailRequestToJSON(requestParameters.updateRecoveryEmailRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update a user\'s Turnkey recovery email
   */
  updateEmbeddedWalletRecoveryEmail(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.updateEmbeddedWalletRecoveryEmailRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update a passkey\'s info
   */
  updatePasskeyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updatePasskey.");
      }
      if (requestParameters.updateUserPasskeyRequest === null || requestParameters.updateUserPasskeyRequest === void 0) {
        throw new RequiredError("updateUserPasskeyRequest", "Required parameter requestParameters.updateUserPasskeyRequest was null or undefined when calling updatePasskey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserPasskeyRequestToJSON(requestParameters.updateUserPasskeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UserPasskeyFromJSON(jsonValue));
    });
  }
  /**
   * Update a passkey\'s info
   */
  updatePasskey(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.updatePasskeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Update a user\'s fields
   */
  updateSelfRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateSelf.");
      }
      if (requestParameters.userFields === null || requestParameters.userFields === void 0) {
        throw new RequiredError("userFields", "Required parameter requestParameters.userFields was null or undefined when calling updateSelf.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UserFieldsToJSON(requestParameters.userFields)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Update a user\'s fields
   */
  updateSelf(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.updateSelfRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Update a device
   */
  updateUserMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateUserMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling updateUserMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: MFAUpdateDeviceRequestToJSON(requestParameters.mFAUpdateDeviceRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update a device
   */
  updateUserMfaDevice(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.updateUserMfaDeviceRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  userPasskeysOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling userPasskeysOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  userPasskeysOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.userPasskeysOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  usersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling usersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  usersOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.usersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify payload and return JWT
   */
  verifyRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verify.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify payload and return JWT
   */
  verify(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Verify email verification request
   */
  verifyEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyEmailVerification.");
      }
      if (requestParameters.emailVerificationVerifyRequest === null || requestParameters.emailVerificationVerifyRequest === void 0) {
        throw new RequiredError("emailVerificationVerifyRequest", "Required parameter requestParameters.emailVerificationVerifyRequest was null or undefined when calling verifyEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationVerifyRequestToJSON(requestParameters.emailVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify email verification request
   */
  verifyEmailVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Link a wallet to a valid environment user, and return an updated JWT
   * Link wallet to user
   */
  verifyLinkRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyLink.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verifyLink.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/link`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Link a wallet to a valid environment user, and return an updated JWT
   * Link wallet to user
   */
  verifyLink(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyLinkRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyLinkOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyLinkOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/link`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyLinkOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyLinkOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to merge two users with user-chosen resolutions to conflicting data between the two users to be merged
   * Merge users with conflict resolutions
   */
  verifyMergeUsersRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyMergeUsers.");
      }
      if (requestParameters.mergeUserConflictResolutions === null || requestParameters.mergeUserConflictResolutions === void 0) {
        throw new RequiredError("mergeUserConflictResolutions", "Required parameter requestParameters.mergeUserConflictResolutions was null or undefined when calling verifyMergeUsers.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MergeUserConflictResolutionsToJSON(requestParameters.mergeUserConflictResolutions)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to merge two users with user-chosen resolutions to conflicting data between the two users to be merged
   * Merge users with conflict resolutions
   */
  verifyMergeUsers(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyMergeUsersRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyMergeUsersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyMergeUsersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyMergeUsersOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyMergeUsersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyPrefetchRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyPrefetch.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/prefetch`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyPrefetch(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyPrefetchRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify sms verification request
   */
  verifySmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifySmsVerification.");
      }
      if (requestParameters.smsVerificationVerifyRequest === null || requestParameters.smsVerificationVerifyRequest === void 0) {
        throw new RequiredError("smsVerificationVerifyRequest", "Required parameter requestParameters.smsVerificationVerifyRequest was null or undefined when calling verifySmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationVerifyRequestToJSON(requestParameters.smsVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify sms verification request
   */
  verifySmsVerification(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifySmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifySmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifySmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifySmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifySmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to link a wallet after user has confirmed transfer to the new account
   * Verify wallet transfer
   */
  verifyTransferRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyTransfer.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verifyTransfer.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to link a wallet after user has confirmed transfer to the new account
   * Verify wallet transfer
   */
  verifyTransfer(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyTransferRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyTransferOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyTransferOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyTransferOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyTransferOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Remove a link from to a valid environment user, and return an updated JWT
   * unlink wallet from user
   */
  verifyUnlinkRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyUnlink.");
      }
      if (requestParameters.verifyUnlinkRequest === null || requestParameters.verifyUnlinkRequest === void 0) {
        throw new RequiredError("verifyUnlinkRequest", "Required parameter requestParameters.verifyUnlinkRequest was null or undefined when calling verifyUnlink.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/unlink`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyUnlinkRequestToJSON(requestParameters.verifyUnlinkRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Remove a link from to a valid environment user, and return an updated JWT
   * unlink wallet from user
   */
  verifyUnlink(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.verifyUnlinkRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyUnlinkOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyUnlinkOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/unlink`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyUnlinkOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.verifyUnlinkOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling walletAccountOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.walletAccountOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountRequestOptionsRaw(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling walletAccountRequestOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts/createRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountRequestOptions(requestParameters, initOverrides) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.walletAccountRequestOptionsRaw(requestParameters, initOverrides);
    });
  }
};
var GetAccountBalancesChainNameEnum;
(function(GetAccountBalancesChainNameEnum2) {
  GetAccountBalancesChainNameEnum2["Evm"] = "EVM";
  GetAccountBalancesChainNameEnum2["Sol"] = "SOL";
})(GetAccountBalancesChainNameEnum || (GetAccountBalancesChainNameEnum = {}));
var GetAccountBalancesNetworkIdEnum;
(function(GetAccountBalancesNetworkIdEnum2) {
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_0"] = 0] = "NUMBER_0";
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_1"] = 1] = "NUMBER_1";
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_10"] = 10] = "NUMBER_10";
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_137"] = 137] = "NUMBER_137";
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_42161"] = 42161] = "NUMBER_42161";
  GetAccountBalancesNetworkIdEnum2[GetAccountBalancesNetworkIdEnum2["NUMBER_8453"] = 8453] = "NUMBER_8453";
})(GetAccountBalancesNetworkIdEnum || (GetAccountBalancesNetworkIdEnum = {}));
var GetAccountBalancesOptionsChainNameEnum;
(function(GetAccountBalancesOptionsChainNameEnum2) {
  GetAccountBalancesOptionsChainNameEnum2["Evm"] = "EVM";
  GetAccountBalancesOptionsChainNameEnum2["Sol"] = "SOL";
})(GetAccountBalancesOptionsChainNameEnum || (GetAccountBalancesOptionsChainNameEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/MinifiedDynamicJwt.js
function MinifiedDynamicJwtFromJSON(json) {
  return MinifiedDynamicJwtFromJSONTyped(json);
}
function MinifiedDynamicJwtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "kid": json["kid"],
    "aud": json["aud"],
    "iss": json["iss"],
    "sub": json["sub"],
    "sid": json["sid"],
    "exp": !exists(json, "exp") ? void 0 : json["exp"],
    "iat": !exists(json, "iat") ? void 0 : json["iat"],
    "environmentId": json["environment_id"],
    "lastVerifiedCredentialId": json["last_verified_credential_id"],
    "scope": !exists(json, "scope") ? void 0 : json["scope"]
  };
}

// node_modules/@dynamic-labs/utils/src/parseChainId.js
var parseChainId = (chainId) => parseInt(chainId.toString());

// node_modules/@dynamic-labs/utils/src/parseEvmNetworks.js
var parseEvmNetworks = (networks) => {
  const clone = networks.slice();
  return clone.map((network) => {
    network.chainId = parseChainId(network.chainId);
    network.networkId = parseChainId(network.networkId);
    return network;
  });
};

// node_modules/@dynamic-labs/utils/src/errors/CustomError.js
var CustomError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = void 0;
    this.code = code;
    Object.setPrototypeOf(this, this.constructor.prototype);
  }
  toJSON() {
    return {
      code: this.code,
      error: this.message
    };
  }
};

// node_modules/@dynamic-labs/utils/src/errors/DynamicError.js
var DynamicError = class extends CustomError {
};

// node_modules/@dynamic-labs/utils/src/errors/AccountExistsError.js
var AccountExistsError = class extends DynamicError {
  constructor(errorMessage, errorPayload) {
    super(errorMessage);
    this.errorMessage = errorMessage;
    this.errorPayload = errorPayload;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ChainalysisError.js
var ChainalysisError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is not approved for access");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SandboxMaximumThresholdReachedError.js
var SandboxMaximumThresholdReachedError = class extends DynamicError {
  constructor(errorMessage) {
    super(errorMessage);
    this.errorMessage = errorMessage;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailAlreadyExistsError.js
var EmailAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Email already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailProviderError.js
var EmailProviderError = class extends DynamicError {
  constructor(code) {
    super("EmailProviderError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailVerificationError.js
var EmailVerificationError = class extends DynamicError {
  constructor(code) {
    super("EmailVerificationError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/GateBlockedError.js
var GateBlockedError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is blocked by the gate");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InsufficientFundsError.js
var InsufficientFundsError = class _InsufficientFundsError extends DynamicError {
  constructor() {
    super(_InsufficientFundsError.message);
  }
  static isInstance(err) {
    var _a4;
    const error = ((_a4 = err === null || err === void 0 ? void 0 : err.walk) === null || _a4 === void 0 ? void 0 : _a4.call(err)) || err;
    return error instanceof _InsufficientFundsError;
  }
  static isErrorMessage(err) {
    var _a4;
    const errorWithMessage = err;
    return ((_a4 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a4 === void 0 ? void 0 : _a4.includes("AA21 didn't pay prefund")) || false;
  }
};
InsufficientFundsError.message = "Insufficient funds.";

// node_modules/@dynamic-labs/utils/src/errors/MissingEnvironmentIdError.js
var MissingEnvironmentIdError = class extends DynamicError {
  constructor() {
    super("You are missing the environmentId field in yours DynamicContextProvider settings prop");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MissingPublicAddressError.js
var MissingPublicAddressError = class extends DynamicError {
  constructor() {
    super("Missing public address", "missing-public-address");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/NoAccessError.js
var NoAccessError = class extends DynamicError {
  constructor({ walletPublicKey, email, phoneNumber, socialProvider, socialUsername }) {
    super("User does not have access");
    this.email = email;
    this.walletPublicKey = walletPublicKey;
    this.phoneNumber = phoneNumber;
    this.socialProvider = socialProvider;
    this.socialUsername = socialUsername;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SmsVerificationError.js
var SmsVerificationError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/SocialAccountAlreadyExistsError.js
var SocialAccountAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Social account already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TransactionGasCannotBeSponsoredError.js
var TransactionGasCannotBeSponsoredError = class _TransactionGasCannotBeSponsoredError extends DynamicError {
  constructor() {
    super(_TransactionGasCannotBeSponsoredError.message);
  }
  static isInstance(err) {
    var _a4;
    const error = ((_a4 = err === null || err === void 0 ? void 0 : err.walk) === null || _a4 === void 0 ? void 0 : _a4.call(err)) || err;
    return error instanceof _TransactionGasCannotBeSponsoredError;
  }
  static isErrorMessage(err) {
    var _a4;
    const errorWithMessage = err;
    return ((_a4 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a4 === void 0 ? void 0 : _a4.includes("userOp did not match any gas sponsoring policies")) || false;
  }
};
TransactionGasCannotBeSponsoredError.message = "Transaction gas cannot be sponsored.";

// node_modules/@dynamic-labs/utils/src/errors/UserHasAccountWithEmailError.js
var UserHasAccountWithEmailError = class extends DynamicError {
  constructor(error) {
    super(error);
    this.error = error;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UsernameAlreadyExistsError.js
var UsernameAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Username already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletNotDeployedError.js
var WalletNotDeployedError = class extends DynamicError {
  constructor() {
    super("Wallet has not been deployed", "wallet_not_deployed");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletUsedError.js
var WalletUsedError = class extends DynamicError {
  constructor(code) {
    super("WalletUsedError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedTransactionError.js
var UserRejectedTransactionError = class extends DynamicError {
  constructor() {
    super("user rejected transaction");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TooManyEmailVerificationsError.js
var TooManyEmailVerificationsError = class extends DynamicError {
  constructor() {
    super("Too many email verification attempts.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/VerificationDataCollectionError.js
var VerificationDataCollectionError = class extends DynamicError {
  constructor(message) {
    super("Failed to get verification data: " + message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InvalidPhoneNumberError.js
var InvalidPhoneNumberError = class extends DynamicError {
  constructor(error) {
    super(error !== null && error !== void 0 ? error : "Invalid phone number.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MergeAccountsConfirmationError.js
var MergeAccountsConfirmationError = class extends DynamicError {
  constructor({ code, mergeConflicts, walletAddress }) {
    super("MergeAccountsConfirmationError", code);
    this.mergeConflicts = mergeConflicts;
    this.walletAddress = walletAddress;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CustomFieldNotUniqueError.js
var CustomFieldNotUniqueError = class extends DynamicError {
  constructor() {
    super("Custom Field for user must be unique within the environment", "custom_field_data_not_unique");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CookieInvalidError.js
var CookieInvalidError = class extends DynamicError {
  constructor() {
    super("The cookie is invalid or expired");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/AccessBlockedError.js
var AccessBlockedError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/EmbeddedWalletException.js
var EmbeddedWalletException = class extends DynamicError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MfaInvalidOtpError.js
var MfaInvalidOtpError = class extends DynamicError {
  constructor() {
    super("Invalid code");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MfaRateLimitedError.js
var MfaRateLimitedError = class extends DynamicError {
  constructor() {
    super("Rate limit reached");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ExternalAuthError.js
var ExternalAuthError = class extends DynamicError {
  constructor(code) {
    super("ExternalAuthError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletAddressMismatchError.js
var WalletAddressMismatchError = class extends DynamicError {
  constructor(message, { activeAddress, expectedAddress, walletName }) {
    super(message, "wallet_address_mismatch_error");
    this.expectedAddress = expectedAddress;
    this.activeAddress = activeAddress;
    this.walletName = walletName;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedRequestError.js
var UserRejectedRequestError = class extends DynamicError {
  constructor() {
    super("User rejected request", "user_rejected_request");
  }
};

// node_modules/@dynamic-labs/logger/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@dynamic-labs/logger/src/types.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["MUTE"] = 99] = "MUTE";
})(LogLevel || (LogLevel = {}));

// node_modules/@dynamic-labs/logger/src/utils/deepMerge.js
var deepMerge = (obj1, obj2) => {
  if (typeof obj1 !== "object" || typeof obj2 !== "object") {
    return obj2;
  }
  const result = Object.assign({}, obj1);
  for (const key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      if (typeof obj2[key] === "object" && Object.prototype.hasOwnProperty.call(obj1, key) && typeof obj1[key] === "object") {
        result[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        result[key] = obj2[key];
      }
    }
  }
  return result;
};

// node_modules/@dynamic-labs/logger/src/utils/processArgs.js
var processArgs = (message) => {
  const objectArgs = message.args.filter((arg) => typeof arg === "object");
  const remainingArgs = message.args.filter((arg) => typeof arg !== "object" || arg instanceof Error).map((arg) => arg.toString());
  return { objectArgs, remainingArgs };
};

// node_modules/@dynamic-labs/logger/src/index.js
var IGNORE_MESSAGES = ["Failed to send logs to server"];
var messageQueue = [];
var Logger = class _Logger {
  constructor(name, level) {
    this.name = name;
    this.meta = void 0;
    if (level === void 0 && true) {
      this.level = LogLevel.DEBUG;
    } else if (level === void 0) {
      this.level = LogLevel.WARN;
    } else {
      this.level = level;
    }
  }
  static setEmitErrors(emit) {
    if (emit !== void 0) {
      _Logger.globalKeys.emitErrors = emit;
    }
  }
  static setEnvironmentId(environmentId) {
    if (environmentId !== void 0) {
      _Logger.globalKeys.environmentId = environmentId;
    }
  }
  setMetaData(key, value) {
    if (!this.meta) {
      this.meta = {};
    }
    const data = {};
    key.split(".").reduce((acc, k, i, arr) => {
      if (i === arr.length - 1) {
        acc[k] = value;
      } else {
        if (!acc[k]) {
          acc[k] = {};
        }
        return acc[k];
      }
    }, data);
    this.meta = deepMerge(this.meta, data);
  }
  getNameArray(name) {
    return Array.isArray(name) ? name : [name];
  }
  createLogger(name, level) {
    return new _Logger([...this.getNameArray(this.name), ...this.getNameArray(name)], level !== null && level !== void 0 ? level : this.level);
  }
  get logLevel() {
    return LogLevel[this.level];
  }
  setLogLevel(level) {
    if (level in LogLevel && typeof level === "string") {
      this.level = LogLevel[level];
    } else if (level in LogLevel && typeof level === "number") {
      this.level = level;
    } else {
      throw new Error(`Invalid log level: ${level}`);
    }
  }
  formatMessage(level, message) {
    var _a4;
    if (message instanceof Error) {
      message = message.stack;
    } else if (
      // Handle Error-Like Objects
      message instanceof Object && Object.prototype.hasOwnProperty.call(message, "stack")
    ) {
      message = message.stack;
    } else if (message instanceof Object) {
      message = JSON.stringify(message);
    }
    const names = (Array.isArray(this.name) ? this.name : [this.name]).map((name) => `[${name}]`);
    return `${names.join("")} [${(_a4 = LogLevel[level]) !== null && _a4 !== void 0 ? _a4 : "TROUBLESHOOTING"}]: ${message}`;
  }
  captureAndSend(level, message, ...args) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (_Logger.globalKeys.emitErrors && !IGNORE_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.toString()) && typeof window !== "undefined") {
        this.emitHttpLogs(level, message, { args });
      }
    });
  }
  emitHttpLogs(level, message, { args = [], transformMeta = (meta) => meta }) {
    messageQueue.push({ args, level, message });
    if (messageQueue.length === 1) {
      queueMicrotask(() => __awaiter2(this, void 0, void 0, function* () {
        var _a4, _b;
        const messages = [];
        messageQueue.forEach((msg) => {
          var _a5, _b2, _c, _d, _e;
          const body = {};
          const { objectArgs, remainingArgs } = processArgs(msg);
          Object.assign(body, ...objectArgs);
          Object.assign(body, {
            level: LogLevel[msg.level],
            message: [msg.message, ...remainingArgs].join(" "),
            meta: transformMeta(this.meta),
            url: {
              hostname: (_a5 = window.location) === null || _a5 === void 0 ? void 0 : _a5.hostname,
              origin: (_b2 = window.location) === null || _b2 === void 0 ? void 0 : _b2.origin,
              pathname: (_c = window.location) === null || _c === void 0 ? void 0 : _c.pathname,
              port: (_d = window.location) === null || _d === void 0 ? void 0 : _d.port,
              protocol: (_e = window.location) === null || _e === void 0 ? void 0 : _e.protocol
            }
          });
          messages.push(body);
        });
        try {
          if (!((_a4 = _Logger.globalKeys) === null || _a4 === void 0 ? void 0 : _a4.environmentId)) {
            throw new Error("Environment ID not set");
          }
          yield fetch(`https://logs.dynamicauth.com/api/v1/${(_b = _Logger.globalKeys) === null || _b === void 0 ? void 0 : _b.environmentId}`, {
            body: JSON.stringify(messages),
            headers: {
              "Content-Type": "application/json"
            },
            method: "POST",
            mode: "cors",
            referrerPolicy: "origin-when-cross-origin"
          });
        } catch (error) {
          this.debug("Failed to send logs to server", error);
        }
        messageQueue.length = 0;
      }));
    }
  }
  /**
   * Emits an INFO type message to the backend for analysis and debugging
   */
  instrument(message, options) {
    return this.emitHttpLogs(LogLevel.INFO, message, {
      args: [options],
      // Don't send any meta to avoid storing PII
      transformMeta: () => void 0
    });
  }
  log(level, message, ...args) {
    const enableTroubleshootMode = typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.dynamic_enableTroubleshootMode) === true;
    if (!enableTroubleshootMode && (level < this.level || level === LogLevel.MUTE)) {
      return;
    }
    const fmtMsg = this.formatMessage(level, message);
    switch (level) {
      case LogLevel.WARN:
        console.warn(fmtMsg, ...args);
        break;
      case LogLevel.ERROR:
        console.error(fmtMsg, ...args);
        break;
      default:
        console.log(fmtMsg, ...args);
    }
    if (level === LogLevel.ERROR) {
      this.captureAndSend(level, message, ...args);
    }
  }
  logVerboseTroubleshootingMessage(message, ...args) {
    this.log(-1, message, ...args);
  }
  debug(message, ...args) {
    this.log(LogLevel.DEBUG, message, ...args);
  }
  info(message, ...args) {
    this.log(LogLevel.INFO, message, ...args);
  }
  warn(message, ...args) {
    this.log(LogLevel.WARN, message, ...args);
  }
  error(message, ...args) {
    _Logger.events.emit("error", message);
    this.log(LogLevel.ERROR, message, ...args);
  }
};
Logger.globalKeys = {
  emitErrors: true
};
Logger.events = new eventemitter3_default();

// node_modules/@dynamic-labs/utils/src/logger/logger.js
var logger = new Logger("utils");

// node_modules/@dynamic-labs/utils/src/isMobile.js
var userAgentRegex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;
var userAgentRegex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
var isMobile = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return userAgentRegex1.test(navigator.userAgent) || userAgentRegex2.test(navigator.userAgent.substring(0, 4)) || isIPad(maxTouchPointsOverride) || isIPhone();
};
var isIPhone = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : /iPhone/.test(navigator.userAgent);
var isIPhone8OrEarlier = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : iPhoneLegacyRegex.some(({ regex }) => regex.test(navigator.userAgent));
var isIPad = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;
  return /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && maxTouchPoints === 5;
};
var isIOS = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return isIPhone() || isIPad(maxTouchPointsOverride);
};
var isAndroid = () => isMobile() && !isIOS();
var isLegacySafari = () => {
  if (typeof window === "undefined" || !window.CSS || typeof window.CSS.supports !== "function") {
    return false;
  }
  const cssValue = "aspect-ratio: 1 / 1";
  return !CSS.supports(cssValue);
};
var isSamsungBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return navigator.userAgent.includes("SamsungBrowser");
};
var isSafariBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const { userAgent } = navigator;
  const isSafari = userAgent.includes("Safari") && !userAgent.includes("Chrome") && !userAgent.includes("Chromium");
  return isSafari;
};
var iPhoneLegacyRegex = [
  {
    model: "iPhone 5",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]12|5)$/
  },
  {
    model: "iPhone 5C",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]34)$/
  },
  {
    model: "iPhone 5S",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?6[C,_]12|5S)$/
  },
  {
    model: "iPhone 6 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]1|1C2%257enohPi|6PLUS)$/
  },
  {
    model: "iPhone 6",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]2|6)$/
  },
  {
    model: "iPhone 6s Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]2|6SPLUS)$/
  },
  {
    model: "iPhone 6s",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]1|iPhone[ /]6s|6S)$/
  },
  {
    model: "iPhone SE",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]4|SE)$/
  },
  {
    model: "iPhone 7",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]13|iphone7|7)$/
  },
  {
    model: "iPhone 7 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]24|7PLUS)$/
  },
  {
    model: "iPhone 8",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]14|8)$/
  },
  {
    model: "iPhone 8 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]25|8PLUS)$/
  }
];
var getAndroidVersion = () => {
  if (typeof navigator === "undefined") {
    return;
  }
  const androidVersionMatch = navigator.userAgent.match(/Android (\d+(\.\d+)?)/);
  if (!androidVersionMatch) {
    return;
  }
  const androidVersion = parseFloat(androidVersionMatch[1]);
  return androidVersion;
};

// node_modules/@dynamic-labs/utils/_virtual/_tslib.js
function __awaiter3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

// node_modules/@dynamic-labs/utils/src/bufferPolyfill.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined") {
  window.global = globalThis;
  if (!window.Buffer && typeof window.Buffer === "undefined") {
    Object.assign(window, { Buffer: import_buffer.Buffer });
  }
}

// node_modules/@dynamic-labs/utils/src/getProvidersFromWindow.js
var getProvidersFromWindow = (path) => {
  const splitPath = path.split(".");
  let result = window;
  const foundProviders = [];
  for (const [index, p] of Object.entries(splitPath)) {
    result = result[p];
    if (typeof result !== "object" || result === null) {
      return [];
    }
    if (Number(index) === splitPath.length - 1) {
      if (Array.isArray(result)) {
        result.forEach((p2) => foundProviders.push(p2));
      } else {
        if (result.providers) {
          result.providers.forEach((p2) => foundProviders.push(p2));
        } else {
          foundProviders.push(result);
        }
      }
    }
  }
  return foundProviders;
};

// node_modules/@dynamic-labs/utils/src/sleep/sleep.js
function sleep(timeoutMs, valueToResolve) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(valueToResolve), timeoutMs);
  });
}

// node_modules/@dynamic-labs/utils/src/retryableFn.js
var FALLBACK_UNDEFINED = "FALLBACK_UNDEFINED";
var retryableFn = (fn_1, ...args_1) => __awaiter3(void 0, [fn_1, ...args_1], void 0, function* (fn, options = {}) {
  const { maxRetries = 3, currentRetry = 0, timeoutMs = 100, fallbackValue = new Error("Max retries reached"), retryStrategy = "timeout-only", retryIntervalMs = 0, logger: logger5 } = options;
  logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("Configured retryableFn with options: ", {
    currentRetry,
    fallbackValue,
    maxRetries,
    retryStrategy,
    timeoutMs
  });
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error("Timeout"));
    }, timeoutMs);
  });
  try {
    const result = yield Promise.race([fn(), timeoutPromise]);
    return result;
  } catch (err) {
    logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("retryableFn caught error: ", err);
    if (currentRetry >= maxRetries) {
      logger5 === null || logger5 === void 0 ? void 0 : logger5.error("Error while retrying function, returning/throwing fallback value", err, fallbackValue);
      if (fallbackValue instanceof Error) {
        throw fallbackValue;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        return void 0;
      }
      return fallbackValue;
    }
    const isTimeout = (err === null || err === void 0 ? void 0 : err.message) === "Timeout";
    const shouldRetry = retryStrategy === "timeout-and-rejection" || retryStrategy === "timeout-only" && isTimeout || retryStrategy === "rejection-only" && !isTimeout;
    logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("retryableFn shouldRetry: ", shouldRetry);
    if (!shouldRetry) {
      if (fallbackValue instanceof Error) {
        logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("retryableFn throwing fallbackValue error: ", fallbackValue);
        throw err;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("retryableFn returning undefined");
        return void 0;
      }
      logger5 === null || logger5 === void 0 ? void 0 : logger5.debug("retryableFn returning fallbackValue: ", fallbackValue);
      logger5 === null || logger5 === void 0 ? void 0 : logger5.error("Error while retrying function, returning fallback value", err);
      return fallbackValue;
    }
    if (retryIntervalMs)
      yield sleep(retryIntervalMs);
    return retryableFn(fn, {
      currentRetry: currentRetry + 1,
      fallbackValue,
      logger: logger5,
      maxRetries,
      retryIntervalMs,
      retryStrategy,
      timeoutMs
    });
  }
});

// node_modules/@dynamic-labs/utils/src/DeferredPromise/DeferredPromise.js
var DeferredPromise = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// node_modules/@dynamic-labs/utils/src/handleMobileWalletRedirect/handleMobileWalletRedirect.js
var handleMobileWalletRedirect = ({ nativeLink, universalLink }) => {
  const url = encodeURIComponent(window.location.toString());
  const ref = encodeURIComponent(window.location.origin);
  if (isSamsungBrowser()) {
    window.location.assign(`${nativeLink}/${url}?ref=${ref}`);
  } else {
    window.location.assign(`${universalLink}/${url}?ref=${ref}`);
  }
};

// node_modules/tldts-core/dist/es6/src/domain.js
function shareSameDomainSuffix(hostname, vhost) {
  if (hostname.endsWith(vhost)) {
    return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === ".";
  }
  return false;
}
function extractDomainWithSuffix(hostname, publicSuffix) {
  const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
  const lastDotBeforeSuffixIndex = hostname.lastIndexOf(".", publicSuffixIndex);
  if (lastDotBeforeSuffixIndex === -1) {
    return hostname;
  }
  return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname, options) {
  if (options.validHosts !== null) {
    const validHosts = options.validHosts;
    for (const vhost of validHosts) {
      if (
        /*@__INLINE__*/
        shareSameDomainSuffix(hostname, vhost)
      ) {
        return vhost;
      }
    }
  }
  let numberOfLeadingDots = 0;
  if (hostname.startsWith(".")) {
    while (numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === ".") {
      numberOfLeadingDots += 1;
    }
  }
  if (suffix.length === hostname.length - numberOfLeadingDots) {
    return null;
  }
  return (
    /*@__INLINE__*/
    extractDomainWithSuffix(hostname, suffix)
  );
}

// node_modules/tldts-core/dist/es6/src/domain-without-suffix.js
function getDomainWithoutSuffix(domain, suffix) {
  return domain.slice(0, -suffix.length - 1);
}

// node_modules/tldts-core/dist/es6/src/extract-hostname.js
function extractHostname(url, urlIsValidHostname) {
  let start = 0;
  let end = url.length;
  let hasUpper = false;
  if (!urlIsValidHostname) {
    if (url.startsWith("data:")) {
      return null;
    }
    while (start < url.length && url.charCodeAt(start) <= 32) {
      start += 1;
    }
    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
      end -= 1;
    }
    if (url.charCodeAt(start) === 47 && url.charCodeAt(start + 1) === 47) {
      start += 2;
    } else {
      const indexOfProtocol = url.indexOf(":/", start);
      if (indexOfProtocol !== -1) {
        const protocolSize = indexOfProtocol - start;
        const c0 = url.charCodeAt(start);
        const c1 = url.charCodeAt(start + 1);
        const c2 = url.charCodeAt(start + 2);
        const c3 = url.charCodeAt(start + 3);
        const c4 = url.charCodeAt(start + 4);
        if (protocolSize === 5 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112 && c4 === 115) {
        } else if (protocolSize === 4 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112) {
        } else if (protocolSize === 3 && c0 === 119 && c1 === 115 && c2 === 115) {
        } else if (protocolSize === 2 && c0 === 119 && c1 === 115) {
        } else {
          for (let i = start; i < indexOfProtocol; i += 1) {
            const lowerCaseCode = url.charCodeAt(i) | 32;
            if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || // [a, z]
            lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
            lowerCaseCode === 46 || // '.'
            lowerCaseCode === 45 || // '-'
            lowerCaseCode === 43)) {
              return null;
            }
          }
        }
        start = indexOfProtocol + 2;
        while (url.charCodeAt(start) === 47) {
          start += 1;
        }
      }
    }
    let indexOfIdentifier = -1;
    let indexOfClosingBracket = -1;
    let indexOfPort = -1;
    for (let i = start; i < end; i += 1) {
      const code = url.charCodeAt(i);
      if (code === 35 || // '#'
      code === 47 || // '/'
      code === 63) {
        end = i;
        break;
      } else if (code === 64) {
        indexOfIdentifier = i;
      } else if (code === 93) {
        indexOfClosingBracket = i;
      } else if (code === 58) {
        indexOfPort = i;
      } else if (code >= 65 && code <= 90) {
        hasUpper = true;
      }
    }
    if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
      start = indexOfIdentifier + 1;
    }
    if (url.charCodeAt(start) === 91) {
      if (indexOfClosingBracket !== -1) {
        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
      }
      return null;
    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
      end = indexOfPort;
    }
  }
  while (end > start + 1 && url.charCodeAt(end - 1) === 46) {
    end -= 1;
  }
  const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
  if (hasUpper) {
    return hostname.toLowerCase();
  }
  return hostname;
}

// node_modules/tldts-core/dist/es6/src/is-ip.js
function isProbablyIpv4(hostname) {
  if (hostname.length < 7) {
    return false;
  }
  if (hostname.length > 15) {
    return false;
  }
  let numberOfDots = 0;
  for (let i = 0; i < hostname.length; i += 1) {
    const code = hostname.charCodeAt(i);
    if (code === 46) {
      numberOfDots += 1;
    } else if (code < 48 || code > 57) {
      return false;
    }
  }
  return numberOfDots === 3 && hostname.charCodeAt(0) !== 46 && hostname.charCodeAt(hostname.length - 1) !== 46;
}
function isProbablyIpv6(hostname) {
  if (hostname.length < 3) {
    return false;
  }
  let start = hostname.startsWith("[") ? 1 : 0;
  let end = hostname.length;
  if (hostname[end - 1] === "]") {
    end -= 1;
  }
  if (end - start > 39) {
    return false;
  }
  let hasColon = false;
  for (; start < end; start += 1) {
    const code = hostname.charCodeAt(start);
    if (code === 58) {
      hasColon = true;
    } else if (!(code >= 48 && code <= 57 || // 0-9
    code >= 97 && code <= 102 || // a-f
    code >= 65 && code <= 90)) {
      return false;
    }
  }
  return hasColon;
}
function isIp(hostname) {
  return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}

// node_modules/tldts-core/dist/es6/src/is-valid.js
function isValidAscii(code) {
  return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function is_valid_default(hostname) {
  if (hostname.length > 255) {
    return false;
  }
  if (hostname.length === 0) {
    return false;
  }
  if (
    /*@__INLINE__*/
    !isValidAscii(hostname.charCodeAt(0)) && hostname.charCodeAt(0) !== 46 && // '.' (dot)
    hostname.charCodeAt(0) !== 95
  ) {
    return false;
  }
  let lastDotIndex = -1;
  let lastCharCode = -1;
  const len = hostname.length;
  for (let i = 0; i < len; i += 1) {
    const code = hostname.charCodeAt(i);
    if (code === 46) {
      if (
        // Check that previous label is < 63 bytes long (64 = 63 + '.')
        i - lastDotIndex > 64 || // Check that previous character was not already a '.'
        lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
        lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
        lastCharCode === 95
      ) {
        return false;
      }
      lastDotIndex = i;
    } else if (!/*@__INLINE__*/
    (isValidAscii(code) || code === 45 || code === 95)) {
      return false;
    }
    lastCharCode = code;
  }
  return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45
  );
}

// node_modules/tldts-core/dist/es6/src/options.js
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname: extractHostname2 = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
  return {
    allowIcannDomains,
    allowPrivateDomains,
    detectIp,
    extractHostname: extractHostname2,
    mixedInputs,
    validHosts,
    validateHostname
  };
}
var DEFAULT_OPTIONS = (
  /*@__INLINE__*/
  setDefaultsImpl({})
);
function setDefaults(options) {
  if (options === void 0) {
    return DEFAULT_OPTIONS;
  }
  return (
    /*@__INLINE__*/
    setDefaultsImpl(options)
  );
}

// node_modules/tldts-core/dist/es6/src/subdomain.js
function getSubdomain(hostname, domain) {
  if (domain.length === hostname.length) {
    return "";
  }
  return hostname.slice(0, -domain.length - 1);
}

// node_modules/tldts-core/dist/es6/src/factory.js
function getEmptyResult() {
  return {
    domain: null,
    domainWithoutSuffix: null,
    hostname: null,
    isIcann: null,
    isIp: null,
    isPrivate: null,
    publicSuffix: null,
    subdomain: null
  };
}
function parseImpl(url, step, suffixLookup2, partialOptions, result) {
  const options = (
    /*@__INLINE__*/
    setDefaults(partialOptions)
  );
  if (typeof url !== "string") {
    return result;
  }
  if (!options.extractHostname) {
    result.hostname = url;
  } else if (options.mixedInputs) {
    result.hostname = extractHostname(url, is_valid_default(url));
  } else {
    result.hostname = extractHostname(url, false);
  }
  if (step === 0 || result.hostname === null) {
    return result;
  }
  if (options.detectIp) {
    result.isIp = isIp(result.hostname);
    if (result.isIp) {
      return result;
    }
  }
  if (options.validateHostname && options.extractHostname && !is_valid_default(result.hostname)) {
    result.hostname = null;
    return result;
  }
  suffixLookup2(result.hostname, options, result);
  if (step === 2 || result.publicSuffix === null) {
    return result;
  }
  result.domain = getDomain(result.publicSuffix, result.hostname, options);
  if (step === 3 || result.domain === null) {
    return result;
  }
  result.subdomain = getSubdomain(result.hostname, result.domain);
  if (step === 4) {
    return result;
  }
  result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
  return result;
}

// node_modules/tldts-core/dist/es6/src/lookup/fast-path.js
function fast_path_default(hostname, options, out) {
  if (!options.allowPrivateDomains && hostname.length > 3) {
    const last2 = hostname.length - 1;
    const c3 = hostname.charCodeAt(last2);
    const c2 = hostname.charCodeAt(last2 - 1);
    const c1 = hostname.charCodeAt(last2 - 2);
    const c0 = hostname.charCodeAt(last2 - 3);
    if (c3 === 109 && c2 === 111 && c1 === 99 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "com";
      return true;
    } else if (c3 === 103 && c2 === 114 && c1 === 111 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "org";
      return true;
    } else if (c3 === 117 && c2 === 100 && c1 === 101 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "edu";
      return true;
    } else if (c3 === 118 && c2 === 111 && c1 === 103 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "gov";
      return true;
    } else if (c3 === 116 && c2 === 101 && c1 === 110 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "net";
      return true;
    } else if (c3 === 101 && c2 === 100 && c1 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "de";
      return true;
    }
  }
  return false;
}

// node_modules/tldts/dist/es6/src/data/trie.js
var exceptions = /* @__PURE__ */ function() {
  const _0 = [1, {}], _1 = [0, { "city": _0 }];
  const exceptions2 = [0, { "ck": [0, { "www": _0 }], "jp": [0, { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 }] }];
  return exceptions2;
}();
var rules = /* @__PURE__ */ function() {
  const _2 = [1, {}], _3 = [2, {}], _4 = [1, { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 }], _5 = [0, { "*": _3 }], _6 = [1, { "blogspot": _3 }], _7 = [1, { "gov": _2 }], _8 = [0, { "*": _2 }], _9 = [0, { "cloud": _3 }], _10 = [1, { "co": _3 }], _11 = [2, { "nodes": _3 }], _12 = [0, { "s3": _3 }], _13 = [0, { "direct": _3 }], _14 = [2, { "id": _3 }], _15 = [0, { "webview-assets": _3 }], _16 = [0, { "vfs": _3, "webview-assets": _3 }], _17 = [0, { "aws-cloud9": _15, "cloud9": _16 }], _18 = [0, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], _19 = [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "aws-cloud9": _15, "cloud9": _16 }], _20 = [0, { "dualstack": _12, "aws-cloud9": _15, "cloud9": _16 }], _21 = [0, { "apps": _3 }], _22 = [0, { "paas": _3 }], _23 = [0, { "app": _3 }], _24 = [2, { "eu": _3 }], _25 = [0, { "site": _3 }], _26 = [0, { "pages": _3 }], _27 = [1, { "com": _2, "edu": _2, "net": _2, "org": _2 }], _28 = [0, { "j": _3 }], _29 = [0, { "jelastic": _3 }], _30 = [0, { "user": _3 }], _31 = [1, { "ybo": _3 }], _32 = [0, { "cust": _3, "reservd": _3 }], _33 = [0, { "cust": _3 }], _34 = [1, { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 }], _35 = [1, { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 }], _36 = [1, { "gov": _2, "blogspot": _3 }], _37 = [1, { "framer": _3 }], _38 = [1, { "barsy": _3 }], _39 = [0, { "forgot": _3 }], _40 = [1, { "gs": _2 }], _41 = [0, { "nes": _2 }], _42 = [1, { "k12": _2, "cc": _2, "lib": _2 }], _43 = [1, { "cc": _2, "lib": _2 }];
  const rules2 = [0, { "ac": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 }], "ad": [1, { "nom": _2 }], "ae": [1, { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "aero": [1, { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 }], "af": _4, "ag": [1, { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 }], "ai": [1, { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 }], "al": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 }], "am": [1, { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 }], "ao": [1, { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 }], "aq": _2, "ar": [1, { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 }], "arpa": [1, { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 }], "as": _7, "asia": [1, { "cloudns": _3 }], "at": [1, { "ac": [1, { "sth": _2 }], "co": _6, "gv": _2, "or": _2, "funkfeuer": [0, { "wien": _3 }], "futurecms": [0, { "*": _3, "ex": _5, "in": _5 }], "futurehosting": _3, "futuremailing": _3, "ortsinfo": [0, { "ex": _5, "kunden": _5 }], "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "au": [1, { "com": [1, { "blogspot": _3, "cloudlets": [0, { "mel": _3 }], "myspreadshop": _3 }], "net": _2, "org": _2, "edu": [1, { "act": _2, "catholic": _2, "nsw": [1, { "schools": _2 }], "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "gov": [1, { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "aw": [1, { "com": _2 }], "ax": [1, { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 }], "az": [1, { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 }], "ba": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 }], "bb": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 }], "bd": _8, "be": [1, { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": [0, { "ezproxy": _3 }], "123website": _3, "myspreadshop": _3, "transurl": _5 }], "bf": _7, "bg": [1, { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 }], "bh": _4, "bi": [1, { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 }], "biz": [1, { "activetrail": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 }], "bj": [1, { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 }], "bm": _4, "bn": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 }], "bo": [1, { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 }], "br": [1, { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": [1, { "blogspot": _3, "simplesite": _3 }], "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": [1, { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 }], "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": [1, { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 }], "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 }], "bs": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 }], "bt": _4, "bv": _2, "bw": [1, { "co": _2, "org": _2 }], "by": [1, { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 }], "bz": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 }], "ca": [1, { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 }], "cat": _2, "cc": [1, { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": [0, { "instances": _3 }] }], "cd": _7, "cf": _6, "cg": _2, "ch": [1, { "square7": _3, "blogspot": _3, "flow": [0, { "ae": [0, { "alp1": _3 }], "appengine": _3 }], "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": [0, { "*": _3, "svc": _5 }], "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "ci": [1, { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aéroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 }], "ck": _8, "cl": [1, { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "cm": [1, { "co": _2, "com": _2, "gov": _2, "net": _2 }], "cn": [1, { "ac": _2, "com": [1, { "amazonaws": [0, { "compute": _5, "cn-north-1": _12, "eb": [0, { "cn-north-1": _3, "cn-northwest-1": _3 }], "elb": _5 }] }], "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "公司": _2, "xn--io0a7i": _2, "网络": _2, "xn--od0alg": _2, "網絡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "instantcloud": _3, "quickconnect": _13 }], "co": [1, { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 }], "com": [1, { "devcdnaccesso": _5, "adobeaemcloud": [2, { "dev": _5 }], "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": [0, { "compute": _5, "compute-1": _5, "us-east-1": [2, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "ap-northeast-1": _18, "ap-northeast-2": _19, "ap-south-1": _19, "ap-southeast-1": _20, "ap-southeast-2": _20, "ca-central-1": _19, "eu-central-1": _19, "eu-west-1": _18, "eu-west-2": _19, "eu-west-3": _19, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _20, "us-east-2": [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "us-west-2": [0, { "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "af-south-1": _17, "ap-east-1": _17, "ap-northeast-3": _17, "eu-north-1": _17, "eu-south-1": _17, "me-south-1": _17, "us-west-1": _17, "elb": _5 }], "elasticbeanstalk": [2, { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 }], "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "customer-oci": [0, { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 }], "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": [0, { "demo": _3, "instance": _3 }], "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": [0, { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 }], "onfabrica": _3, "fbsbx": _21, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": [2, { "r": _5 }], "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "dopaas": _3, "hosted-by-previder": _22, "hosteur": [0, { "rag-cloud": _3, "rag-cloud-ch": _3 }], "ik-server": [0, { "jcloud": _3, "jcloud-ver-jpc": _3 }], "jelastic": [0, { "demo": _3 }], "kilatiron": _3, "massivegrid": _22, "wafaicloud": [0, { "jed": _3, "lon": _3, "ryd": _3 }], "joyent": [0, { "cns": _5 }], "ktistory": _3, "lpusercontent": _3, "lmpm": _23, "linode": [0, { "members": _3, "nodebalancer": _5 }], "linodeobjects": _5, "linodeusercontent": [0, { "ip": _3 }], "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _24, "hostedpi": _3, "mythic-beasts": [0, { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 }], "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": [0, { "static": _3 }], "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": [0, { "xen": _3 }], "pythonanywhere": _24, "qualifioapp": _3, "ladesk": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _23, "onrender": _3, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": [0, { "builder": _5, "dev-builder": _5, "stg-builder": _5 }], "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": [2, { "alpha": _3, "beta": _3 }], "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": [0, { "api": _3 }], "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "tb-hosting": _25, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": [0, { "pro": _3 }], "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _26, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": [2, { "js": _3 }], "wixsite": _3, "xnbay": [2, { "u2": _3, "u2-local": _3 }], "yolasite": _3 }], "coop": _2, "cr": [1, { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 }], "cu": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 }], "cv": [1, { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 }], "cw": _27, "cx": [1, { "gov": _2, "ath": _3, "info": _3 }], "cy": [1, { "ac": _2, "biz": _2, "com": [1, { "blogspot": _3, "scaleforce": _28 }], "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 }], "cz": [1, { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": [0, { "cloud": _5, "custom": _3 }], "muni": [0, { "cloud": [0, { "flt": _3, "usr": _3 }] }] }], "de": [1, { "bplaced": _3, "square7": _3, "com": _3, "cosidns": [0, { "dyn": _3 }], "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": [2, { "dyn": _3, "dyndns": _3 }], "dyndns1": _3, "dyn-ip24": _3, "home-webserver": [2, { "dyn": _3 }], "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "günstigbestellen": _3, "xn--gnstigliefern-wob": _3, "günstigliefern": _3, "hs-heilbronn": [0, { "it": _26 }], "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": [0, { "customer": _3 }], "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 }], "dj": _2, "dk": [1, { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "dm": _4, "do": [1, { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 }], "dz": [1, { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 }], "ec": [1, { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 }], "edu": [1, { "rit": [0, { "git-pages": _3 }] }], "ee": [1, { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 }], "eg": [1, { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 }], "er": _8, "es": [1, { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 }], "et": [1, { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 }], "eu": [1, { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _29, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 }], "fi": [1, { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "häkkinen": _3, "iki": _3, "cloudplatform": [0, { "fi": _3 }], "datacenter": [0, { "demo": _3, "paas": _3 }], "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 }], "fj": [1, { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "fk": _8, "fm": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 }], "fo": _2, "fr": [1, { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "avoues": _2, "cci": _2, "greta": _2, "huissier-justice": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "aeroport": _3, "avocat": _3, "chambagri": _3, "chirurgiens-dentistes": _3, "experts-comptables": _3, "medecin": _3, "notaires": _3, "pharmacien": _3, "port": _3, "veterinaire": _3, "myspreadshop": _3, "ynh": _3 }], "ga": _2, "gb": _2, "gd": [1, { "edu": _2, "gov": _2 }], "ge": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 }], "gf": _2, "gg": [1, { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": [2, { "daemon": _3 }] }], "gh": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 }], "gi": [1, { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 }], "gl": [1, { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 }], "gm": _2, "gn": [1, { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 }], "gov": _2, "gp": [1, { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 }], "gq": _2, "gr": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 }], "gs": _2, "gt": [1, { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 }], "gu": [1, { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 }], "gw": _2, "gy": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 }], "hk": [1, { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "公司": _2, "xn--wcvs22d": _2, "教育": _2, "xn--lcvr32d": _2, "敎育": _2, "xn--mxtq1m": _2, "政府": _2, "xn--gmqw5a": _2, "個人": _2, "xn--ciqpn": _2, "个人": _2, "xn--gmq050i": _2, "箇人": _2, "xn--zf0avx": _2, "網络": _2, "xn--io0a7i": _2, "网络": _2, "xn--mk0axi": _2, "组織": _2, "xn--od0alg": _2, "網絡": _2, "xn--od0aq3b": _2, "网絡": _2, "xn--tn0ag": _2, "组织": _2, "xn--uc0atv": _2, "組織": _2, "xn--uc0ay4a": _2, "組织": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 }], "hm": _2, "hn": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 }], "hr": [1, { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 }], "ht": [1, { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 }], "hu": [1, { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 }], "id": [1, { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": [1, { "rss": _5 }], "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 }], "ie": [1, { "gov": _2, "blogspot": _3, "myspreadshop": _3 }], "il": [1, { "ac": _2, "co": [1, { "ravpage": _3, "blogspot": _3, "tabitorder": _3, "mytabit": _3 }], "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 }], "ישראל": [1, { "אקדמיה": _2, "ישוב": _2, "צהל": _2, "ממשל": _2 }], "im": [1, { "ac": _2, "co": [1, { "ltd": _2, "plc": _2 }], "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 }], "in": [1, { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 }], "info": [1, { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 }], "int": [1, { "eu": _2 }], "io": [1, { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": [0, { "app": _3, "backyards": _5 }], "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": [0, { "uk0": _3 }], "cleverapps": _3, "dappnode": [0, { "dyndns": _3 }], "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": [0, { "id": _3 }], "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _22, "beebyteapp": [0, { "sekd1": _3 }], "jele": _3, "unispace": [0, { "cloud-fr1": _3 }], "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": [2, { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 }], "nodeart": [0, { "stage": _3 }], "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": [2, { "mock": _3 }], "protonet": _3, "qoto": _3, "qcx": [2, { "sys": _5 }], "vaporcloud": _3, "vbrplsbx": [0, { "g": _3 }], "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": [0, { "devices": _3 }], "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _21, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": [0, { "dev": _32, "disrec": _32, "prod": _33, "testing": _32 }], "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "wixstudio": _3, "basicserver": _3, "virtualserver": _3 }], "iq": _34, "ir": [1, { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2 }], "is": [1, { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 }], "it": [1, { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-süd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-südtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-süd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-südtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosüd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosüdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsüd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsüdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallée-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallée-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valléeaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valléedaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-südtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-südtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-südtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlì": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlì": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlì-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlìcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "südtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": [0, { "jc": _3 }], "tim": [0, { "open": [0, { "jelastic": _9 }] }], "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 }], "je": [1, { "co": _2, "net": _2, "org": _2, "of": _3 }], "jm": _8, "jo": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 }], "jobs": _2, "jp": [1, { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": [1, { "aseinet": _30, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 }], "or": _2, "aichi": [1, { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 }], "akita": [1, { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 }], "aomori": [1, { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 }], "chiba": [1, { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 }], "ehime": [1, { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 }], "fukui": [1, { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 }], "fukuoka": [1, { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 }], "fukushima": [1, { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 }], "gifu": [1, { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 }], "gunma": [1, { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 }], "hiroshima": [1, { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 }], "hokkaido": [1, { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 }], "hyogo": [1, { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 }], "ibaraki": [1, { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 }], "ishikawa": [1, { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 }], "iwate": [1, { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 }], "kagawa": [1, { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 }], "kagoshima": [1, { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 }], "kanagawa": [1, { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 }], "kochi": [1, { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 }], "kumamoto": [1, { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 }], "kyoto": [1, { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 }], "mie": [1, { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 }], "miyagi": [1, { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 }], "miyazaki": [1, { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 }], "nagano": [1, { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 }], "nagasaki": [1, { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 }], "nara": [1, { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 }], "niigata": [1, { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 }], "oita": [1, { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 }], "okayama": [1, { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 }], "okinawa": [1, { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 }], "osaka": [1, { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 }], "saga": [1, { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 }], "saitama": [1, { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 }], "shiga": [1, { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 }], "shimane": [1, { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 }], "shizuoka": [1, { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 }], "tochigi": [1, { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 }], "tokushima": [1, { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 }], "tokyo": [1, { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 }], "tottori": [1, { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 }], "toyama": [1, { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 }], "wakayama": [1, { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 }], "yamagata": [1, { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 }], "yamaguchi": [1, { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 }], "yamanashi": [1, { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 }], "xn--4pvxs": _2, "栃木": _2, "xn--vgu402c": _2, "愛知": _2, "xn--c3s14m": _2, "愛媛": _2, "xn--f6qx53a": _2, "兵庫": _2, "xn--8pvr4u": _2, "熊本": _2, "xn--uist22h": _2, "茨城": _2, "xn--djrs72d6uy": _2, "北海道": _2, "xn--mkru45i": _2, "千葉": _2, "xn--0trq7p7nn": _2, "和歌山": _2, "xn--8ltr62k": _2, "長崎": _2, "xn--2m4a15e": _2, "長野": _2, "xn--efvn9s": _2, "新潟": _2, "xn--32vp30h": _2, "青森": _2, "xn--4it797k": _2, "静岡": _2, "xn--1lqs71d": _2, "東京": _2, "xn--5rtp49c": _2, "石川": _2, "xn--5js045d": _2, "埼玉": _2, "xn--ehqz56n": _2, "三重": _2, "xn--1lqs03n": _2, "京都": _2, "xn--qqqt11m": _2, "佐賀": _2, "xn--kbrq7o": _2, "大分": _2, "xn--pssu33l": _2, "大阪": _2, "xn--ntsq17g": _2, "奈良": _2, "xn--uisz3g": _2, "宮城": _2, "xn--6btw5a": _2, "宮崎": _2, "xn--1ctwo": _2, "富山": _2, "xn--6orx2r": _2, "山口": _2, "xn--rht61e": _2, "山形": _2, "xn--rht27z": _2, "山梨": _2, "xn--djty4k": _2, "岩手": _2, "xn--nit225k": _2, "岐阜": _2, "xn--rht3d": _2, "岡山": _2, "xn--klty5x": _2, "島根": _2, "xn--kltx9a": _2, "広島": _2, "xn--kltp7d": _2, "徳島": _2, "xn--uuwu58a": _2, "沖縄": _2, "xn--zbx025d": _2, "滋賀": _2, "xn--ntso0iqx3a": _2, "神奈川": _2, "xn--elqq16h": _2, "福井": _2, "xn--4it168d": _2, "福岡": _2, "xn--klt787d": _2, "福島": _2, "xn--rny31h": _2, "秋田": _2, "xn--7t0a264c": _2, "群馬": _2, "xn--5rtq34k": _2, "香川": _2, "xn--k7yn95e": _2, "高知": _2, "xn--tor131o": _2, "鳥取": _2, "xn--d5qv7z876c": _2, "鹿児島": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": [0, { "isk01": _12, "isk02": _12 }], "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": [0, { "rs": _3, "user": _3 }], "websozai": _3, "xii": _3 }], "ke": [1, { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 }], "kg": [1, { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 }], "kh": _8, "ki": _35, "km": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 }], "kn": [1, { "net": _2, "org": _2, "edu": _2, "gov": _2 }], "kp": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 }], "kr": [1, { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 }], "kw": [1, { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 }], "ky": _27, "kz": [1, { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": [0, { "upaas": _3 }] }], "la": [1, { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 }], "lb": _4, "lc": [1, { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 }], "li": [1, { "blogspot": _3, "caa": _3 }], "lk": [1, { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 }], "lr": _4, "ls": [1, { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 }], "lt": _36, "lu": [1, { "blogspot": _3, "123website": _3 }], "lv": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 }], "ly": [1, { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 }], "ma": [1, { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 }], "mc": [1, { "tm": _2, "asso": _2 }], "md": [1, { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 }], "me": [1, { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": [2, { "localhost": _3 }], "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _25, "wedeploy": _3, "yombo": _3, "nohost": _3 }], "mg": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 }], "mh": _2, "mil": _2, "mk": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 }], "ml": [1, { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 }], "mm": _8, "mn": [1, { "gov": _2, "edu": _2, "org": _2, "nyc": _3 }], "mo": _4, "mobi": [1, { "barsy": _3, "dscloud": _3 }], "mp": [1, { "ju": _3 }], "mq": _2, "mr": _36, "ms": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 }], "mt": [1, { "com": _6, "edu": _2, "net": _2, "org": _2 }], "mu": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 }], "museum": _2, "mv": [1, { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "mw": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 }], "mx": [1, { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 }], "my": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 }], "mz": [1, { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "na": [1, { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 }], "name": [1, { "her": _39, "his": _39 }], "nc": [1, { "asso": _2, "nom": _2 }], "ne": _2, "net": [1, { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": [0, { "prod": [0, { "cdn": _3 }] }], "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": [0, { "r": _3 }], "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": [2, { "u": _3 }], "fastlylb": [2, { "map": _3 }], "fastly": [0, { "freetls": _3, "map": _3, "prod": [0, { "a": _3, "global": _3 }], "ssl": [0, { "a": _3, "b": _3, "global": _3 }] }], "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": [2, { "fra1-de": _3, "west1-us": _3 }], "elastx": [0, { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 }], "faststacks": _3, "massivegrid": [0, { "paas": [0, { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 }] }], "saveincloud": [0, { "jelastic": _3, "nordeste-idc": _3 }], "scaleforce": _28, "tsukaeru": _29, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": [2, { "1": _3, "2": _3, "3": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 }], "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": [0, { "webpaas": _5, "hosting": _5 }], "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": [2, { "jelastic": [0, { "atl": _3, "njs": _3, "ric": _3 }] }], "myspreadshop": _3, "srcf": [0, { "soc": _3, "user": _3 }], "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": [0, { "beta": _3 }], "ts": _3, "torproject": [2, { "pages": _3 }], "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": [2, { "storage": _3, "website": _3 }], "za": _3 }], "nf": [1, { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 }], "ng": [1, { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 }], "ni": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 }], "nl": [1, { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 }], "no": [1, { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _40, "ah": _40, "bu": _40, "fm": _40, "hl": _40, "hm": _40, "jan-mayen": _40, "mr": _40, "nl": _40, "nt": _40, "of": _40, "ol": _40, "oslo": _40, "rl": _40, "sf": _40, "st": _40, "svalbard": _40, "tm": _40, "tr": _40, "va": _40, "vf": _40, "akrehamn": _2, "xn--krehamn-dxa": _2, "åkrehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "ålgård": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brønnøysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drøbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florø": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hønefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jørpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevåg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjøndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjøen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osøyro": _2, "raholt": _2, "xn--rholt-mra": _2, "råholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjøen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjørdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "åfjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "ål": _2, "alesund": _2, "xn--lesund-hua": _2, "ålesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "áltá": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "álaheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "åmli": _2, "amot": _2, "xn--mot-tla": _2, "åmot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andøy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "årdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "ås": _2, "aseral": _2, "xn--seral-lra": _2, "åseral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askøy": _2, "asnes": _2, "xn--snes-poa": _2, "åsnes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-høland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averøy": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bálát": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "báhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bájddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "báidár": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevåg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalváhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkøy": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodø": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bådåddjå": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brønnøy": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bærum": _2, "telemark": [0, { "bo": _2, "xn--b-5ga": _2, "bø": _2 }], "nordland": [0, { "bo": _2, "xn--b-5ga": _2, "bø": _2, "heroy": _2, "xn--hery-ira": _2, "herøy": _2 }], "bievat": _2, "xn--bievt-0qa": _2, "bievát": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bømlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "båtsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "báhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrøy": _2, "donna": _2, "xn--dnna-gra": _2, "dønna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenášši": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnøy": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flå": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "fræna": _2, "froya": _2, "xn--frya-hra": _2, "frøya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "førde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gáŋgaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskål": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjøvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kråanghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hábmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hápmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hámmárfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "ákŋoluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": [0, { "heroy": _2, "sande": _2 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _2, "sande": _2 }], "møre-og-romsdal": [0, { "herøy": _2, "sande": _2 }], "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobøl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtålen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hægebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "høyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "høylandet": _2, "ha": _2, "xn--h-2fa": _2, "hå": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderøy": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jølster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kárášjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gálsá": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmøy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klæbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerø": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krødsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "ráhkkerávju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsøy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvæfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvænangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "návuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kåfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gáivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabát": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaŋgaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindås": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "láhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurøy": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lærdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lødingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lørenskog": _2, "loten": _2, "xn--lten-gra": _2, "løten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "måsøy": _2, "muosat": _2, "xn--muost-0qa": _2, "muosát": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "meløy": _2, "meraker": _2, "xn--merker-kua": _2, "meråker": _2, "moareke": _2, "xn--moreke-jua": _2, "moåreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "målselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "málatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nååmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _41, "buskerud": _41, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjárga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjárga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "ráisa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nærøy": _2, "notteroy": _2, "xn--nttery-byae": _2, "nøtterøy": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "øksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegård": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "ørland": _2, "orskog": _2, "xn--rskog-uua": _2, "ørskog": _2, "orsta": _2, "xn--rsta-fra": _2, "ørsta": _2, "hedmark": [0, { "os": _2, "valer": _2, "xn--vler-qoa": _2, "våler": _2 }], "hordaland": [0, { "os": _2 }], "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterøy": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "østre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "øvre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "øyer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "øygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "øystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsáŋgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radøy": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesøy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risør": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rælingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rødøy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rømskog": _2, "roros": _2, "xn--rros-gra": _2, "røros": _2, "rost": _2, "xn--rst-0na": _2, "røst": _2, "royken": _2, "xn--ryken-vua": _2, "røyken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "røyrvik": _2, "rade": _2, "xn--rde-ula": _2, "råde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sálát": _2, "xn--slat-5na": _2, "sálat": _2, "samnanger": _2, "vestfold": [0, { "sande": _2 }], "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandøy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervøy": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervá": _2, "skjak": _2, "xn--skjk-soa": _2, "skjåk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skånland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skánit": _2, "smola": _2, "xn--smla-hra": _2, "smøla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snåsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snåase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjørdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "søgne": _2, "somna": _2, "xn--smna-gra": _2, "sømna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "søndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sør-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sør-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sør-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sør-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mátta-várjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sørfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sørreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sørum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjøme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranøy": _2, "tromso": _2, "xn--troms-zua": _2, "tromsø": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "træna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trøgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvær": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tønsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsø": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "čáhcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardø": _2, "varggat": _2, "xn--vrggt-xqad": _2, "várggát": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegårshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvågøy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "værøy": _2, "vagan": _2, "xn--vgan-qoa": _2, "vågan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vågsøy": _2, "vaga": _2, "xn--vg-yiab": _2, "vågå": _2, "ostfold": [0, { "valer": _2 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _2 }], "østfold": [0, { "våler": _2 }], "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "np": _8, "nr": _35, "nu": [1, { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 }], "nz": [1, { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "māori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 }], "om": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 }], "onion": _2, "org": [1, { "altervista": _3, "amune": [0, { "tele": _3 }], "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": [0, { "c": _3, "rsc": _3 }], "cdn77-secure": [0, { "origin": [0, { "ssl": _3 }] }], "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": [2, { "go": _3, "home": _3 }], "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": [2, { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 }], "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": [0, { "cloud": _3, "os": _23, "stg": [0, { "os": _23 }] }], "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 }], "pa": [1, { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 }], "pe": [1, { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 }], "pf": [1, { "com": _2, "org": _2, "edu": _2 }], "pg": _8, "ph": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 }], "pk": [1, { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 }], "pl": [1, { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": [1, { "ap": _2, "griw": _2, "ic": _2, "is": _2, "kmpsp": _2, "konsulat": _2, "kppsp": _2, "kwp": _2, "kwpsp": _2, "mup": _2, "mw": _2, "oia": _2, "oirm": _2, "oke": _2, "oow": _2, "oschr": _2, "oum": _2, "pa": _2, "pinb": _2, "piw": _2, "po": _2, "pr": _2, "psp": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "sdn": _2, "sko": _2, "so": _2, "sr": _2, "starostwo": _2, "ug": _2, "ugim": _2, "um": _2, "umig": _2, "upow": _2, "uppo": _2, "us": _2, "uw": _2, "uzs": _2, "wif": _2, "wiih": _2, "winb": _2, "wios": _2, "witd": _2, "wiw": _2, "wkz": _2, "wsa": _2, "wskr": _2, "wsse": _2, "wuoz": _2, "wzmiuw": _2, "zp": _2, "zpisdn": _2 }], "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 }], "pm": [1, { "own": _3, "name": _3 }], "pn": [1, { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 }], "post": _2, "pr": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 }], "pro": [1, { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": [0, { "bci": _3 }], "barsy": _3 }], "ps": [1, { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 }], "pt": [1, { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 }], "pw": [1, { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 }], "py": [1, { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "qa": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 }], "re": [1, { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 }], "ro": [1, { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 }], "rs": [1, { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": [0, { "shop": _3 }], "blogspot": _3, "ua": _3, "ox": _3 }], "ru": [1, { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _29, "myjino": [2, { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 }], "cldmail": [0, { "hb": _3 }], "mcdir": [2, { "vps": _3 }], "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 }], "rw": [1, { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "sa": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 }], "sb": _4, "sc": _4, "sd": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 }], "se": [1, { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": [0, { "su": _3 }] }], "sg": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 }], "sh": [1, { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": [0, { "bc": _3, "ent": _3, "eu": _3, "us": _3 }], "now": _3, "vxl": _3, "wedeploy": _3 }], "si": [1, { "gitapp": _3, "gitpage": _3, "blogspot": _3 }], "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": [1, { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 }], "so": [1, { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 }], "sr": _2, "ss": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 }], "st": [1, { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "kirara": _3, "noho": _3 }], "su": [1, { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 }], "sv": [1, { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 }], "sx": _7, "sy": _34, "sz": [1, { "co": _2, "ac": _2, "org": _2 }], "tc": [1, { "ch": _3, "me": _3, "we": _3 }], "td": _6, "tel": _2, "tf": [1, { "sch": _3 }], "tg": _2, "th": [1, { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 }], "tj": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 }], "tk": _2, "tl": _7, "tm": [1, { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 }], "tn": [1, { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 }], "to": [1, { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "x0": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 }], "tr": [1, { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 }], "tt": [1, { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 }], "tv": [1, { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 }], "tw": [1, { "edu": _2, "gov": _2, "mil": _2, "com": [1, { "mymailer": _3 }], "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "網路": _2, "xn--uc0atv": _2, "組織": _2, "xn--czrw28b": _2, "商業": _2, "url": _3, "blogspot": _3 }], "tz": [1, { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 }], "ua": [1, { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "kropyvnytskyi": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "luhansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "uzhhorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zakarpattia": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 }], "ug": [1, { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 }], "uk": [1, { "ac": _2, "co": [1, { "bytemark": [0, { "dh": _3, "vm": _3 }], "blogspot": _3, "layershift": _28, "barsy": _3, "barsyonline": _3, "retrosnub": _33, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3 }], "gov": [1, { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 }], "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": [1, { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 }], "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 }], "us": [1, { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _42, "al": _42, "ar": _42, "as": _42, "az": _42, "ca": _42, "co": _42, "ct": _42, "dc": _42, "de": [1, { "cc": _2, "lib": _3 }], "fl": _42, "ga": _42, "gu": _42, "hi": _43, "ia": _42, "id": _42, "il": _42, "in": _42, "ks": _42, "ky": _42, "la": _42, "ma": [1, { "k12": [1, { "pvt": _2, "chtr": _2, "paroch": _2 }], "cc": _2, "lib": _2 }], "md": _42, "me": _42, "mi": [1, { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 }], "mn": _42, "mo": _42, "ms": _42, "mt": _42, "nc": _42, "nd": _43, "ne": _42, "nh": _42, "nj": _42, "nm": _42, "nv": _42, "ny": _42, "oh": _42, "ok": _42, "or": _42, "pa": _42, "pr": _42, "ri": _43, "sc": _42, "sd": _43, "tn": _42, "tx": _42, "ut": _42, "vi": _42, "vt": _42, "va": _42, "wa": _42, "wi": _42, "wv": [1, { "cc": _2 }], "wy": _42, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": [0, { "phx": _3 }], "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 }], "uy": [1, { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 }], "uz": [1, { "co": _2, "com": _2, "net": _2, "org": _2 }], "va": _2, "vc": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": [2, { "d": _3 }], "0e": _3 }], "ve": [1, { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 }], "vg": [1, { "at": _3 }], "vi": [1, { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 }], "vn": [1, { "ac": _2, "ai": _2, "biz": _2, "com": _2, "edu": _2, "gov": _2, "health": _2, "id": _2, "info": _2, "int": _2, "io": _2, "name": _2, "net": _2, "org": _2, "pro": _2, "angiang": _2, "bacgiang": _2, "backan": _2, "baclieu": _2, "bacninh": _2, "baria-vungtau": _2, "bentre": _2, "binhdinh": _2, "binhduong": _2, "binhphuoc": _2, "binhthuan": _2, "camau": _2, "cantho": _2, "caobang": _2, "daklak": _2, "daknong": _2, "danang": _2, "dienbien": _2, "dongnai": _2, "dongthap": _2, "gialai": _2, "hagiang": _2, "haiduong": _2, "haiphong": _2, "hanam": _2, "hanoi": _2, "hatinh": _2, "haugiang": _2, "hoabinh": _2, "hungyen": _2, "khanhhoa": _2, "kiengiang": _2, "kontum": _2, "laichau": _2, "lamdong": _2, "langson": _2, "laocai": _2, "longan": _2, "namdinh": _2, "nghean": _2, "ninhbinh": _2, "ninhthuan": _2, "phutho": _2, "phuyen": _2, "quangbinh": _2, "quangnam": _2, "quangngai": _2, "quangninh": _2, "quangtri": _2, "soctrang": _2, "sonla": _2, "tayninh": _2, "thaibinh": _2, "thainguyen": _2, "thanhhoa": _2, "thanhphohochiminh": _2, "thuathienhue": _2, "tiengiang": _2, "travinh": _2, "tuyenquang": _2, "vinhlong": _2, "vinhphuc": _2, "yenbai": _2, "blogspot": _3 }], "vu": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 }], "wf": [1, { "biz": _3, "sch": _3 }], "ws": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 }], "yt": [1, { "org": _3 }], "xn--mgbaam7a8h": _2, "امارات": _2, "xn--y9a3aq": _2, "հայ": _2, "xn--54b7fta0cc": _2, "বাংলা": _2, "xn--90ae": _2, "бг": _2, "xn--mgbcpq6gpa1a": _2, "البحرين": _2, "xn--90ais": _2, "бел": _2, "xn--fiqs8s": _2, "中国": _2, "xn--fiqz9s": _2, "中國": _2, "xn--lgbbat1ad8j": _2, "الجزائر": _2, "xn--wgbh1c": _2, "مصر": _2, "xn--e1a4c": _2, "ею": _2, "xn--qxa6a": _2, "ευ": _2, "xn--mgbah1a3hjkrd": _2, "موريتانيا": _2, "xn--node": _2, "გე": _2, "xn--qxam": _2, "ελ": _2, "xn--j6w193g": [1, { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 }], "香港": [1, { "公司": _2, "教育": _2, "政府": _2, "個人": _2, "網絡": _2, "組織": _2 }], "xn--2scrj9c": _2, "ಭಾರತ": _2, "xn--3hcrj9c": _2, "ଭାରତ": _2, "xn--45br5cyl": _2, "ভাৰত": _2, "xn--h2breg3eve": _2, "भारतम्": _2, "xn--h2brj9c8c": _2, "भारोत": _2, "xn--mgbgu82a": _2, "ڀارت": _2, "xn--rvc1e0am3e": _2, "ഭാരതം": _2, "xn--h2brj9c": _2, "भारत": _2, "xn--mgbbh1a": _2, "بارت": _2, "xn--mgbbh1a71e": _2, "بھارت": _2, "xn--fpcrj9c3d": _2, "భారత్": _2, "xn--gecrj9c": _2, "ભારત": _2, "xn--s9brj9c": _2, "ਭਾਰਤ": _2, "xn--45brj9c": _2, "ভারত": _2, "xn--xkc2dl3a5ee0h": _2, "இந்தியா": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2, "xn--mgbtx2b": _2, "عراق": _2, "xn--mgbayh7gpa": _2, "الاردن": _2, "xn--3e0b707e": _2, "한국": _2, "xn--80ao21a": _2, "қаз": _2, "xn--q7ce6a": _2, "ລາວ": _2, "xn--fzc2c9e2c": _2, "ලංකා": _2, "xn--xkc2al3hye2a": _2, "இலங்கை": _2, "xn--mgbc0a9azcg": _2, "المغرب": _2, "xn--d1alf": _2, "мкд": _2, "xn--l1acc": _2, "мон": _2, "xn--mix891f": _2, "澳門": _2, "xn--mix082f": _2, "澳门": _2, "xn--mgbx4cd0ab": _2, "مليسيا": _2, "xn--mgb9awbf": _2, "عمان": _2, "xn--mgbai9azgqp6j": _2, "پاکستان": _2, "xn--mgbai9a5eva00b": _2, "پاكستان": _2, "xn--ygbi2ammx": _2, "فلسطين": _2, "xn--90a3ac": [1, { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 }], "срб": [1, { "пр": _2, "орг": _2, "обр": _2, "од": _2, "упр": _2, "ак": _2 }], "xn--p1ai": _2, "рф": _2, "xn--wgbl6a": _2, "قطر": _2, "xn--mgberp4a5d4ar": _2, "السعودية": _2, "xn--mgberp4a5d4a87g": _2, "السعودیة": _2, "xn--mgbqly7c0a67fbc": _2, "السعودیۃ": _2, "xn--mgbqly7cvafr": _2, "السعوديه": _2, "xn--mgbpl2fh": _2, "سودان": _2, "xn--yfro4i67o": _2, "新加坡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "சிங்கப்பூர்": _2, "xn--ogbpf8fl": _2, "سورية": _2, "xn--mgbtf8fl": _2, "سوريا": _2, "xn--o3cw4h": [1, { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 }], "ไทย": [1, { "ศึกษา": _2, "ธุรกิจ": _2, "รัฐบาล": _2, "ทหาร": _2, "เน็ต": _2, "องค์กร": _2 }], "xn--pgbs0dh": _2, "تونس": _2, "xn--kpry57d": _2, "台灣": _2, "xn--kprw13d": _2, "台湾": _2, "xn--nnx388a": _2, "臺灣": _2, "xn--j1amh": _2, "укр": _2, "xn--mgb2ddes": _2, "اليمن": _2, "xxx": _2, "ye": _34, "za": [0, { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 }], "zm": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 }], "zw": [1, { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 }], "aaa": _2, "aarp": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": [1, { "official": _3 }], "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": [1, { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": [2, { "a": _3 }], "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "snowflake": [2, { "privatelink": _3 }], "streamlit": _3, "storipress": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 }], "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": [1, { "aus": _3, "nz": _3 }], "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": [1, { "cloudsite": _3 }], "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": [1, { "nabu": [0, { "ui": _3 }] }], "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": [1, { "banzai": _5, "elementor": _3, "encoway": [0, { "eu": _3 }], "statics": _5, "ravendb": _3, "axarnet": [0, { "es-1": _3 }], "diadem": _3, "jelastic": [0, { "vip": _3 }], "jele": _3, "jenv-aruba": [0, { "aruba": [0, { "eur": [0, { "it1": _3 }] }], "it1": _3 }], "keliweb": [2, { "cs": _3 }], "oxa": [2, { "tn": _3, "uk": _3 }], "primetel": [2, { "uk": _3 }], "reclaim": [0, { "ca": _3, "uk": _3, "us": _3 }], "trendhosting": [0, { "ch": _3, "de": _3 }], "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": [0, { "baremetal": [0, { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 }], "fr-par": [0, { "fnc": [2, { "functions": _3 }], "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "instances": [0, { "priv": _3, "pub": _3 }], "k8s": _3, "nl-ams": [0, { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "pl-waw": [0, { "k8s": _11, "s3": _3, "s3-website": _3 }], "scalebook": _3, "smartlabeling": _3 }], "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 }], "club": [1, { "cloudns": _3, "jele": _3, "barsy": _3 }], "clubmed": _2, "coach": _2, "codes": [1, { "owo": _5 }], "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": [1, { "nog": _3, "ravendb": _3, "myforum": _3 }], "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cool": [1, { "elementor": _3, "de": _3 }], "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": [1, { "bss": _3 }], "dev": [1, { "autocode": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": [0, { "user": _5 }], "loginline": _3, "mediatech": _3, "ngrok": _3, "ngrok-free": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 }], "dhl": _2, "diamonds": _2, "diet": _2, "digital": [1, { "cloudapps": [2, { "london": _3 }] }], "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": [1, { "dapps": [0, { "*": _3, "bzz": _5 }] }], "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": [1, { "compute": _5 }], "etisalat": _2, "eurovision": _2, "eus": [1, { "party": _30 }], "events": [1, { "koobin": _3, "co": _3 }], "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _31, "family": _2, "fan": _2, "fans": _2, "farm": [1, { "storj": _3 }], "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": [1, { "cnpy": _3 }], "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": [1, { "cloud": _3, "translate": _3, "usercontent": _5 }], "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": [1, { "discourse": _3 }], "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": [1, { "hra": _3 }], "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": [1, { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 }], "hosting": [1, { "opencraft": _3 }], "hot": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": [1, { "co": _3, "edu": _3 }], "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "land": [1, { "static": [2, { "dev": _3, "sites": _3 }] }], "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "link": [1, { "cyon": _3, "mypep": _3, "dweb": _5 }], "lipsy": _2, "live": [1, { "hlx": _3 }], "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": [1, { "omg": _3 }], "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": [1, { "router": _3 }], "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _37, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _38, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": [1, { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 }], "neustar": _2, "new": _2, "news": [1, { "noticeable": _3 }], "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": [1, { "onred": [2, { "staging": _3 }], "service": _3, "homelink": _3 }], "ong": _2, "onl": _2, "online": [1, { "eero": _3, "eero-stage": _3, "barsy": _3 }], "ooo": _2, "open": _2, "oracle": _2, "orange": [1, { "tech": _3 }], "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": [1, { "nerdpol": _3 }], "page": [1, { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 }], "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _31, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _37, "physio": _2, "pics": _2, "pictet": _2, "pictures": [1, { "1337": _3 }], "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": [1, { "ngrok": _3 }], "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": [1, { "indie": _3 }], "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _38, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _31, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": [1, { "clan": _3 }], "rocher": _2, "rocks": [1, { "myddns": _3, "lima-city": _3, "webspace": _3 }], "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": [1, { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3, "wix": _3 }], "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _31, "scot": [1, { "edu": _3, "gov": [2, { "service": _3 }] }], "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": [1, { "loginline": _3 }], "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": [1, { "base": _3, "hoplix": _3, "barsy": _3 }], "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": [1, { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 }], "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": [1, { "diher": _5 }], "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": [1, { "myfast": _3, "uber": _3, "xs4all": _3 }], "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": [1, { "sellfy": _3, "shopware": _3, "storebase": _3 }], "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _38, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": [1, { "knightpoint": _3 }], "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": [1, { "discourse": _3, "jelastic": _3 }], "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": [1, { "prequalifyme": _3 }], "tokyo": _2, "tools": _2, "top": [1, { "now-dns": _3, "ntdll": _3 }], "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _31, "trading": _2, "training": _2, "travel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _37, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _37, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "कॉम": _2, "xn--1ck2e1b": _2, "セール": _2, "xn--1qqw23a": _2, "佛山": _2, "xn--30rr7y": _2, "慈善": _2, "xn--3bst00m": _2, "集团": _2, "xn--3ds443g": _2, "在线": _2, "xn--3pxu8k": _2, "点看": _2, "xn--42c2d9a": _2, "คอม": _2, "xn--45q11c": _2, "八卦": _2, "xn--4gbrim": _2, "موقع": _2, "xn--55qw42g": _2, "公益": _2, "xn--55qx5d": _2, "公司": _2, "xn--5su34j936bgsg": _2, "香格里拉": _2, "xn--5tzm5g": _2, "网站": _2, "xn--6frz82g": _2, "移动": _2, "xn--6qq986b3xl": _2, "我爱你": _2, "xn--80adxhks": _2, "москва": _2, "xn--80aqecdr1a": _2, "католик": _2, "xn--80asehdb": _2, "онлайн": _2, "xn--80aswg": _2, "сайт": _2, "xn--8y0a063a": _2, "联通": _2, "xn--9dbq2a": _2, "קום": _2, "xn--9et52u": _2, "时尚": _2, "xn--9krt00a": _2, "微博": _2, "xn--b4w605ferd": _2, "淡马锡": _2, "xn--bck1b9a5dre4c": _2, "ファッション": _2, "xn--c1avg": _2, "орг": _2, "xn--c2br7g": _2, "नेट": _2, "xn--cck2b3b": _2, "ストア": _2, "xn--cckwcxetd": _2, "アマゾン": _2, "xn--cg4bki": _2, "삼성": _2, "xn--czr694b": _2, "商标": _2, "xn--czrs0t": _2, "商店": _2, "xn--czru2d": _2, "商城": _2, "xn--d1acj3b": _2, "дети": _2, "xn--eckvdtc9d": _2, "ポイント": _2, "xn--efvy88h": _2, "新闻": _2, "xn--fct429k": _2, "家電": _2, "xn--fhbei": _2, "كوم": _2, "xn--fiq228c5hs": _2, "中文网": _2, "xn--fiq64b": _2, "中信": _2, "xn--fjq720a": _2, "娱乐": _2, "xn--flw351e": _2, "谷歌": _2, "xn--fzys8d69uvgm": _2, "電訊盈科": _2, "xn--g2xx48c": _2, "购物": _2, "xn--gckr3f0f": _2, "クラウド": _2, "xn--gk3at1e": _2, "通販": _2, "xn--hxt814e": _2, "网店": _2, "xn--i1b6b1a6a2e": _2, "संगठन": _2, "xn--imr513n": _2, "餐厅": _2, "xn--io0a7i": _2, "网络": _2, "xn--j1aef": _2, "ком": _2, "xn--jlq480n2rg": _2, "亚马逊": _2, "xn--jvr189m": _2, "食品": _2, "xn--kcrx77d1x4a": _2, "飞利浦": _2, "xn--kput3i": _2, "手机": _2, "xn--mgba3a3ejt": _2, "ارامكو": _2, "xn--mgba7c0bbn0a": _2, "العليان": _2, "xn--mgbaakc7dvf": _2, "اتصالات": _2, "xn--mgbab2bd": _2, "بازار": _2, "xn--mgbca7dzdo": _2, "ابوظبي": _2, "xn--mgbi4ecexp": _2, "كاثوليك": _2, "xn--mgbt3dhd": _2, "همراه": _2, "xn--mk1bu44c": _2, "닷컴": _2, "xn--mxtq1m": _2, "政府": _2, "xn--ngbc5azd": _2, "شبكة": _2, "xn--ngbe9e0a": _2, "بيتك": _2, "xn--ngbrx": _2, "عرب": _2, "xn--nqv7f": _2, "机构": _2, "xn--nqv7fs00ema": _2, "组织机构": _2, "xn--nyqy26a": _2, "健康": _2, "xn--otu796d": _2, "招聘": _2, "xn--p1acf": [1, { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 }], "рус": [1, { "биз": _3, "ком": _3, "крым": _3, "мир": _3, "мск": _3, "орг": _3, "самара": _3, "сочи": _3, "спб": _3, "я": _3 }], "xn--pssy2u": _2, "大拿": _2, "xn--q9jyb4c": _2, "みんな": _2, "xn--qcka1pmc": _2, "グーグル": _2, "xn--rhqv96g": _2, "世界": _2, "xn--rovu88b": _2, "書籍": _2, "xn--ses554g": _2, "网址": _2, "xn--t60b56a": _2, "닷넷": _2, "xn--tckwe": _2, "コム": _2, "xn--tiq49xqyj": _2, "天主教": _2, "xn--unup4y": _2, "游戏": _2, "xn--vermgensberater-ctb": _2, "vermögensberater": _2, "xn--vermgensberatung-pwb": _2, "vermögensberatung": _2, "xn--vhquv": _2, "企业": _2, "xn--vuq861b": _2, "信息": _2, "xn--w4r85el8fhu5dnra": _2, "嘉里大酒店": _2, "xn--w4rs40l": _2, "嘉里": _2, "xn--xhq521b": _2, "广东": _2, "xn--zfr164b": _2, "政务": _2, "xyz": [1, { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 }], "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": [1, { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 }], "zuerich": _2 }];
  return rules2;
}();

// node_modules/tldts/dist/es6/src/suffix-trie.js
function lookupInTrie(parts, trie, index, allowedMask) {
  let result = null;
  let node = trie;
  while (node !== void 0) {
    if ((node[0] & allowedMask) !== 0) {
      result = {
        index: index + 1,
        isIcann: node[0] === 1,
        isPrivate: node[0] === 2
      };
    }
    if (index === -1) {
      break;
    }
    const succ = node[1];
    node = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ["*"];
    index -= 1;
  }
  return result;
}
function suffixLookup(hostname, options, out) {
  var _a4;
  if (fast_path_default(hostname, options, out)) {
    return;
  }
  const hostnameParts = hostname.split(".");
  const allowedMask = (options.allowPrivateDomains ? 2 : 0) | (options.allowIcannDomains ? 1 : 0);
  const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
  if (exceptionMatch !== null) {
    out.isIcann = exceptionMatch.isIcann;
    out.isPrivate = exceptionMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join(".");
    return;
  }
  const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
  if (rulesMatch !== null) {
    out.isIcann = rulesMatch.isIcann;
    out.isPrivate = rulesMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join(".");
    return;
  }
  out.isIcann = false;
  out.isPrivate = false;
  out.publicSuffix = (_a4 = hostnameParts[hostnameParts.length - 1]) !== null && _a4 !== void 0 ? _a4 : null;
}

// node_modules/tldts/dist/es6/index.js
var RESULT = getEmptyResult();
function parse(url, options = {}) {
  return parseImpl(url, 5, suffixLookup, options, getEmptyResult());
}

// node_modules/@dynamic-labs/utils/src/services/PlatformService/createBrowserPlatformService/createBrowserPlatformService.js
var createBrowserPlatformService = (window2) => ({
  getDisplayOrigin: () => window2.location.origin,
  getHost: () => window2.location.host,
  getHostname: () => window2.location.hostname,
  getOrigin: () => window2.location.origin,
  getTLD: () => {
    const data = parse(window2.location.hostname, {
      allowPrivateDomains: true
    });
    return data.domain || void 0;
  },
  isNativeMobile: false,
  openURL: (url) => __awaiter3(void 0, void 0, void 0, function* () {
    window2.location.assign(url);
  })
});

// node_modules/@dynamic-labs/utils/src/services/PlatformService/PlatformService.js
var _a;
var _PlatformService_implementation;
var PlatformService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation)) {
      return createBrowserPlatformService(window);
    }
    return __classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a, _a, implementation, "f", _PlatformService_implementation);
  }
  /**
   * Indicates if the current platform is a native mobile app
   * like react-native or flutter.
   */
  static get isNativeMobile() {
    return _a.implementation.isNativeMobile;
  }
  /**
   * Gets the origin of the current location.
   *
   * @example window.location.origin
   */
  static get getOrigin() {
    return _a.implementation.getOrigin;
  }
  /**
   * Gets the origin to be displayed in the UI.
   *
   * @example window.location.origin
   */
  static get getDisplayOrigin() {
    return _a.implementation.getDisplayOrigin;
  }
  /**
   * Gets the host of the current location.
   *
   * @example window.location.host
   */
  static get getHost() {
    return _a.implementation.getHost;
  }
  /**
   * Gets the hostname of the current location.
   *
   * @example window.location.hostname
   */
  static get getHostname() {
    return _a.implementation.getHostname;
  }
  static get getTLD() {
    return _a.implementation.getTLD;
  }
  /**
   * Opens a URL. If possible, should avoid new windows.
   */
  static get openURL() {
    return _a.implementation.openURL;
  }
};
_a = PlatformService;
_PlatformService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/utils/src/getTLD/getTLD.js
var getTLD = () => PlatformService.getTLD();

// node_modules/@dynamic-labs/utils/src/ceil/ceil.js
var ceil = (value, precision = 0) => {
  const multiplier = Math.pow(10, precision);
  return Math.ceil(value * multiplier) / multiplier;
};

// node_modules/@dynamic-labs/utils/src/trimEnd/trimEnd.js
var trimEnd = (text, char = "") => {
  let endIndex = text.length - 1;
  while (endIndex >= 0 && text[endIndex] === char) {
    endIndex--;
  }
  return text.slice(0, endIndex + 1);
};

// node_modules/@dynamic-labs/utils/src/formatNumberText/formatNumberText.js
var formatNumberText = (value, { precision = 0 } = {}) => {
  if (!precision) {
    return value;
  }
  const floatValue = parseFloat(value);
  const formattedAtPrecision = ceil(floatValue, precision).toFixed(precision);
  const [integerPart, decimalPart] = formattedAtPrecision.split(".");
  const decimalPartTrimmed = trimEnd(decimalPart, "0");
  return `${integerPart}.${decimalPartTrimmed || "0"}`;
};

// node_modules/@dynamic-labs/utils/src/eip6963/eip6963Provider.js
var isEip9693Event = (event) => event.type === "eip6963:announceProvider" && event.detail !== void 0;
var Eip6963Provider = class {
  constructor() {
    this.providers = [];
  }
  registerProviders() {
    if (typeof window === "undefined") {
      return;
    }
    window.addEventListener("eip6963:announceProvider", (event) => {
      if (!isEip9693Event(event)) {
        return;
      }
      this.providers.push(event.detail);
    });
    window.dispatchEvent(new Event("eip6963:requestProvider"));
  }
};
var Eip6963ProviderSingleton = class _Eip6963ProviderSingleton {
  constructor() {
    this.eip6963Provider = new Eip6963Provider();
  }
  static get() {
    var _a4;
    if (!((_a4 = _Eip6963ProviderSingleton.instance) === null || _a4 === void 0 ? void 0 : _a4.eip6963Provider)) {
      _Eip6963ProviderSingleton.instance = new _Eip6963ProviderSingleton();
      _Eip6963ProviderSingleton.instance.eip6963Provider.registerProviders();
    }
    return _Eip6963ProviderSingleton.instance.eip6963Provider;
  }
};

// node_modules/@dynamic-labs/utils/src/runSafe/runSafe.js
var runSafe = (callback) => __awaiter3(void 0, void 0, void 0, function* () {
  try {
    const resolved = yield callback();
    return [resolved, void 0];
  } catch (error) {
    return [void 0, error];
  }
});

// node_modules/@dynamic-labs/utils/src/services/FetchService/FetchService.js
var _a2;
var _FetchService_implementation;
var FetchService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a2, _a2, "f", _FetchService_implementation)) {
      return { fetch: window.fetch.bind(window) };
    }
    return __classPrivateFieldGet(_a2, _a2, "f", _FetchService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a2, _a2, implementation, "f", _FetchService_implementation);
  }
  static get fetch() {
    return _a2.implementation.fetch;
  }
};
_a2 = FetchService;
_FetchService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/types/src/oauth/index.js
var SocialOAuthErrorCode;
(function(SocialOAuthErrorCode2) {
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED"] = "account_already_linked";
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE"] = "account_already_linked_to_different_profile";
  SocialOAuthErrorCode2["INVALID_PROVIDER"] = "invalid_provider";
  SocialOAuthErrorCode2["NO_ACCOUNT_LINKED"] = "no_account_linked";
  SocialOAuthErrorCode2["NO_AUTH_CODE"] = "no_auth_code";
  SocialOAuthErrorCode2["NO_OAUTH_URL"] = "no_oauth_url";
  SocialOAuthErrorCode2["NO_PROVIDER"] = "no_provider";
  SocialOAuthErrorCode2["OAUTH_ERROR"] = "oauth_error";
  SocialOAuthErrorCode2["OAUTH_WINDOW_BLOCKED"] = "oauth_window_blocked";
  SocialOAuthErrorCode2["OAUTH_WINDOW_CLOSED"] = "oauth_window_closed";
  SocialOAuthErrorCode2["OAUTH_WINDOW_TIMEOUT"] = "oauth_window_timeout";
  SocialOAuthErrorCode2["PROVIDER_NOT_ENABLED"] = "provider_not_enabled";
  SocialOAuthErrorCode2["SESSION_TIMEOUT"] = "session_timeout";
  SocialOAuthErrorCode2["SIGNIN_ERROR"] = "signin_error";
  SocialOAuthErrorCode2["SOCIAL_LINKING_NOT_ENABLED"] = "social_linking_not_enabled";
  SocialOAuthErrorCode2["UNLINK_ERROR"] = "unlink_error";
  SocialOAuthErrorCode2["VERIFICATION_ERROR"] = "verification_error";
  SocialOAuthErrorCode2["GENERAL_ERROR"] = "general_error";
})(SocialOAuthErrorCode || (SocialOAuthErrorCode = {}));

// node_modules/@dynamic-labs/types/src/wallets/BaseWallet.js
var BaseWallet = class {
  constructor({ id, key, address, additionalAddresses = [], chain, isAuthenticated }) {
    this.id = id;
    this.key = key;
    this.address = address;
    this.additionalAddresses = additionalAddresses;
    this.chain = chain;
    this.isAuthenticated = isAuthenticated;
  }
};

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/loadAppleId/loadAppleId.js
var appleIdScriptSrc = "https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js";
var loadAppleId = () => new Promise((resolve, reject) => {
  const script = document.querySelector("script[data-apple-sdk]");
  if (script) {
    if (script.hasAttribute("data-loaded")) {
      resolve();
    } else {
      script.addEventListener("load", () => resolve());
      script.addEventListener("error", () => reject(new Error("Failed to load Apple SDK")));
    }
  } else {
    const script2 = document.createElement("script");
    script2.type = "text/javascript";
    script2.src = appleIdScriptSrc;
    script2.setAttribute("data-apple-sdk", "true");
    script2.onload = () => {
      script2 === null || script2 === void 0 ? void 0 : script2.setAttribute("data-loaded", "true");
      resolve();
    };
    script2.onerror = () => reject(new Error("Failed to load Apple SDK"));
    window.document.head.appendChild(script2);
  }
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/connectWithAppleId/connectWithAppleId.js
var connectWithAppleId = (_a4) => __awaiter3(void 0, [_a4], void 0, function* ({ clientId, oauthLoginUrl, state }) {
  yield loadAppleId();
  AppleID.auth.init({
    clientId,
    redirectURI: oauthLoginUrl.searchParams.get("redirect_uri"),
    scope: "name email",
    state,
    usePopup: false
  });
  AppleID.auth.signIn();
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/createWindowOauth2Service/createWindowOauth2Service.js
var authWindowInterval;
var createWindowOauth2Service = () => ({
  getOauthCode: ({ apiProvider, provider, redirectUrl, setIsProcessing, state, oauthLoginUrl, initWebAuth, strategy }) => new Promise((resolve, _reject) => {
    if (provider === ProviderEnum.Apple && (isSafariBrowser() || isIOS() || strategy === "redirect")) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => connectWithAppleId({
        clientId: apiProvider === null || apiProvider === void 0 ? void 0 : apiProvider.clientId,
        oauthLoginUrl,
        state
      }).catch(_reject));
      return;
    }
    if (strategy === "redirect" && provider !== ProviderEnum.Telegram) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => {
        window.location.assign(oauthLoginUrl);
      });
      return;
    }
    const typedReject = (params) => _reject(params);
    clearInterval(authWindowInterval);
    const providersWaitingOauthMessage = {};
    const authWindow = window.open("", "_blank", "width=500,height=600");
    const clearListeners = () => {
      window.removeEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = false;
    };
    const handleWindowMessage = (event) => __awaiter3(void 0, void 0, void 0, function* () {
      const message = event.data;
      const expectedOrigin = getExpectedOrigin(apiProvider);
      if (!expectedOrigin) {
        return;
      }
      if ((message === null || message === void 0 ? void 0 : message.type) === "origin_check" && authWindow) {
        logger.debug("Origin check message received. Sending response now.", {
          data: message,
          expectedOrigin
        });
        authWindow.postMessage("origin_check_response", expectedOrigin);
        return;
      }
      const isTelegramCompletedMessage = (message === null || message === void 0 ? void 0 : message.type) === "telegram_completed";
      const isAuthorizationMessage = (message === null || message === void 0 ? void 0 : message.type) === "authorization_response";
      if (isAuthorizationMessage || isTelegramCompletedMessage) {
        logger.debug("Message received", { data: message });
      }
      const isExpectedOrigin = event.origin === expectedOrigin;
      const isValidMessage = (isAuthorizationMessage && (message === null || message === void 0 ? void 0 : message.provider) === provider || isTelegramCompletedMessage) && isExpectedOrigin;
      if (!isValidMessage) {
        return;
      }
      setIsProcessing(true);
      if (!providersWaitingOauthMessage[provider]) {
        typedReject({
          code: SocialOAuthErrorCode.SESSION_TIMEOUT,
          message: `Connecting ${provider} account session timeout.`
        });
        return;
      }
      clearListeners();
      if (isTelegramCompletedMessage) {
        handleTelegramCompletionMessage(message, state);
        return;
      }
      handleAuthorizationMessage(message, provider, state);
    });
    const getExpectedOrigin = (apiProvider2) => {
      if (!(apiProvider2 === null || apiProvider2 === void 0 ? void 0 : apiProvider2.redirectUrl)) {
        return;
      }
      try {
        const redirectUri = new URL(apiProvider2.redirectUrl);
        return redirectUri.origin;
      } catch (e) {
        logger.error("Failed to parse social provider redirect url", {
          error: e
        });
        return;
      }
    };
    const handleTelegramCompletionMessage = (message, state2) => {
      logger.debug("Telegram completion message received", {
        data: message
      });
      const { code, state: authState } = message;
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: "Failed to connect telegram account: Invalid random state"
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    const handleAuthorizationMessage = (message, provider2, state2) => {
      const { code, error, state: authState } = message;
      if (error && error !== "undefined") {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: ${error}`
        });
        return;
      }
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: Invalid random state`
        });
        return;
      }
      if (!code) {
        typedReject({
          code: SocialOAuthErrorCode.NO_AUTH_CODE,
          message: `Failed to connect ${provider2} social account: no authorization code`
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    if (!providersWaitingOauthMessage[provider]) {
      window.addEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = true;
    }
    initWebAuth().then(() => {
      authWindow === null || authWindow === void 0 ? void 0 : authWindow.location.assign(oauthLoginUrl);
      authWindowInterval = setInterval(() => {
        if (!(authWindow === null || authWindow === void 0 ? void 0 : authWindow.closed))
          return;
        clearInterval(authWindowInterval);
        setIsProcessing(false);
        if (providersWaitingOauthMessage[provider])
          typedReject("user-cancelled");
      }, 2e3);
    });
  })
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/Oauth2Service.js
var _a3;
var _Oauth2Service_implementation;
var Oauth2Service = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a3, _a3, "f", _Oauth2Service_implementation)) {
      return createWindowOauth2Service();
    }
    return __classPrivateFieldGet(_a3, _a3, "f", _Oauth2Service_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a3, _a3, implementation, "f", _Oauth2Service_implementation);
  }
  static get getOauthCode() {
    return _a3.implementation.getOauthCode;
  }
};
_a3 = Oauth2Service;
_Oauth2Service_implementation = { value: void 0 };
Oauth2Service.isGetOauthCodeError = (error) => error === "user-cancelled" || typeof error === "object" && "code" in error && Object.values(SocialOAuthErrorCode).includes(error.code) && "message" in error && typeof error.message === "string";

// node_modules/@dynamic-labs/utils/src/hexToString/hexToString.js
var hexToString = (hexString) => {
  const normalizedHexString = hexString.startsWith("0x") ? hexString.substring(2) : hexString;
  let text = "";
  const length = normalizedHexString.length - normalizedHexString.length % 2;
  for (let i = 0; i < length; i += 2) {
    const hexCode = normalizedHexString.substring(i, i + 2);
    const decimal = parseInt(hexCode, 16);
    text += String.fromCharCode(decimal);
  }
  return text;
};

// node_modules/@dynamic-labs/utils/src/isHex/isHex.js
var isHex = (str) => {
  if (typeof str !== "string") {
    throw new Error("Input must be a string");
  }
  const normalizedStr = str.startsWith("0x") ? str.substring(2) : str;
  const regex = /^[0-9a-fA-F]+$/;
  return regex.test(normalizedStr);
};

// node_modules/@dynamic-labs/utils/src/services/StorageService/StorageService.js
var StorageService = class _StorageService {
  static clearRegistry() {
    _StorageService.registry = {
      localStorage: void 0,
      secureStorage: void 0,
      sessionStorage: void 0
    };
  }
  static registerSourceStorage(source, implementation) {
    _StorageService.registry[source] = implementation;
  }
  static getSourceStorage(source) {
    return _StorageService.registry[source];
  }
  static resolveStorage(options) {
    const priority = (options === null || options === void 0 ? void 0 : options.priority) || ["localStorage"];
    for (const source of priority) {
      const storage = _StorageService.getSourceStorage(source);
      if (storage) {
        return storage;
      }
    }
    throw new Error("No available storage found based on the specified priority");
  }
  static getItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    return storage.getItem(key);
  }
  static setItem(key, value, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.setItem(key, value);
  }
  static removeItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.removeItem(key);
  }
  static getKeys(options) {
    return _StorageService.resolveStorage(options).getKeys();
  }
};
StorageService.registry = {
  localStorage: void 0,
  secureStorage: void 0,
  sessionStorage: void 0
};
StorageService.events = new eventemitter3_default();

// node_modules/@dynamic-labs/utils/src/services/StorageService/createStorageService/createStorageService.js
var createStorageService = ({ postfix, storage }) => {
  const getKey = (key) => postfix ? `${key}_${postfix}` : key;
  const packValue = (value) => JSON.stringify(value);
  const unpackValue = (value) => JSON.parse(value);
  const getItem = (key) => {
    const value = storage.getItem(getKey(key));
    if (!value) {
      return void 0;
    }
    try {
      return unpackValue(value);
    } catch (error) {
      logger.error(`Error while parsing ${key} from local storage`, {
        value
      });
      removeItem(key);
      StorageService.events.emit("parseFailure", error, key);
    }
    return void 0;
  };
  const setItem = (key, value) => {
    storage.setItem(getKey(key), packValue(value));
  };
  const removeItem = (key) => {
    storage.removeItem(getKey(key));
  };
  const getKeys = () => Object.keys(storage);
  return {
    getItem,
    getKeys,
    removeItem,
    setItem
  };
};

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var import_react = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/helpers/getIconicSpriteUrl.js
var DEFAULT_ICONIC_SPRITE_URL = "https://iconic.dynamic-static-assets.com/icons/sprite.svg";
var getIconicSpriteUrl = () => {
  var _a4, _b, _c;
  if (typeof process !== "undefined" && process.env) {
    return (_c = (_b = (_a4 = process.env["ICONIC_SPRITE_CDN_URL"]) !== null && _a4 !== void 0 ? _a4 : process.env["NEXT_PUBLIC_ICONIC_SPRITE_CDN_URL"]) !== null && _b !== void 0 ? _b : process.env["REACT_APP_ICONIC_SPRITE_CDN_URLL"]) !== null && _c !== void 0 ? _c : DEFAULT_ICONIC_SPRITE_URL;
  }
  return DEFAULT_ICONIC_SPRITE_URL;
};

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var ICONIC_SPRITE_URL = getIconicSpriteUrl();
var createIconic = (props) => {
  const Icon = Object.assign(Object.assign({}, props), { function: (props2) => {
    const url = `${ICONIC_SPRITE_URL}#${Icon.iconName}`;
    return (0, import_react.createElement)("img", Object.assign(Object.assign({ "data-testid": `iconic-${Icon.iconName}` }, props2), { alt: Icon.alt, src: url }));
  } });
  const IconicComponent = Icon.function.bind(Icon);
  Object.assign(IconicComponent, {
    iconName: Icon.iconName,
    sourcePath: Icon.sourcePath
  });
  return IconicComponent;
};

// node_modules/@dynamic-labs/iconic/src/icons/browsers/index.js
var BraveIcon = createIconic({
  alt: "Brave Browser",
  iconName: "brave",
  sourcePath: "icons/browsers/brave.svg"
});
var ChromeIcon = createIconic({
  alt: "Chrome Browser",
  iconName: "chrome",
  sourcePath: "icons/browsers/chrome.svg"
});
var EdgeIcon = createIconic({
  alt: "Edge Browser",
  iconName: "edge",
  sourcePath: "icons/browsers/edge.svg"
});
var FirefoxIcon = createIconic({
  alt: "Firefox Browser",
  iconName: "firefox",
  sourcePath: "icons/browsers/firefox.svg"
});
var OperaIcon = createIconic({
  alt: "Opera Browser",
  iconName: "opera",
  sourcePath: "icons/browsers/opera.svg"
});
var SafariIcon = createIconic({
  alt: "Opera Browser",
  iconName: "safari",
  sourcePath: "icons/browsers/safari.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/chains/index.js
var AlgorandIcon = createIconic({
  alt: "Algorand Chain",
  iconName: "algorand",
  sourcePath: "icons/chains/algorand.svg"
});
var ArbitrumIcon = createIconic({
  alt: "Arbitrum Chain",
  iconName: "arbitrum",
  sourcePath: "icons/chains/arbitrum.svg"
});
var AuroraIcon = createIconic({
  alt: "Aurora Chain",
  iconName: "aurora",
  sourcePath: "icons/chains/aurora.svg"
});
var BaseChainIcon = createIconic({
  alt: "Base Chain",
  iconName: "base",
  sourcePath: "icons/chains/base.svg"
});
var BerachainIcon = createIconic({
  alt: "Berachain Chain",
  iconName: "berachain",
  sourcePath: "icons/chains/berachain.svg"
});
var BitcoinIcon = createIconic({
  alt: "Bitcoin Chain",
  iconName: "bitcoin",
  sourcePath: "icons/chains/bitcoin.svg"
});
var BnbIcon = createIconic({
  alt: "BNB Chain",
  iconName: "bnb",
  sourcePath: "icons/chains/bnb.svg"
});
var CosmosIcon = createIconic({
  alt: "Cosmos Chain",
  iconName: "cosmos",
  sourcePath: "icons/chains/cosmos.svg"
});
var OsmosisIcon = createIconic({
  alt: "Osmosis Chain",
  iconName: "osmosis",
  sourcePath: "icons/chains/osmosis.svg"
});
var AxelarIcon = createIconic({
  alt: "Axelar Chain",
  iconName: "axelar",
  sourcePath: "icons/chains/axelar.svg"
});
var EthereumIcon = createIconic({
  alt: "Ethereum Chain",
  iconName: "ethereum",
  sourcePath: "icons/chains/ethereum.svg"
});
var GoerliIcon = createIconic({
  alt: "Goerli Chain",
  iconName: "goerli",
  sourcePath: "icons/chains/goerli.svg"
});
var ZkSyncIcon = createIconic({
  alt: "zkSync Era Chain",
  iconName: "zkSync",
  sourcePath: "icons/chains/zkSync.svg"
});
var FlowIcon = createIconic({
  alt: "Flow Chain",
  iconName: "flow",
  sourcePath: "icons/chains/flow.svg"
});
var GnosisIcon = createIconic({
  alt: "Gnosis Chain",
  iconName: "gnosis",
  sourcePath: "icons/chains/gnosis.svg"
});
var OptimismIcon = createIconic({
  alt: "Optimism Chain",
  iconName: "optimism",
  sourcePath: "icons/chains/optimism.svg"
});
var PalmIcon = createIconic({
  alt: "Palm Chain",
  iconName: "palm",
  sourcePath: "icons/chains/palm.svg"
});
var PolygonIcon = createIconic({
  alt: "Polygon Chain",
  iconName: "polygon",
  sourcePath: "icons/chains/polygon.svg"
});
var SolanaIcon = createIconic({
  alt: "Solana Chain",
  iconName: "solana",
  sourcePath: "icons/chains/solana.svg"
});
var StarknetIcon = createIconic({
  alt: "Starknet Chain",
  iconName: "starknet",
  sourcePath: "icons/chains/starknet.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/wallets/index.js
var OneInchIcon = createIconic({
  alt: "1inch Wallet",
  iconName: "1inch.svg",
  sourcePath: "icons/wallets/1inch.svg"
});
var ArgentXIcon = createIconic({
  alt: "Argent X Wallet",
  iconName: "argentx",
  sourcePath: "icons/wallets/argentx.svg"
});
var ArgentMobile = createIconic({
  alt: "Argent Mobile",
  iconName: "argentmobile",
  sourcePath: "icons/wallets/argent-mobile.svg"
});
var ArgentWebWallet = createIconic({
  alt: "Argent Web Wallet",
  iconName: "argentwebwallet",
  sourcePath: "icons/wallets/argent-web-wallet.svg"
});
var BackpackIcon = createIconic({
  alt: "Backpack Wallet",
  iconName: "backpack",
  sourcePath: "icons/wallets/backpack.svg"
});
var BinanceIcon = createIconic({
  alt: "Binance Wallet",
  iconName: "binance.svg",
  sourcePath: "icons/wallets/binance.svg"
});
var BitPayIcon = createIconic({
  alt: "BitPay Wallet",
  iconName: "bitpay.svg",
  sourcePath: "icons/wallets/bitpay.svg"
});
var BloctoIcon = createIconic({
  alt: "Blocto Wallet",
  iconName: "blocto",
  sourcePath: "icons/wallets/blocto.svg"
});
var BraavosIcon = createIconic({
  alt: "Braavos Wallet",
  iconName: "braavos",
  sourcePath: "icons/wallets/braavos.svg"
});
var Coin98Icon = createIconic({
  alt: "Coin98 Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CoinbaseIcon = createIconic({
  alt: "Coinbase Wallet",
  iconName: "coinbase",
  sourcePath: "icons/wallets/coinbase.svg"
});
var CryptoIcon = createIconic({
  alt: "Crypto Wallet",
  iconName: "crypto.svg",
  sourcePath: "icons/wallets/crypto.svg"
});
var DapperIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "dapper",
  sourcePath: "icons/wallets/dapper.svg"
});
var DawnIcon = createIconic({
  alt: "Dawn Wallet",
  iconName: "dawn",
  sourcePath: "icons/wallets/dawn.svg"
});
var DefaultIcon = createIconic({
  alt: "Default Wallet",
  iconName: "defaultwallet",
  sourcePath: "icons/wallets/default.svg"
});
var EmailSignIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "emailsign.svg",
  sourcePath: "icons/wallets/emailsign.svg"
});
var SignInWithEmailIcon = createIconic({
  alt: "Sign in with Email",
  iconName: "signinwithemail",
  sourcePath: "icons/wallets/signinwithemail.svg"
});
var ExodusIcon = createIconic({
  alt: "Exodus Wallet",
  iconName: "exodus",
  sourcePath: "icons/wallets/exodus.svg"
});
var FireblocksIcon = createIconic({
  alt: "Fireblocks Wallet",
  iconName: "fireblocks.svg",
  sourcePath: "icons/wallets/fireblocks.svg"
});
var FortmaticIcon = createIconic({
  alt: "Fortmatic Wallet",
  iconName: "fortmatic",
  sourcePath: "icons/wallets/fortmatic.svg"
});
var FrameIcon = createIconic({
  alt: "Frame Wallet",
  iconName: "frame",
  sourcePath: "icons/wallets/frame.svg"
});
var GamestopIcon = createIconic({
  alt: "Gamestop Wallet",
  iconName: "gamestop",
  sourcePath: "icons/wallets/gamestop.svg"
});
var GlowIcon = createIconic({
  alt: "Glow Wallet",
  iconName: "glow",
  sourcePath: "icons/wallets/glow.svg"
});
var ImTokenWallet = createIconic({
  alt: "ImToken Wallet",
  iconName: "imtoken.svg",
  sourcePath: "icons/wallets/imtoken.svg"
});
var InjectedWalletIcon = createIconic({
  alt: "Injected Wallet",
  iconName: "injectedwallet",
  sourcePath: "icons/wallets/injectedwallet.svg"
});
var KeplrIcon = createIconic({
  alt: "Keplr Wallet",
  iconName: "keplr",
  sourcePath: "icons/wallets/keplr.svg"
});
var LedgerIcon = createIconic({
  alt: "Ledger Wallet",
  iconName: "ledger",
  sourcePath: "icons/wallets/ledger.svg"
});
var LilicoIcon = createIconic({
  alt: "Lilico Wallet",
  iconName: "lilico",
  sourcePath: "icons/wallets/lilico.svg"
});
var LinenIcon = createIconic({
  alt: "Linen Wallet",
  iconName: "linen.svg",
  sourcePath: "icons/wallets/linen.svg"
});
var MaticIcon = createIconic({
  alt: "Matic Wallet",
  iconName: "matic",
  sourcePath: "icons/wallets/matic.svg"
});
var MetaMaskIcon = createIconic({
  alt: "MetaMask Wallet",
  iconName: "metamask",
  sourcePath: "icons/wallets/metamask.svg"
});
var MissingIcon = createIconic({
  alt: "Missing Wallet",
  iconName: "missing",
  sourcePath: "icons/wallets/missing.svg"
});
var MyalgoIcon = createIconic({
  alt: "MyAlgo Wallet",
  iconName: "myalgo",
  sourcePath: "icons/wallets/myalgo.svg"
});
var OmniIcon = createIconic({
  alt: "Omni Wallet",
  iconName: "omni",
  sourcePath: "icons/wallets/omni.svg"
});
var OpeanSeaIcon = createIconic({
  alt: "OpeanSea Wallet",
  iconName: "opeansea",
  sourcePath: "icons/wallets/opensea.svg"
});
var PeraIcon = createIconic({
  alt: "Pera Wallet",
  iconName: "pera",
  sourcePath: "icons/wallets/pera.svg"
});
var PhantomIcon = createIconic({
  alt: "Phantom Wallet",
  iconName: "phantom",
  sourcePath: "icons/wallets/phantom.svg"
});
var RabbyIcon = createIconic({
  alt: "Rabby Wallet",
  iconName: "rabby",
  sourcePath: "icons/wallets/rabby.svg"
});
var RainbowIcon = createIconic({
  alt: "Rainbow Wallet",
  iconName: "rainbow",
  sourcePath: "icons/wallets/rainbow.svg"
});
var SafeIcon = createIconic({
  alt: "Safe Wallet",
  iconName: "safe",
  sourcePath: "icons/wallets/safe.svg"
});
var SequenceIcon = createIconic({
  alt: "Sequence Wallet",
  iconName: "sequence",
  sourcePath: "icons/wallets/sequence.svg"
});
var SolflareIcon = createIconic({
  alt: "Solflare Wallet",
  iconName: "solflare",
  sourcePath: "icons/wallets/solflare.svg"
});
var SpotIcon = createIconic({
  alt: "Spot Wallet",
  iconName: "spot",
  sourcePath: "icons/wallets/spot.svg"
});
var StrokeIcon = createIconic({
  alt: "Stroke Wallet",
  iconName: "stroke",
  sourcePath: "icons/wallets/stroke.svg"
});
var TallyCashIcon = createIconic({
  alt: "Taho Wallet",
  iconName: "tallycash",
  sourcePath: "icons/wallets/tallycash.svg"
});
var TerraIcon = createIconic({
  alt: "Terra Wallet",
  iconName: "terra",
  sourcePath: "icons/wallets/terra.svg"
});
var TorusIcon = createIconic({
  alt: "Torus Wallet",
  iconName: "torus",
  sourcePath: "icons/wallets/torus.svg"
});
var TrustIcon = createIconic({
  alt: "Trust Wallet",
  iconName: "trust",
  sourcePath: "icons/wallets/trust.svg"
});
var UnstoppableIcon = createIconic({
  alt: "Unstoppable Wallet",
  iconName: "unstoppable",
  sourcePath: "icons/wallets/unstoppable.svg"
});
var VenlyIcon = createIconic({
  alt: "Venly Wallet",
  iconName: "venly",
  sourcePath: "icons/wallets/venly.svg"
});
var WalletConnectIcon = createIconic({
  alt: "Wallet Connect Wallet",
  iconName: "walletconnect",
  sourcePath: "icons/wallets/walletconnect.svg"
});
var MagicLinkIcon = createIconic({
  alt: "Magic Link Wallet",
  iconName: "magiclink",
  sourcePath: "icons/wallets/magic-link.svg"
});
var TurnkeyIcon = createIconic({
  alt: "Turnkey",
  iconName: "turnkey",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var ZengoIcon = createIconic({
  alt: "Zengo Wallet",
  iconName: "zengo",
  sourcePath: "icons/wallets/zengo.svg"
});
var SuperbIcon = createIconic({
  alt: "Superb Wallet",
  iconName: "superb",
  sourcePath: "icons/wallets/superb.svg"
});
var ZeroDevIcon = createIconic({
  alt: "ZeroDev",
  iconName: "zerodev",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var SmartWalletIcon = createIconic({
  alt: "Smart Wallet",
  iconName: "smartwallet",
  sourcePath: "icons/wallets/smart-wallet.svg"
});
var MagicEdenIcon = createIconic({
  alt: "Magic Eden",
  iconName: "magiceden",
  sourcePath: "icons/wallets/magiceden.svg"
});
var XverseEdenIcon = createIconic({
  alt: "Xverse",
  iconName: "xverse",
  sourcePath: "icons/wallets/xverse.svg"
});
var UnisatIcon = createIconic({
  alt: "Unisat",
  iconName: "unisat",
  sourcePath: "icons/wallets/unisat.svg"
});
var LeatherIcon = createIconic({
  alt: "Leather",
  iconName: "leather",
  sourcePath: "icons/wallets/leather.svg"
});
var OkxIcon = createIconic({
  alt: "OKX",
  iconName: "okx",
  sourcePath: "icons/wallets/okx.svg"
});
var CoinbaseWaaSIcon = createIconic({
  alt: "Coinbase WaaS",
  iconName: "coinbasewaas",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var MetaMaskStarknetIcon = createIconic({
  alt: "MetaMask Starknet Snap",
  iconName: "metamaskstarknetsnap",
  sourcePath: "icons/wallets/metamask-starknet.svg"
});
var NightlyIcon = createIconic({
  alt: "Nightly",
  iconName: "nightly",
  sourcePath: "icons/wallets/nightly.svg"
});
var OneKeyIcon = createIconic({
  alt: "OneKey",
  iconName: "onekey",
  sourcePath: "icons/wallets/onekey.svg"
});
var AmbireIcon = createIconic({
  alt: "Ambire",
  iconName: "ambire",
  sourcePath: "icons/wallets/ambire.svg"
});
var BitGetWalletIcon = createIconic({
  alt: "Bitget Wallet",
  iconName: "bitgetwallet",
  sourcePath: "icons/wallets/bitgetwallet.svg"
});
var MathWalletIcon = createIconic({
  alt: "Math Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CloverWalletIcon = createIconic({
  alt: "Clover Wallet",
  iconName: "clover",
  sourcePath: "icons/wallets/clover.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/mobile/index.js
var AppleIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/mobile/apple.svg"
});
var AndroidIcon = createIconic({
  alt: "Android",
  iconName: "android",
  sourcePath: "icons/mobile/android.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/social/index.js
var social_exports = {};
__export(social_exports, {
  AppleDarkSocialIcon: () => AppleDarkSocialIcon,
  AppleSocialIcon: () => AppleSocialIcon,
  BitbucketIcon: () => BitbucketIcon,
  CoinbaseSocialDarkIcon: () => CoinbaseSocialDarkIcon,
  CoinbaseSocialIcon: () => CoinbaseSocialIcon,
  DiscordIcon: () => DiscordIcon,
  FacebookIcon: () => FacebookIcon,
  FarcasterIcon: () => FarcasterIcon,
  GithubDarkIcon: () => GithubDarkIcon,
  GithubIcon: () => GithubIcon,
  GitlabIcon: () => GitlabIcon,
  GoogleIcon: () => GoogleIcon,
  HelpdeskIcon: () => HelpdeskIcon,
  InstagramIcon: () => InstagramIcon,
  LinkedinIcon: () => LinkedinIcon,
  MicrosoftIcon: () => MicrosoftIcon,
  OnePasswordDarkIcon: () => OnePasswordDarkIcon,
  OnePasswordIcon: () => OnePasswordIcon,
  SlackIcon: () => SlackIcon,
  TelegramIcon: () => TelegramIcon,
  TwitchDarkIcon: () => TwitchDarkIcon,
  TwitchIcon: () => TwitchIcon,
  TwitterDarkIcon: () => TwitterDarkIcon,
  TwitterIcon: () => TwitterIcon,
  YouTubeIcon: () => YouTubeIcon
});
var BitbucketIcon = createIconic({
  alt: "Bitbucket",
  iconName: "bitbucket",
  sourcePath: "icons/social/bitbucket.svg"
});
var DiscordIcon = createIconic({
  alt: "Discord",
  iconName: "discord",
  sourcePath: "icons/social/discord.svg"
});
var FacebookIcon = createIconic({
  alt: "Facebook",
  iconName: "facebook",
  sourcePath: "icons/social/facebook.svg"
});
var FarcasterIcon = createIconic({
  alt: "Farcaster",
  iconName: "farcaster",
  sourcePath: "icons/social/farcaster.svg"
});
var GithubIcon = createIconic({
  alt: "Github",
  iconName: "github",
  sourcePath: "icons/social/github.svg"
});
var GithubDarkIcon = createIconic({
  alt: "Github",
  iconName: "github-dark",
  sourcePath: "icons/social/github-dark.svg"
});
var GitlabIcon = createIconic({
  alt: "Gitlab",
  iconName: "gitlab",
  sourcePath: "icons/social/gitlab.svg"
});
var GoogleIcon = createIconic({
  alt: "Google",
  iconName: "google",
  sourcePath: "icons/social/google.svg"
});
var HelpdeskIcon = createIconic({
  alt: "Helpdesk",
  iconName: "helpdesk",
  sourcePath: "icons/social/helpdesk.svg"
});
var LinkedinIcon = createIconic({
  alt: "Linkedin",
  iconName: "linkedin",
  sourcePath: "icons/social/linkedin.svg"
});
var MicrosoftIcon = createIconic({
  alt: "Microsoft",
  iconName: "microsoft",
  sourcePath: "icons/social/microsoft.svg"
});
var SlackIcon = createIconic({
  alt: "Slack",
  iconName: "slack",
  sourcePath: "icons/social/slack.svg"
});
var TelegramIcon = createIconic({
  alt: "Telegram",
  iconName: "telegram",
  sourcePath: "icons/social/telegram.svg"
});
var TwitchIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch",
  sourcePath: "icons/social/twitch.svg"
});
var TwitchDarkIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch-dark",
  sourcePath: "icons/social/twitch-dark.svg"
});
var TwitterIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter",
  sourcePath: "icons/social/twitter.svg"
});
var TwitterDarkIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter-dark",
  sourcePath: "icons/social/twitter-dark.svg"
});
var AppleSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/social/apple.svg"
});
var AppleDarkSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple-dark",
  sourcePath: "icons/social/apple-dark.svg"
});
var CoinbaseSocialIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial",
  sourcePath: "icons/social/coinbasesocial.svg"
});
var CoinbaseSocialDarkIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial-dark",
  sourcePath: "icons/social/coinbasesocial-dark.svg"
});
var InstagramIcon = createIconic({
  alt: "Instagram",
  iconName: "instagram",
  sourcePath: "icons/social/instagram.svg"
});
var YouTubeIcon = createIconic({
  alt: "YouTube",
  iconName: "youtube",
  sourcePath: "icons/social/youtube.svg"
});
var OnePasswordIcon = createIconic({
  alt: "onePassword",
  iconName: "one-password",
  sourcePath: "icons/social/onePassword.svg"
});
var OnePasswordDarkIcon = createIconic({
  alt: "onePassword-dark",
  iconName: "one-password-dark",
  sourcePath: "icons/social/onePassword-dark.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/misc/index.js
var CaptchaWaveIcon = createIconic({
  alt: "Captcha Wave",
  iconName: "captcha-wave",
  sourcePath: "icons/misc/captcha-wave.svg"
});
var UserProfileIcon = createIconic({
  alt: "User Profile",
  iconName: "user-profile",
  sourcePath: "icons/misc/user-profile.svg"
});
var ArrowSendIcon = createIconic({
  alt: "Arrow Send",
  iconName: "arrow-send",
  sourcePath: "icons/misc/arrow-send.svg"
});

// node_modules/@dynamic-labs/iconic/_virtual/_tslib.js
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/logger.js
var logger2 = new Logger("iconic");

// node_modules/@dynamic-labs/iconic/src/components/getSocialIcon.js
var getSocialIcon = (name, variant = "light") => {
  const map = Object.fromEntries(Object.values(social_exports).map((icon2) => [icon2.iconName, icon2]));
  if (variant === "dark") {
    const darkIcon = map[`${name.toLowerCase()}-dark`];
    if (darkIcon)
      return darkIcon;
  }
  const icon = map[name.toLowerCase()];
  if (icon)
    return icon;
  throw new Error(`Icon ${name}, not found`);
};

// node_modules/@dynamic-labs/iconic/src/components/findSocialIcon.js
var findSocialIcon = (name, variant = "light") => {
  try {
    return getSocialIcon(name, variant);
  } catch (e) {
    logger2.error(e);
    return null;
  }
};

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var SocialIcon = (_a4) => {
  var { name, variant } = _a4, props = __rest(_a4, ["name", "variant"]);
  const Icon = findSocialIcon(name, variant);
  if (!Icon)
    return null;
  return (0, import_react2.createElement)(Icon, props, null);
};

// node_modules/@dynamic-labs/wallet-book/src/context/WalletBookContext.js
var import_react3 = __toESM(require_react(), 1);
var WalletBookContext = (0, import_react3.createContext)(void 0);
var useWalletBookContext = () => {
  const context = (0, import_react3.useContext)(WalletBookContext);
  if (context === void 0) {
    throw new Error("useWalletBookContext must be used within a WalletBookContextProvider");
  }
  return context;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookWallet.js
var getWalletBookWallet = (walletBook, walletKey, walletFallback) => {
  var _a4, _b, _c;
  if (!walletKey)
    throw new Error("Wallet key is required. Please pass in a wallet key to getWalletBookWallet");
  const walletData = (_b = (_a4 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) === null || _a4 === void 0 ? void 0 : _a4[walletKey]) !== null && _b !== void 0 ? _b : walletFallback;
  if (!walletData) {
    throw new Error(`Wallet ${walletKey} not found in wallet book (${Object.keys((_c = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _c !== void 0 ? _c : {}).length} wallets found)`);
  }
  return walletData;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/renderTemplate.js
var TEMPLATES = {
  androidUrl: "https://play.google.com/store/apps/details?id={{id}}",
  chromeUrl: "https://chrome.google.com/webstore/detail/{{id}}",
  edgeUrl: "https://microsoftedge.microsoft.com/addons/detail/{{id}}",
  firefoxUrl: "https://addons.mozilla.org/en-US/firefox/addon/{{id}}",
  iconicUrl: `${getIconicSpriteUrl()}#{{id}}`,
  iosUrl: "https://apps.apple.com/app/apple-store/{{id}}",
  walletConnectUrl: "https://registry.walletconnect.org/v2/logo/sm/{{id}}"
};
var renderTemplate = (templateName, data) => {
  if (!data)
    return void 0;
  return TEMPLATES[templateName].replace("{{id}}", data);
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getBrandIconUrl.js
var getBrandIconUrl = (brand) => {
  if (brand.spriteId) {
    return renderTemplate("iconicUrl", brand.spriteId);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/logger.js
var logger3 = new Logger("WalletBook");

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletIconUrl.js
var getWalletIconUrl = (walletBook, walletKey) => {
  try {
    const walletData = getWalletBookWallet(walletBook, walletKey);
    if (walletData === null || walletData === void 0 ? void 0 : walletData.brand) {
      return getBrandIconUrl(walletData.brand);
    }
  } catch (err) {
    logger3.error(err);
  }
  return "";
};
var getDefaultWalletIconUrl = () => {
  try {
    return renderTemplate("iconicUrl", "defaultwallet");
  } catch (err) {
    logger3.error(err);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletBookWallet.js
var findWalletBookWallet = (walletBook, walletKey) => {
  try {
    const walletData = getWalletBookWallet(walletBook, walletKey);
    return walletData;
  } catch (err) {
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletLinks.js
var getWalletLinks = (walletBook, walletKey) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
  const walletData = findWalletBookWallet(walletBook, walletKey);
  const links = {
    android: "",
    brave: "",
    chrome: "",
    edge: "",
    firefox: "",
    ios: ""
  };
  links.brave = (_b = renderTemplate("chromeUrl", (_a4 = walletData === null || walletData === void 0 ? void 0 : walletData.desktop) === null || _a4 === void 0 ? void 0 : _a4.chromeId)) !== null && _b !== void 0 ? _b : "";
  links.chrome = (_d = renderTemplate("chromeUrl", (_c = walletData === null || walletData === void 0 ? void 0 : walletData.desktop) === null || _c === void 0 ? void 0 : _c.chromeId)) !== null && _d !== void 0 ? _d : "";
  links.edge = (_f = renderTemplate("edgeUrl", (_e = walletData === null || walletData === void 0 ? void 0 : walletData.desktop) === null || _e === void 0 ? void 0 : _e.edgeId)) !== null && _f !== void 0 ? _f : "";
  links.firefox = (_h = renderTemplate("firefoxUrl", (_g = walletData === null || walletData === void 0 ? void 0 : walletData.desktop) === null || _g === void 0 ? void 0 : _g.firefoxId)) !== null && _h !== void 0 ? _h : "";
  links.ios = (_m = (_k = renderTemplate("iosUrl", (_j = walletData === null || walletData === void 0 ? void 0 : walletData.mobile) === null || _j === void 0 ? void 0 : _j.iosId)) !== null && _k !== void 0 ? _k : (_l = walletData === null || walletData === void 0 ? void 0 : walletData.mobile) === null || _l === void 0 ? void 0 : _l.ios) !== null && _m !== void 0 ? _m : "";
  links.android = (_r = (_p = renderTemplate("androidUrl", (_o = walletData === null || walletData === void 0 ? void 0 : walletData.mobile) === null || _o === void 0 ? void 0 : _o.androidId)) !== null && _p !== void 0 ? _p : (_q = walletData === null || walletData === void 0 ? void 0 : walletData.mobile) === null || _q === void 0 ? void 0 : _q.android) !== null && _r !== void 0 ? _r : "";
  return links;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletPrimaryColor.js
var getWalletPrimaryColor = (walletBook, walletKey) => {
  var _a4;
  const walletData = getWalletBookWallet(walletBook, walletKey);
  return (_a4 = walletData === null || walletData === void 0 ? void 0 : walletData.brand) === null || _a4 === void 0 ? void 0 : _a4.primaryColor;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletGroup.js
var getWalletGroup = (walletBook, key) => {
  const group = walletBook.groups[key];
  if (!group)
    throw new Error(`Group ${key} not found in wallet book`);
  return group;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroup.js
var findWalletGroup = (walletBook, walletGroup) => {
  try {
    return getWalletGroup(walletBook, walletGroup);
  } catch (err) {
    logger3.error(err);
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookCdnUrl.js
var getWalletBookCdnUrl = () => {
  var _a4, _b, _c;
  return (_c = (_b = (_a4 = process.env["WALLET_BOOK_CDN_URL"]) !== null && _a4 !== void 0 ? _a4 : process.env["NEXT_PUBLIC_WALLET_BOOK_CDN_URL"]) !== null && _b !== void 0 ? _b : process.env["REACT_APP_WALLET_BOOK_CDN_URL"]) !== null && _c !== void 0 ? _c : "https://dynamic-static-assets.com/wallet-book/v1/stable/wallet-book.json";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroupOverride.js
var findWalletGroupOverride = (walletBook, groupKey, walletKey) => {
  var _a4;
  const group = findWalletGroup(walletBook, groupKey);
  return (_a4 = group === null || group === void 0 ? void 0 : group.walletOverrides) === null || _a4 === void 0 ? void 0 : _a4[walletKey];
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/isWalletMethodSupported.js
var isWalletMethodSupported = (wallet, method, platform) => {
  var _a4, _b, _c;
  return !((_c = (_b = (_a4 = wallet === null || wallet === void 0 ? void 0 : wallet.walletLimitations) === null || _a4 === void 0 ? void 0 : _a4[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedMethods) === null || _c === void 0 ? void 0 : _c.includes(method));
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/isWalletEventSupported.js
var isWalletEventSupported = (wallet, event, platform) => {
  var _a4, _b, _c;
  return !((_c = (_b = (_a4 = wallet === null || wallet === void 0 ? void 0 : wallet.walletLimitations) === null || _a4 === void 0 ? void 0 : _a4[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedEvents) === null || _c === void 0 ? void 0 : _c.includes(event));
};

// node_modules/@dynamic-labs/wallet-book/_virtual/_tslib.js
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter4(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a4;
    const ctx = {
      common: {
        issues: [],
        async: (_a4 = params === null || params === void 0 ? void 0 : params.async) !== null && _a4 !== void 0 ? _a4 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a4) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a4;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a4 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a4 !== void 0 ? _a4 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a4;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a4;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a4, _b, _c, _d;
          const defaultError = (_c = (_b = (_a4 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a4, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a4, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a4 = p.fatal) !== null && _a4 !== void 0 ? _a4 : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletConnectSourceSchema.js
var walletConnectSourceValueSchema = z.object({
  app: z.object({
    android: z.string().nullable(),
    browser: z.string().nullable(),
    chrome: z.string().nullable(),
    edge: z.string().nullable(),
    firefox: z.string().nullable(),
    ios: z.string().nullable(),
    linux: z.string().nullable(),
    mac: z.string().nullable(),
    opera: z.string().nullable(),
    safari: z.string().nullable(),
    windows: z.string().nullable()
  }),
  app_type: z.string(),
  category: z.string().nullable(),
  chains: z.array(z.string()),
  description: z.string().nullable(),
  desktop: z.object({
    native: z.string().nullable(),
    universal: z.string().nullable()
  }),
  homepage: z.string(),
  id: z.string(),
  image_id: z.string(),
  image_url: z.object({
    lg: z.string(),
    md: z.string(),
    sm: z.string()
  }),
  injected: z.array(z.object({
    injected_id: z.string(),
    namespace: z.string()
  })).nullable(),
  metadata: z.object({
    colors: z.object({
      primary: z.string().nullable(),
      secondary: z.string().nullable()
    }),
    shortName: z.string().nullable()
  }),
  mobile: z.object({
    native: z.string().nullable(),
    universal: z.string().nullable()
  }),
  name: z.string(),
  rdns: z.string().nullable(),
  sdks: z.array(z.string()),
  slug: z.string(),
  supported_standards: z.array(z.object({
    id: z.string(),
    standard_id: z.number(),
    standard_prefix: z.string(),
    title: z.string(),
    url: z.string()
  })).optional(),
  updatedAt: z.string(),
  versions: z.array(z.string())
}).strict();
z.record(z.string(), walletConnectSourceValueSchema);

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyString.js
var nonEmptyString = z.preprocess((val) => val ? val : void 0, z.string().optional());

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformChromeExtensionId.js
var transformChromeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("chrome.google.com/webstore/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a4) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformEdgeExtensionId.js
var transformEdgeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("microsoftedge.microsoft.com/addons/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a4) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformFirefoxExtensionId.js
var transformFirefoxExtensionId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("addons.mozilla.org")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
    } catch (_a4) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformIosId.js
var idRegex = /^id[0-9]{1,36}$/;
var transformIosId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(idRegex))
    return url;
  if (url === null || url === void 0 ? void 0 : url.match(/^https:\/\/[a-zA-Z0-9-]+\.apple\.com/)) {
    try {
      const urlObject = new URL(url);
      const expectedId = urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
      if (expectedId === null || expectedId === void 0 ? void 0 : expectedId.match(idRegex)) {
        return expectedId;
      }
    } catch (_a4) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformAndroidId.js
var transformAndroidId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (!url)
    return;
  try {
    const urlObject = new URL(url);
    const id = urlObject.searchParams.get("id");
    if (id) {
      return id;
    }
  } catch (_a4) {
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyStringArray.js
var nonEmptyStringArray = z.preprocess((val) => Array.isArray(val) && val.length > 0 ? val : void 0, z.array(z.string()).optional());

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/filterEmptyObject.js
var filterEmptyObject = (val) => val && Object.values(val).some((x) => Boolean(x)) ? val : void 0;

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletSchema.js
var injectedConfigSchema = z.object({
  chain: z.string(),
  extensionLocators: z.array(z.object({
    flag: z.string(),
    value: z.boolean().optional().default(true)
  })),
  /**
   * Allows declaring which interface, if any, this wallet's implementation follows
   * ex. Leather with https://btckit.org/
   */
  providerInterface: z.string().optional(),
  /**
   * Allows declaring that this wallet is discoverable through the the Wallet Standard
   * See https://github.com/wallet-standard/wallet-standard
   * Also allows ignoring wallets that don't support the provided features
   */
  walletStandard: z.object({
    features: z.array(z.string()),
    name: z.string(),
    providerId: z.string().optional()
  }).optional(),
  walletStandardLocators: z.array(z.object({ locator: z.string(), name: z.string() })).optional(),
  windowLocations: z.array(z.string()).optional().refine((val) => {
    if (!val)
      return true;
    if (!val.some((v) => ["ethereum", "ethereum.providers"].includes(v)))
      return true;
    return false;
  }, {
    message: "windowLocations cannot include ethereum or ethereum.providers as they are included by default",
    path: ["config"]
  })
});
var brandSchema = z.object({
  alt: nonEmptyString,
  primaryColor: nonEmptyString,
  spriteId: nonEmptyString
});
var walletSchema = z.preprocess((val) => val, z.object({
  brand: brandSchema.optional(),
  chainGroup: z.string().optional(),
  chains: z.array(z.string()).optional(),
  desktop: z.object({
    chromeId: nonEmptyString.transform(transformChromeExtensionId),
    edgeId: nonEmptyString.transform(transformEdgeExtensionId),
    firefoxId: nonEmptyString.transform(transformFirefoxExtensionId),
    native: nonEmptyString,
    operaId: nonEmptyString,
    safariId: nonEmptyString,
    universal: nonEmptyString
  }).optional().transform(filterEmptyObject),
  eip6963Config: z.object({ rdns: z.string() }).optional(),
  filterFromWalletConnect: z.boolean().optional(),
  group: z.string().optional(),
  /**
   * Indicates which hardware wallets are enabled for this wallet
   */
  hardwareWallets: z.array(z.string()).optional(),
  injectedConfig: z.array(injectedConfigSchema).optional(),
  mobile: z.object({
    android: stringType().nullish(),
    androidId: nonEmptyString.transform(transformAndroidId),
    inAppBrowser: stringType().nullish(),
    ios: stringType().nullish(),
    iosId: nonEmptyString.transform(transformIosId),
    native: nonEmptyString,
    universal: nonEmptyString
  }).optional().transform(filterEmptyObject),
  mobileExperience: z.enum(["in-app-browser", "redirect"]).optional(),
  name: z.string(),
  shortName: nonEmptyString,
  showOnlyIfInstalled: z.boolean().optional(),
  switchNetworkOnlyFromWallet: z.boolean().optional(),
  walletConnect: z.object({
    sdks: nonEmptyStringArray
  }).optional().transform(filterEmptyObject),
  walletGroup: z.string().optional(),
  /**
   * Indicates which connector methods/events are not supported, keyed by wallet type
   */
  walletLimitations: z.object({
    browserExtension: z.object({
      unsupportedEvents: z.array(z.string()).optional(),
      unsupportedMethods: z.array(z.string()).optional()
    }).optional(),
    mobile: z.object({
      unsupportedEvents: z.array(z.string()).optional(),
      unsupportedMethods: z.array(z.string()).optional()
    }).optional()
  }).optional()
})).transform((val) => {
  var _a4, _b, _c, _d, _e, _f;
  if (val.group) {
    val.chainGroup = val.group;
  }
  if (((_a4 = val.mobile) === null || _a4 === void 0 ? void 0 : _a4.iosId) || ((_b = val.mobile) === null || _b === void 0 ? void 0 : _b.ios) === null) {
    (_c = val.mobile) === null || _c === void 0 ? true : delete _c.ios;
  }
  if (((_d = val.mobile) === null || _d === void 0 ? void 0 : _d.androidId) || ((_e = val.mobile) === null || _e === void 0 ? void 0 : _e.android) === null) {
    (_f = val.mobile) === null || _f === void 0 ? true : delete _f.android;
  }
  return val;
});

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletGroup.js
var WalletOverrideEntrySchema = z.object({
  brand: brandSchema.optional(),
  name: nonEmptyString
});
var walletGroupSchema = z.object({
  brand: z.object({
    alt: nonEmptyString,
    primaryColor: nonEmptyString,
    spriteId: nonEmptyString
  }).optional(),
  key: z.string(),
  name: z.string(),
  walletOverrides: z.record(WalletOverrideEntrySchema).optional()
});

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletBookSchema.js
z.record(z.string(), walletSchema);
var walletBookSchema = z.preprocess((val) => val, z.object({
  groups: z.record(z.string(), walletGroupSchema),
  wallets: z.record(z.string(), walletSchema)
}));
z.record(z.string(), walletGroupSchema);

// node_modules/@dynamic-labs/wallet-book/wallet-book-fallbacks.js
var groups = {
  argentx: {
    brand: {
      alt: "ArgentX",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    key: "argentx",
    name: "ArgentX"
  },
  backpack: {
    brand: {
      alt: "Backpack",
      spriteId: "backpack"
    },
    key: "backpack",
    name: "Backpack"
  },
  bitgetwallet: {
    brand: {
      alt: "Bitget Wallet",
      spriteId: "bitget"
    },
    key: "bitgetwallet",
    name: "Bitget"
  },
  blocto: {
    brand: {
      alt: "Blocto",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    key: "blocto",
    name: "Blocto"
  },
  brave: {
    brand: {
      alt: "Brave Browser",
      primaryColor: "#4B49C6",
      spriteId: "brave"
    },
    key: "brave",
    name: "Brave"
  },
  coin98: {
    brand: {
      alt: "Coin98 Wallet",
      primaryColor: "#CDA349",
      spriteId: "fc460647-ea95-447a-99f0-1bff8fa4be00"
    },
    key: "coin98",
    name: "Coin98"
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    key: "coinbase",
    name: "Coinbase"
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    key: "exodus",
    name: "Exodus"
  },
  keplr: {
    brand: {
      alt: "Keplr",
      spriteId: "keplr"
    },
    key: "keplr",
    name: "Keplr"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    key: "magiceden",
    name: "Magic Eden"
  },
  mathwallet: {
    brand: {
      alt: "MathWallet Wallet",
      spriteId: "26a8f588-3231-4411-60ce-5bb6b805a700"
    },
    key: "mathwallet",
    name: "Math Wallet"
  },
  metamask: {
    brand: {
      alt: "MetaMask",
      primaryColor: "#E2761B",
      spriteId: "metamask"
    },
    key: "metamask",
    name: "MetaMask"
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    key: "okxwallet",
    name: "OKX Wallet"
  },
  onekey: {
    brand: {
      alt: "OneKey Wallet",
      spriteId: "12bebb3f-8030-4892-8452-c60a6bac1500"
    },
    key: "onekey",
    name: "OneKey"
  },
  phantom: {
    brand: {
      alt: "Phantom",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    key: "phantom",
    name: "Phantom"
  }
};
var wallets = {
  metamask: {
    brand: {
      alt: "MetaMask Wallet",
      primaryColor: "#E8831D",
      spriteId: "metamask"
    },
    chainGroup: "metamask",
    chains: [
      "eip155:1"
    ],
    desktop: {
      chromeId: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edgeId: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefoxId: "ether-metamask"
    },
    eip6963Config: {
      rdns: "io.metamask"
    },
    filterFromWalletConnect: true,
    group: "metamask",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMetaMask",
            value: true
          },
          {
            flag: "isDawn",
            value: false
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isTrustWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isSuperb",
            value: false
          },
          {
            flag: "isRabby",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          },
          {
            flag: "isRainbow",
            value: false
          },
          {
            flag: "isAvalanche",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isOneKey",
            value: false
          },
          {
            flag: "isPhantom",
            value: false
          },
          {
            flag: "isCoin98",
            value: false
          },
          {
            flag: "isBinance",
            value: false
          }
        ]
      }
    ],
    mobile: {
      androidId: "io.metamask",
      inAppBrowser: "https://metamask.app.link/dapp",
      iosId: "id1438144202",
      native: "metamask://wc",
      universal: "https://metamask.app.link/wc"
    },
    mobileExperience: "in-app-browser",
    name: "MetaMask",
    shortName: "MetaMask",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    eip6963Config: {
      rdns: "com.coinbase.wallet"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isCoinbaseWallet",
            value: true
          }
        ],
        windowLocations: [
          "coinbaseWalletExtension"
        ]
      }
    ],
    mobile: {
      androidId: "org.toshi",
      iosId: "id1278383455"
    },
    name: "Coinbase",
    shortName: "Coinbase Wallet"
  },
  coinbasesolana: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [],
        windowLocations: [
          "coinbaseSolana"
        ]
      }
    ],
    name: "Coinbase",
    shortName: "Coinbase Wallet (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  phantom: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom"
  },
  phantombtc: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        walletStandard: {
          features: [
            "bitcoin:connect"
          ],
          name: "Phantom"
        },
        windowLocations: [
          "phantom.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Bitcoin)"
  },
  phantomevm: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        windowLocations: [
          "phantom.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (EVM)"
  },
  phantomledger: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Ledger)"
  },
  walletconnect: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1438144202"
    },
    name: "WalletConnect",
    shortName: "WalletConnect"
  },
  argentx: {
    brand: {
      alt: "Argent X Wallet",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    desktop: {
      chromeId: "dlcobpjiigpikoobohmabehhmhfoodbb",
      edgeId: "ajcicjlkibolbeaaagejfhnofogocgcj",
      firefoxId: "argent-x"
    },
    mobile: {
      androidId: "im.argent.contractwalletclient",
      iosId: "id1358741926"
    },
    name: "Argent X"
  },
  perawallet: {
    brand: {
      alt: "Pera Wallet",
      spriteId: "pera"
    },
    mobile: {
      androidId: "com.algorand.android",
      iosId: "id1459898525"
    },
    name: "Pera Wallet"
  },
  blocto: {
    brand: {
      alt: "Blocto Wallet",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    chainGroup: "blocto",
    group: "blocto",
    mobile: {
      androidId: "com.portto.blocto",
      iosId: "id1481181682"
    },
    name: "Blocto",
    shortName: "Blocto (Flow)"
  },
  solflare: {
    brand: {
      alt: "Solflare Wallet",
      primaryColor: "#FC7227",
      spriteId: "solflare"
    },
    chains: [
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "bhhhlbepdkbapadjdnnojkbgioiodbic"
    },
    filterFromWalletConnect: true,
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isSolflare",
            value: true
          }
        ],
        windowLocations: [
          "solflare"
        ]
      }
    ],
    mobile: {
      androidId: "com.solflare.mobile",
      iosId: "id1580902717"
    },
    name: "Solflare",
    walletConnect: {
      sdks: [
        "sign_v1"
      ]
    },
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  braavos: {
    brand: {
      alt: "Braavos Wallet",
      primaryColor: "#FABB38",
      spriteId: "braavos"
    },
    desktop: {
      chromeId: "jnlgamecbpmbajjfhmmmlhejkemejdma",
      edgeId: "hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      firefoxId: "braavos-wallet"
    },
    mobile: {
      androidId: "app.braavos.wallet",
      iosId: "id1636013523"
    },
    name: "Braavos"
  },
  trust: {
    brand: {
      alt: "Trust Wallet",
      primaryColor: "#0500FF",
      spriteId: "7677b54f-3486-46e2-4e37-bf8747814f00"
    },
    chains: [
      "cosmos:cosmoshub-4",
      "cosmos:kava-4",
      "cosmos:thorchain-mainnet-v1",
      "eip155:1",
      "eip155:10",
      "eip155:100",
      "eip155:108",
      "eip155:1101",
      "eip155:128",
      "eip155:137",
      "eip155:2020",
      "eip155:288",
      "eip155:321",
      "eip155:324",
      "eip155:361",
      "eip155:42161",
      "eip155:42220",
      "eip155:43114",
      "eip155:4689",
      "eip155:56",
      "eip155:56288",
      "eip155:59144",
      "eip155:60",
      "eip155:820",
      "eip155:88",
      "eip155:9001",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "egjidjbpglichdcondbcbdnbeeppgdph"
    },
    eip6963Config: {
      rdns: "com.trustwallet.app"
    },
    filterFromWalletConnect: true,
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isTrustWallet",
            value: true
          }
        ],
        windowLocations: [
          "trustWallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.wallet.crypto.trustapp",
      iosId: "id1288339409",
      native: "trust://wc",
      universal: "https://link.trustwallet.com/wc"
    },
    name: "Trust",
    shortName: "Trust",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  rainbow: {
    brand: {
      alt: "Rainbow Wallet",
      primaryColor: "#001e59",
      spriteId: "rainbow"
    },
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:137",
      "eip155:42161",
      "eip155:56",
      "eip155:7777777",
      "eip155:8453"
    ],
    desktop: {
      chromeId: "opfgelmcmbiajamepnmloijbpoleiama",
      edgeId: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefoxId: "rainbow-extension"
    },
    eip6963Config: {
      rdns: "me.rainbow"
    },
    filterFromWalletConnect: true,
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isRainbow",
            value: true
          }
        ],
        windowLocations: [
          "rainbow"
        ]
      }
    ],
    mobile: {
      androidId: "me.rainbow",
      iosId: "id1457119021",
      native: "rainbow://wc",
      universal: "https://rnbwapp.com/wc"
    },
    name: "Rainbow",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  dapper: {
    brand: {
      alt: "Dapper Wallet",
      primaryColor: "#762FBE",
      spriteId: "dapper"
    },
    mobile: {
      android: "fake-to-get-dapper-to-appear",
      ios: "fake-to-get-dapper-to-appear"
    },
    name: "Dapper"
  },
  glow: {
    brand: {
      alt: "Glow Wallet",
      spriteId: "glow"
    },
    desktop: {
      chromeId: "ojbcfhjmpigfobfclfflafhblgemeidi",
      edgeId: "niihfokdlimbddhfmngnplgfcgpmlido",
      firefoxId: "glow-solana-wallet"
    },
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isGlow",
            value: true
          }
        ],
        windowLocations: [
          "glowSolana"
        ]
      }
    ],
    name: "Glow"
  },
  lilico: {
    brand: {
      alt: "Lilico Wallet",
      spriteId: "lilico"
    },
    desktop: {
      chromeId: "hpclkefagolihohboafpheddmmgdffjm"
    },
    filterFromWalletConnect: true,
    name: "Lilico"
  },
  magicemailotp: {
    brand: {
      alt: "Magic Email OTP",
      spriteId: "magiclink"
    },
    name: "Magic Email OTP"
  },
  magiclink: {
    brand: {
      alt: "Magic Link",
      spriteId: "magiclink"
    },
    name: "Magic Link"
  },
  magicsocial: {
    brand: {
      alt: "Magic Social",
      spriteId: "magiclink"
    },
    name: "Magic Social"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:8453",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    eip6963Config: {
      rdns: "io.magiceden.wallet"
    },
    filterFromWalletConnect: true,
    group: "magiceden",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      iosId: "id6478631482",
      native: "magiceden://wc"
    },
    name: "Magic Eden"
  },
  magicedenbtc: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Magic Eden"
        },
        windowLocations: [
          "magicEden.bitcoin"
        ]
      }
    ],
    name: "Magic Eden",
    shortName: "Magic Eden (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  magicedensol: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.solana"
        ]
      }
    ],
    name: "Magic Eden",
    shortName: "Magic Eden (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "4c16cad4-cac9-4643-6726-c696efaf5200"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc",
      universal: "https://exodus.com/m/wc"
    },
    name: "Exodus",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodusevm: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isExodus",
            value: true
          }
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (EVM)",
    walletConnect: {
      sdks: [
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodussol: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    group: "exodus",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isExodus",
            value: true
          }
        ],
        windowLocations: [
          "exodus.solana"
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (Solana)"
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "eip155:66",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    eip6963Config: {
      rdns: "com.okex.wallet"
    },
    filterFromWalletConnect: true,
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isOKExWallet",
            value: true
          },
          {
            flag: "isOkxWallet",
            value: true
          }
        ],
        windowLocations: [
          "okxwallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      iosId: "id1327268470",
      native: "okex://main/wc"
    },
    name: "OKX",
    shortName: "OKX Wallet",
    walletConnect: {
      sdks: [
        "sign_v2"
      ]
    }
  },
  backpack: {
    brand: {
      alt: "Backpack",
      primaryColor: "#e43c3c",
      spriteId: "backpack"
    },
    chainGroup: "backpack",
    chains: [
      "eip155:1",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "aflkmfhebedbjioipglgcbcmnbpgliof"
    },
    eip6963Config: {
      rdns: "app.backpack"
    },
    filterFromWalletConnect: true,
    group: "backpack",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isBackpack",
            value: true
          }
        ],
        windowLocations: []
      }
    ],
    name: "Backpack",
    walletConnect: {
      sdks: [
        "sign_v1"
      ]
    }
  },
  okxwalletbtc: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "okxwallet.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470"
    },
    name: "OKX",
    shortName: "OKX Wallet (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  unisat: {
    brand: {
      alt: "UniSat",
      spriteId: "unisat"
    },
    desktop: {
      chromeId: "ppbibelpcjmhbdihakflkdcoccbgbkpo"
    },
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "unisat"
        ]
      }
    ],
    name: "UniSat"
  },
  unknown: {
    brand: {
      spriteId: "captcha-wave"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Unknown Wallet",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  xverse: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Xverse",
          providerId: "XverseProviders.BitcoinProvider"
        },
        windowLocations: [
          "XverseProviders.BitcoinProvider"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    name: "Xverse",
    walletLimitations: {
      browserExtension: {
        unsupportedEvents: [
          "accountChanged"
        ],
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  fallbackconnector: {
    brand: {
      spriteId: "captcha-wave"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Fallback Connector",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  }
};
var walletBookFallbacks = {
  groups,
  wallets
};

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
var useWalletBookCdn = () => {
  const [walletBook, setWalletBook] = (0, import_react4.useState)({});
  (0, import_react4.useEffect)(() => {
    const fetchWalletBook = () => __awaiter4(void 0, void 0, void 0, function* () {
      const url = getWalletBookCdnUrl();
      const fn = () => __awaiter4(void 0, void 0, void 0, function* () {
        const res = yield fetch(url, { mode: "cors" });
        if (res.ok) {
          const json = yield res.json();
          try {
            const parsedData = walletBookSchema.parse(json);
            return parsedData;
          } catch (e) {
            logger3.error("Error parsing wallet book data", e, json);
            throw e;
          }
        }
        throw new Error(`Failed to fetch wallet book data from ${url} with status code ${res.status}`);
      });
      const data = yield retryableFn(fn, {
        fallbackValue: walletBookSchema.parse(walletBookFallbacks),
        logger: logger3.createLogger("useWalletBookCdn"),
        maxRetries: 3,
        retryStrategy: "timeout-and-rejection",
        timeoutMs: 3e4
      });
      setWalletBook(data);
    });
    fetchWalletBook();
  }, []);
  return walletBook;
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletIcon.js
var import_react5 = __toESM(require_react(), 1);
var WalletIcon = (_a4) => {
  var { walletKey, children } = _a4, props = __rest2(_a4, ["walletKey", "children"]);
  const { walletBook } = useWalletBookContext();
  const walletData = findWalletBookWallet(walletBook, walletKey);
  const [imgError, setImgError] = (0, import_react5.useState)(false);
  const walletIconUrl = getWalletIconUrl(walletBook, walletKey);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletData || !walletData.brand || !walletIconUrl) {
    return (0, import_react5.createElement)(import_react5.Fragment, {}, children);
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react5.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: walletData.brand.alt, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }), children);
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletBookContextProvider.js
var import_react6 = __toESM(require_react(), 1);
var WalletBookContextProvider = ({ walletBook, children }) => (0, import_react6.createElement)(WalletBookContext.Provider, {
  value: { walletBook }
}, children);

// node_modules/@dynamic-labs/wallet-book/src/components/BrandIcon.js
var import_react7 = __toESM(require_react(), 1);
var BrandIcon = (_a4) => {
  var { brand, walletKey } = _a4, props = __rest2(_a4, ["brand", "walletKey"]);
  const [imgError, setImgError] = (0, import_react7.useState)(false);
  const walletIconUrl = getBrandIconUrl(brand);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletIconUrl) {
    return (0, import_react7.createElement)(import_react7.Fragment, {});
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react7.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: brand.alt, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }));
};

// node_modules/@dynamic-labs/wallet-connector-core/_virtual/_tslib.js
function __rest3(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/logger.js
var logger4 = new Logger("WalletConnector");

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/shouldLowercaseAddress.js
var shouldLowercaseAddress = (chain) => (
  // these are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md
  // see also: https://github.com/ChainAgnostic/namespaces
  // note: no standard namespace currently exists for flow
  ["eip155", "flow", "evm", "eth", "avax", "matic"].includes(chain.toLowerCase())
);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/utils/normalizeAddress/normalizeAddress.js
var normalizeAddress = (rawAddress, chain) => {
  if (rawAddress.startsWith("0x")) {
    rawAddress = rawAddress.slice(2);
  }
  const address = shouldLowercaseAddress(chain) ? rawAddress.toLowerCase() : rawAddress;
  return address;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/isSameAddress.js
var isSameAddress = (left, right, chain) => normalizeAddress(left, chain) === normalizeAddress(right, chain);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getMobileExperience/getMobileExperience.js
var getMobileExperience = ({ mobileExperienceProp, walletBook, walletKey }) => {
  if (mobileExperienceProp && typeof mobileExperienceProp === "string")
    return mobileExperienceProp;
  if (mobileExperienceProp === null || mobileExperienceProp === void 0 ? void 0 : mobileExperienceProp[walletKey])
    return mobileExperienceProp[walletKey];
  const walletRecord = findWalletBookWallet(walletBook, walletKey);
  if (walletRecord === null || walletRecord === void 0 ? void 0 : walletRecord.mobileExperience)
    return walletRecord.mobileExperience;
  if (mobileExperienceProp === null || mobileExperienceProp === void 0 ? void 0 : mobileExperienceProp.default)
    return mobileExperienceProp.default;
  return "in-app-browser";
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isConnectorMethodSupported/isConnectorMethodSupported.js
var isConnectorMethodSupported = (connector, method, platform) => {
  const walletBookWallet = connector.constructorProps.walletData || getWalletBookWallet(connector.walletBook, connector.key);
  return isWalletMethodSupported(walletBookWallet, method, platform);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/lib/WalletBookSingleton.js
var WalletBookSingleton = class _WalletBookSingleton {
  constructor(walletBook) {
    this.walletBook = walletBook;
  }
  static getOrCreate(walletBook) {
    var _a4;
    if (!((_a4 = _WalletBookSingleton.instance) === null || _a4 === void 0 ? void 0 : _a4.walletBook)) {
      _WalletBookSingleton.instance = new _WalletBookSingleton(walletBook);
    }
    return _WalletBookSingleton.instance;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/lib/WalletConnector.js
var _WalletConnectorBase_registeredExtensions;
var WalletConnectorBase = class extends eventemitter3_default {
  createWallet(props) {
    const wallet = new this.ChainWallet(props);
    return wallet;
  }
  /**
   * We store the constructor props so that we can use them later on
   * in getMobileOrInstalledWallet which may fall back to a different class
   * but will need the original constructor props.
   * @param props - constructor props
   */
  constructor(props) {
    super();
    this.chainRpcProviders = void 0;
    this.isGlobalTransaction = false;
    _WalletConnectorBase_registeredExtensions.set(this, []);
    this.didSetup = false;
    this.requiresNonDynamicEmailOtp = false;
    this.canConnectViaCustodialService = false;
    this.canConnectViaQrCode = false;
    this.canConnectViaSocial = false;
    this.isAvailable = true;
    this.isEmbeddedWallet = false;
    this.isWalletConnect = false;
    this.overrideKey = void 0;
    this.providerResources = void 0;
    this.switchNetworkOnlyFromWallet = void 0;
    this.isInitialized = true;
    this.constructorProps = props;
    this._walletBookInstance = WalletBookSingleton.getOrCreate(props.walletBook);
    if (this.walletBook === void 0) {
      throw new Error("WalletConnectorBase was not called with super(props) and is missing wallet-book");
    }
  }
  extend(extension) {
    if (__classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").includes(extension.name)) {
      throw new Error(`You can only register a single extension of: ${extension.name}`);
    }
    if (extension.name === "global-wallet-extension") {
      if (!this.isEmbeddedWallet || !this.supportedChains.includes("EVM"))
        return;
    }
    __classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").push(extension.name);
    extension.extend(this);
  }
  /**
   * Add the event listeners for the wallet and connect
   * with event emitter.
   */
  initEventListener() {
    if (this.didSetup)
      return;
    this.didSetup = true;
    this.setupEventListeners();
  }
  get walletBook() {
    return this._walletBookInstance.walletBook;
  }
  filter() {
    try {
      getWalletBookWallet(this.walletBook, this.key, this.walletFallback);
      return true;
    } catch (_a4) {
      return false;
    }
  }
  get mobileExperience() {
    return getMobileExperience({
      mobileExperienceProp: this.constructorProps.mobileExperience,
      walletBook: this.walletBook,
      walletKey: this.key
    });
  }
  /**
   * Prompt the user to choose accounts to connect (see behavior in MM)
   * @default Promise<[]>
   */
  chooseAccountsToConnect() {
    return Promise.resolve([]);
  }
  connect() {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  /**
   * Generic function to close the wallet connection
   * Originally implemented for WalletConnect, but it is used
   * for anything that needs to be "logged out" or cleaned up
   *
   * @default Promise<undefined>
   */
  endSession() {
    return Promise.resolve();
  }
  /**
   * Gets the public address of the wallet
   *
   * @default Promise<undefined>
   */
  getAddress(opts) {
    return Promise.resolve(void 0);
  }
  /**
   * Parses a public address to ensure it follows a correct format.
   *
   * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
   *
   * @default string
   */
  parseAddress(address) {
    return address;
  }
  /**
   * Whether this wallet connector is targeting a testnet.
   * So far only supported for EVM connectors.
   *
   * @default Promise<false>
   */
  isTestnet() {
    return Promise.resolve(false);
  }
  /**
   * Gets the additional addresses of the wallet, given the main address
   *
   * @default Promise<[]>
   */
  getAdditionalAddresses(mainAddress) {
    return Promise.resolve([]);
  }
  /**
   * Sets the additional addresses of the wallet, given the main address
   *
   * @default Promise<void>
   */
  setAdditionalAddresses(mainAddress, additionalAddresses) {
    return Promise.resolve();
  }
  /**
   * Gets the balance of the wallet
   *
   * @default Promise<undefined>
   */
  getBalance(address) {
    return Promise.resolve(void 0);
  }
  /**
   * Get the address silently
   *
   * @default Promise<[]>
   */
  getConnectedAccounts() {
    return Promise.resolve([]);
  }
  /**
   * Gets the deep link of the wallet
   *
   * @default undefined
   */
  getDeepLink() {
    return void 0;
  }
  getNetwork() {
    return Promise.resolve(void 0);
  }
  /**
   * Gets current network of connected wallet
   *
   * @default Promise<undefined>
   */
  getNameService(address) {
    return Promise.resolve(void 0);
  }
  getPublicClient() {
    return Promise.resolve(void 0);
  }
  getSession() {
    return __awaiter5(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  getSigner() {
    return Promise.resolve(void 0);
  }
  getWalletClient(chainId) {
    return void 0;
  }
  /**
   * Initialize the wallet connector with any async operations
   *
   * @default Promise<void>
   */
  init() {
    return Promise.resolve();
  }
  /**
   * Check if the wallet is installed on the browser
   *
   * @default false
   */
  isInstalledOnBrowser() {
    return false;
  }
  /**
   * Override key or the normalized wallet name if needed
   */
  get key() {
    return this.overrideKey || this.name.replace(/\W/g, "").toLowerCase();
  }
  /**
   * Whether the wallet connector should fall back to a different wallet connector
   * This is called after the object is instantiated, so it can't be a static property
   * and will return the appropriate instance of the wallet connector
   * @returns WalletConnector
   * @default this
   */
  getMobileOrInstalledWallet() {
    return this;
  }
  /**
   * In most cases this is an alias for `signMessage`
   *
   * @default Promise<undefined>
   */
  proveOwnership(address, messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      return this.signMessage(messageToSign);
    });
  }
  /**
   * Set up event listeners for the wallet
   *
   * @default void
   */
  setupEventListeners() {
    return;
  }
  /**
   * Sign a message
   *
   * @default Promise<undefined>
   */
  signMessage(messageToSign, withAddress) {
    return Promise.resolve(void 0);
  }
  /**
   * Whether the wallet supports network switching
   *
   * @default false
   */
  supportsNetworkSwitching() {
    return false;
  }
  switchNetwork({ networkName, networkChainId }) {
    return Promise.resolve(void 0);
  }
  /**
   * Tear down event listeners for the wallet
   * @default void
   */
  teardownEventListeners() {
    return;
  }
  /**
   * Receive the user verified credentials
   */
  setVerifiedCredentials(verifiedCredentials) {
    return;
  }
  /**
   * Whether the wallet allow for getting the address in the
   * current chain.
   * This is used for multi chain wallets.
   * @default true
   */
  canGetChainAddress() {
    return true;
  }
  /**
   * Prompts the user to make expected wallet active
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
   * otherwise rejects with an error.
   */
  handleWalletNotActive(_a4) {
    return __awaiter5(this, arguments, void 0, function* ({ activeAddress, expectedAddress, reconnectedAddress }) {
      logger4.debug("validateActiveWallet - wallet is not active", {
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
      const currentActiveAddress = activeAddress || reconnectedAddress || "";
      const walletUiUtils = this.constructorProps.walletUiUtils;
      if (!walletUiUtils) {
        throw new WalletAddressMismatchError(`Wallet ${expectedAddress !== null && expectedAddress !== void 0 ? expectedAddress : ""} is not currently active in ${this.name || this.key}.`, {
          activeAddress: currentActiveAddress,
          expectedAddress,
          walletName: this.name || this.key
        });
      }
      return walletUiUtils.syncWallet({
        activeAddress: currentActiveAddress,
        expectedAddress,
        walletConnector: this
      });
    });
  }
  /**
   * Validates if the address is connected and active in the wallet app
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
   * otherwise rejects with an error.
   */
  validateActiveWallet(expectedAddress) {
    return __awaiter5(this, void 0, void 0, function* () {
      logger4.debug("validateActiveWallet - validating wallet", expectedAddress);
      const canFetchConnectedAccounts = isConnectorMethodSupported(this, "getConnectedAccounts", "browserExtension");
      logger4.debug("validateActiveWallet - getting connected accounts", {
        canFetchConnectedAccounts
      });
      const [activeAddress] = canFetchConnectedAccounts ? yield this.getConnectedAccounts() : [];
      const isWalletActive = activeAddress && isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (isWalletActive) {
        logger4.debug("validateActiveWallet - wallet is active");
        return;
      }
      logger4.debug("validateActiveWallet - trying to reconnect wallet...");
      const getReconnectedAddress = () => __awaiter5(this, void 0, void 0, function* () {
        if (this.isWalletConnect || !this.canGetChainAddress()) {
          return void 0;
        }
        return this.getAddress().catch((err) => {
          logger4.debug("validateActiveWallet - error getting address", err);
          return void 0;
        });
      });
      const reconnectedAddress = yield getReconnectedAddress();
      if (reconnectedAddress && isSameAddress(reconnectedAddress, expectedAddress, this.connectedChain)) {
        logger4.debug("validateActiveWallet - wallet reconnected successfuly");
        return;
      }
      return this.handleWalletNotActive({
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
    });
  }
};
_WalletConnectorBase_registeredExtensions = /* @__PURE__ */ new WeakMap();

// node_modules/@dynamic-labs/wallet-connector-core/src/lib/wallets/Wallet/Wallet.js
var Wallet = class extends BaseWallet {
  constructor(_a4) {
    var { connector } = _a4, props = __rest3(_a4, ["connector"]);
    super(props);
    this._connector = connector;
  }
  /**
   * Gets the wallet connector.
   */
  get connector() {
    return this._connector;
  }
  /**
   * Retrieves the balance of the wallet.
   * @returns A promise that resolves to the balance of the wallet as a string,
   * or undefined if the balance cannot be retrieved.
   */
  getBalance() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getBalance(this.address);
    });
  }
  /**
   * Retrieves the name service data associated with the wallet.
   * @returns A promise that resolves to the name service data of the wallet,
   * or undefined if the data cannot be retrieved.
   */
  getNameService() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getNameService(this.address);
    });
  }
  /**
   * Retrieves the network that the wallet is connected to.
   * @returns A promise that resolves to the network value as a string or number,
   * or undefined if the network cannot be retrieved.
   */
  getNetwork() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getNetwork();
    });
  }
  /**
   * If the wallet is connected.
   * @returns A promise that resolves to true the wallet is connected or false if it's not connected.
   */
  isConnected() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const connectedAccounts = yield this._connector.getConnectedAccounts();
        return connectedAccounts.map((address) => normalizeAddress(address, this.chain)).includes(normalizeAddress(this.address, this.chain));
      } catch (error) {
        logger4.error("[Wallet] isConnected - Error detecting if wallet is connected", error);
        return false;
      }
    });
  }
  /**
   * Proves ownership of the wallet by signing a message.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   *  or undefined if the message cannot be signed.
   */
  proveOwnership(messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.proveOwnership(this.address, messageToSign);
    });
  }
  /**
   * Signs a message using the wallet.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   * or undefined if the message cannot be signed.
   */
  signMessage(messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.signMessage(messageToSign, this.address);
    });
  }
  /**
   * Switches the network that the wallet is connected to.
   * @param networkChainId - The chain id of the network to switch to.
   * @returns A promise that resolves when the network is switched.
   */
  switchNetwork(networkChainId) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.switchNetwork({
        networkChainId
      });
    });
  }
  /**
   * Synchronizes the wallet with the connector.
   * @returns A promise that resolves when the wallet is connected and active.
   */
  sync() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.validateActiveWallet(this.address);
    });
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/ProviderLookup/ProviderLookup.js
var ProviderLookup = (installedProviders, extensionLocators) => {
  if (extensionLocators.length === 0) {
    return void 0;
  }
  return installedProviders.find((provider) => {
    const extensionLocatorMatch = extensionLocators.every((condition) => {
      const flagValue = (provider === null || provider === void 0 ? void 0 : provider[condition.flag]) || false;
      return flagValue === condition.value;
    });
    return extensionLocatorMatch === true;
  });
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getChainInfo/getChainInfo.js
var chainsInfo = [
  {
    blockchainName: "Algorand",
    displayName: "Algorand",
    name: "algorand",
    symbol: "ALGO"
  },
  {
    blockchainName: "Bitcoin",
    displayName: "Bitcoin",
    name: "bitcoin",
    symbol: "BTC"
  },
  {
    blockchainName: "Ethereum",
    displayName: "EVM",
    name: "evm",
    symbol: "ETH"
  },
  {
    blockchainName: "Flow",
    displayName: "Flow",
    name: "flow",
    symbol: "FLOW"
  },
  {
    blockchainName: "Solana",
    displayName: "Solana",
    name: "solana",
    symbol: "SOL"
  },
  {
    blockchainName: "Starknet",
    displayName: "Starknet",
    name: "starknet",
    symbol: "ETH"
  },
  {
    blockchainName: "Cosmos",
    displayName: "Cosmos",
    name: "cosmos",
    symbol: "COSMOS"
  },
  {
    blockchainName: "Bitcoin",
    displayName: "Bitcoin",
    name: "bitcoin",
    symbol: "BTC"
  }
];
var chainOverrides = {
  algo: "algorand",
  bip122: "bitcoin",
  btc: "bitcoin",
  eip155: "evm",
  eth: "evm",
  sol: "solana",
  stark: "starknet"
};
var chainInfoOverrides;
var setChainInfoOverrides = (overrides) => {
  chainInfoOverrides = overrides;
};
var getChainInfo = (chain) => {
  var _a4;
  const lowerCasedChain = chain.toLowerCase();
  const normalizedChain = (_a4 = chainOverrides[lowerCasedChain]) !== null && _a4 !== void 0 ? _a4 : lowerCasedChain;
  const chainInfo = chainsInfo.find((info) => info.name === normalizedChain || info.symbol.toLocaleLowerCase() === normalizedChain);
  if (!chainInfo) {
    return;
  }
  return chainInfo;
};
var getChainInfoWithOverrides = (chain) => {
  var _a4, _b;
  const chainInfo = getChainInfo(chain);
  if (!chainInfo) {
    return;
  }
  const overrides = chainInfoOverrides === null || chainInfoOverrides === void 0 ? void 0 : chainInfoOverrides[chainInfo.name];
  const chainInfoClone = Object.assign({}, chainInfo);
  if (overrides) {
    chainInfoClone.blockchainName = (_a4 = overrides.displayName) !== null && _a4 !== void 0 ? _a4 : chainInfo.blockchainName;
    chainInfoClone.displayName = (_b = overrides.displayName) !== null && _b !== void 0 ? _b : chainInfo.displayName;
  }
  return chainInfoClone;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailOTPWalletConnector/isEmailOTPWalletConnector.js
var isEmailOTPWalletConnector = (walletConnector) => Boolean(walletConnector.verifyOneTimePassword);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailWalletConnector/isEmailWalletConnector.js
var isEmailWalletConnector = (walletConnector) => Boolean(walletConnector.clearEmail);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isTurnkeyWalletConnector/isTurnkeyWalletConnector.js
var isTurnkeyWalletConnector = (walletConnector) => {
  const turnkeyWalletConnector = walletConnector;
  return Boolean(turnkeyWalletConnector && turnkeyWalletConnector.key === "turnkeyhd" && typeof turnkeyWalletConnector.getWebAuthnAttestation === "function" && typeof turnkeyWalletConnector.getAuthenticatorHandler === "function" && typeof turnkeyWalletConnector.getExportHandler === "function" && typeof turnkeyWalletConnector.isSessionKeyCompatible === "function" && typeof turnkeyWalletConnector.createOrRestoreSession === "function");
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSocialWalletConnector/isSocialWalletConnector.js
var isSocialWalletConnector = (walletConnector) => Boolean(walletConnector.canConnectViaSocial);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletConnectorByKey.js
var filterWalletsByKey = (wallets2, keys) => keys.flatMap((key) => wallets2.find((w) => walletHasKey(w, key))).filter(isWalletConnector);
var walletHasKey = (wallet, key) => wallet.key === key;
var isWalletConnector = (item) => Boolean(item);
var getWalletConnectorByKey = (wallets2, key) => filterWalletsByKey(wallets2, [key]).length > 0 ? filterWalletsByKey(wallets2, [key])[0] : null;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/walletConnectDeepLinks.js
var getConnectionDeepLink = (uri, metadata, preference) => {
  if (isAndroid()) {
    return uri;
  }
  const deepLink = getRegularDeepLink(uri, metadata, preference);
  if (!deepLink) {
    return `${deepLink}?uri=${encodeURIComponent(uri)}`;
  }
  const deepLinkUrl = new URL(deepLink);
  const deepLinkParams = new URLSearchParams(deepLinkUrl.search);
  deepLinkParams.set("uri", uri);
  deepLinkUrl.search = deepLinkParams.toString();
  return deepLinkUrl.toString();
};
var getRegularDeepLink = (uri, metadata, preference) => {
  var _a4, _b, _c, _d;
  if (isAndroid()) {
    return uri.split("?")[0];
  }
  const index = isMobile() ? "mobile" : "desktop";
  let origin;
  if (preference === "native") {
    origin = ((_a4 = metadata[index]) === null || _a4 === void 0 ? void 0 : _a4.native) || ((_b = metadata[index]) === null || _b === void 0 ? void 0 : _b.universal);
  } else {
    origin = ((_c = metadata[index]) === null || _c === void 0 ? void 0 : _c.universal) || ((_d = metadata[index]) === null || _d === void 0 ? void 0 : _d.native);
  }
  return origin || "";
};
var getDeepLink = ({ mode, uri = "", metadata, preference }) => {
  switch (mode) {
    case "connection":
      return getConnectionDeepLink(uri, metadata, preference);
    case "regular":
      return getRegularDeepLink(uri, metadata, preference);
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/performPlatformSpecificConnectionMethod.js
var performPlatformSpecificConnectionMethod = (uri, metadata, opts, preference) => {
  var _a4, _b, _c;
  const deepLink = getDeepLink({
    metadata,
    mode: "connection",
    preference,
    uri
  });
  if (isMobile()) {
    window.location.href = deepLink;
  } else {
    if ((_a4 = metadata.desktop) === null || _a4 === void 0 ? void 0 : _a4.native) {
      (_b = opts.onDesktopUri) === null || _b === void 0 ? void 0 : _b.call(opts, deepLink);
    }
    (_c = opts.onDisplayUri) === null || _c === void 0 ? void 0 : _c.call(opts, uri);
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmbeddedConnector/isEmbeddedConnector.js
var isEmbeddedConnector = (connector) => Boolean(connector.isEmbeddedWallet);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isMagicConnector/isMagicConnector.js
var isMagicConnector = (connector) => ["magicemailotp", "magicsocial"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBloctoConnector/isBloctoConnector.js
var isBloctoConnector = (connector) => ["bloctoemail", "bloctoevm", "Blocto"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPasskeyWalletConnector/isPasskeyWalletConnector.js
var isPasskeyWalletConnector = (walletConnector) => Boolean(walletConnector.getWebAuthnAttestation);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isAccountAbstractionConnector/isAccountAbstractionConnector.js
var isAccountAbstractionConnector = (walletConnector) => walletConnector !== void 0 && walletConnector !== null && typeof walletConnector === "object" && "canSponsorTransactionGas" in walletConnector;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBitcoinConnector/isBitcoinConnector.js
var isBitcoinConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.sendBitcoin);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isHardwareWalletConnector/isHardwareWalletConnector.js
var isHardwareWalletConnector = (connector) => "canConnectWithHardwareWallet" in connector;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isHex/isHex.js
var isHex2 = (value) => {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return /^0x[0-9a-fA-F]*$/.test(value);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/eventListenerHandlers.js
var eventListenerHandlers = (walletConnector) => {
  const handleAccountChange = (accounts) => __awaiter5(void 0, void 0, void 0, function* () {
    logger4.debug(`${walletConnector.name} - accountChange`, accounts);
    if (accounts.length === 0) {
      walletConnector.emit("disconnect");
      return;
    }
    walletConnector.emit("accountChange", { accounts });
  });
  const handleChainChange = (chain) => __awaiter5(void 0, void 0, void 0, function* () {
    logger4.debug(`${walletConnector.name} - chainChange`, chain);
    const chainStr = isHex2(chain) ? parseInt(chain, 16).toString() : chain.toString();
    walletConnector.emit("chainChange", {
      chain: chainStr
    });
  });
  const handleDisconnect = (error) => __awaiter5(void 0, void 0, void 0, function* () {
    logger4.debug(`${walletConnector.name} - disconnect`, error);
    if ((error === null || error === void 0 ? void 0 : error.code) === 1013) {
      return;
    }
    walletConnector.emit("disconnect");
  });
  return {
    handleAccountChange,
    handleChainChange,
    handleDisconnect
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPhantomRedirectConnector/isPhantomRedirectConnector.js
var isPhantomRedirectConnector = (connector) => connector.key === "phantom" && connector.extractSignature !== void 0;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getRpcUrlForChain/getRpcUrlForChain.js
var getRpcUrlForChain = ({ networks, chainId }) => {
  var _a4;
  const network = networks.find((network2) => network2.chainId === chainId);
  if (!network) {
    return void 0;
  }
  return ((_a4 = network.privateCustomerRpcUrls) === null || _a4 === void 0 ? void 0 : _a4[0]) || network.rpcUrls[0];
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isCoinbaseMpcWalletConnector/isCoinbaseMpcWalletConnector.js
var isCoinbaseMpcWalletConnector = (connector) => Boolean(connector) && connector.key === "coinbasempc" && connector.generateWallet !== void 0 && connector.changePasscode !== void 0 && connector.exportWalletKeys !== void 0;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isWalletConnectConnector/isWalletConnectConnector.js
var isWalletConnectConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.isWalletConnect);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSendBalanceWalletConnector/isSendBalanceWalletConnector.js
var isSendBalanceWalletConnector = (walletConnector) => "createUiTransaction" in walletConnector && typeof walletConnector.createUiTransaction === "function";

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWalletConnector/isSessionKeyCompatibleWalletConnector.js
var isSessionKeyCompatibleWalletConnector = (walletConnector) => {
  const connector = walletConnector;
  return Boolean(typeof (connector === null || connector === void 0 ? void 0 : connector.isSessionKeyCompatible) === "function" && connector.isSessionKeyCompatible());
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWallet/isSessionKeyCompatibleWallet.js
var isSessionKeyCompatibleWallet = (wallet) => isSessionKeyCompatibleWalletConnector(wallet.connector);

// node_modules/@dynamic-labs/rpc-providers/src/RpcProviders.js
var ProviderChain;
(function(ProviderChain2) {
  ProviderChain2["EVM"] = "evm";
  ProviderChain2["SOLANA"] = "solana";
  ProviderChain2["STARKNET"] = "starknet";
})(ProviderChain || (ProviderChain = {}));

// node_modules/@dynamic-labs/rpc-providers/_virtual/_tslib.js
function __awaiter6(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/rpc-providers/src/ChainRpcProviders.js
var ChainRpcProvidersClass = class _ChainRpcProvidersClass {
  static get client() {
    if (!_ChainRpcProvidersClass.instance) {
      _ChainRpcProvidersClass.instance = new _ChainRpcProvidersClass();
    }
    return _ChainRpcProvidersClass.instance;
  }
  constructor() {
    this.getProvidersMethods = {};
  }
  static getProviders(configurations) {
    Object.values(ProviderChain).forEach((chain) => {
      var _a4, _b;
      if (!_ChainRpcProvidersClass.providers[chain]) {
        const providers = (_b = (_a4 = _ChainRpcProvidersClass.client.getProvidersMethods)[chain]) === null || _b === void 0 ? void 0 : _b.call(_a4, configurations);
        if (providers) {
          Object.assign(_ChainRpcProvidersClass.providers, {
            [chain]: providers
          });
        }
      }
    });
    return _ChainRpcProvidersClass.providers;
  }
  static registerChainProviders(providerChain, fn) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!_ChainRpcProvidersClass.client.getProvidersMethods[providerChain]) {
        Object.assign(_ChainRpcProvidersClass.client.getProvidersMethods, {
          [providerChain]: fn
        });
      }
    });
  }
};
ChainRpcProvidersClass.providers = {};
ChainRpcProvidersClass.wipeInstance = () => {
  ChainRpcProvidersClass.instance = void 0;
  ChainRpcProvidersClass.providers = {};
};
var ChainRpcProviders = ChainRpcProvidersClass;

export {
  parseChainId,
  parseEvmNetworks,
  DynamicError,
  AccountExistsError,
  ChainalysisError,
  SandboxMaximumThresholdReachedError,
  EmailAlreadyExistsError,
  EmailProviderError,
  EmailVerificationError,
  GateBlockedError,
  InsufficientFundsError,
  MissingEnvironmentIdError,
  MissingPublicAddressError,
  NoAccessError,
  SmsVerificationError,
  SocialAccountAlreadyExistsError,
  TransactionGasCannotBeSponsoredError,
  UserHasAccountWithEmailError,
  UsernameAlreadyExistsError,
  WalletNotDeployedError,
  WalletUsedError,
  UserRejectedTransactionError,
  TooManyEmailVerificationsError,
  VerificationDataCollectionError,
  InvalidPhoneNumberError,
  MergeAccountsConfirmationError,
  CustomFieldNotUniqueError,
  CookieInvalidError,
  AccessBlockedError,
  EmbeddedWalletException,
  MfaInvalidOtpError,
  MfaRateLimitedError,
  ExternalAuthError,
  UserRejectedRequestError,
  require_eventemitter3,
  eventemitter3_default,
  LogLevel,
  Logger,
  isMobile,
  isIPhone,
  isIPhone8OrEarlier,
  isIPad,
  isIOS,
  isAndroid,
  isLegacySafari,
  getAndroidVersion,
  require_buffer,
  getProvidersFromWindow,
  sleep,
  FALLBACK_UNDEFINED,
  retryableFn,
  DeferredPromise,
  handleMobileWalletRedirect,
  PlatformService,
  getTLD,
  ceil,
  formatNumberText,
  Eip6963ProviderSingleton,
  runSafe,
  FetchService,
  Configuration,
  AuthModeEnum,
  AuthStorageEnum,
  AuthenticatorTransportProtocol,
  JwtVerifiedCredentialFormatEnum,
  ProviderEnum,
  WalletAddressType,
  EmbeddedWalletVersionEnum,
  HardwareWalletEnum,
  PasswordSourceTypeEnum,
  WalletProviderEnum,
  MfaBackupCodeAcknowledgement,
  CustomFieldType,
  KycFieldType,
  ChainEnum,
  EmbeddedWalletChainEnum,
  EmbeddedWalletProviderEnum,
  EmbeddedWalletAuthType,
  EnvironmentEnum,
  MFADeviceType,
  NextViewEnum,
  SignInProviderEnum,
  SocialSignInProviderEnum,
  SdkViewSectionType,
  SdkViewType,
  UnprocessableEntityErrorCode,
  VerifyRequestFromJSON,
  SDKApi,
  GetAccountBalancesNetworkIdEnum,
  DynamicJwtFromJSON,
  MinifiedDynamicJwtFromJSON,
  SocialOAuthErrorCode,
  Oauth2Service,
  hexToString,
  isHex,
  StorageService,
  createStorageService,
  useWalletBookContext,
  getWalletBookWallet,
  getIconicSpriteUrl,
  BraveIcon,
  ChromeIcon,
  EdgeIcon,
  FirefoxIcon,
  OperaIcon,
  SafariIcon,
  AlgorandIcon,
  BitcoinIcon,
  CosmosIcon,
  EthereumIcon,
  FlowIcon,
  SolanaIcon,
  StarknetIcon,
  SignInWithEmailIcon,
  WalletConnectIcon,
  AppleIcon,
  AndroidIcon,
  DiscordIcon,
  HelpdeskIcon,
  SlackIcon,
  TwitterIcon,
  CaptchaWaveIcon,
  UserProfileIcon,
  findSocialIcon,
  SocialIcon,
  findWalletBookWallet,
  getWalletLinks,
  getWalletPrimaryColor,
  getWalletGroup,
  getWalletBookCdnUrl,
  findWalletGroupOverride,
  isWalletEventSupported,
  useWalletBookCdn,
  WalletIcon,
  WalletBookContextProvider,
  BrandIcon,
  logger4 as logger,
  isSameAddress,
  WalletConnectorBase,
  Wallet,
  ProviderLookup,
  setChainInfoOverrides,
  getChainInfo,
  getChainInfoWithOverrides,
  isEmailOTPWalletConnector,
  isEmailWalletConnector,
  isTurnkeyWalletConnector,
  isSocialWalletConnector,
  getWalletConnectorByKey,
  getDeepLink,
  performPlatformSpecificConnectionMethod,
  isEmbeddedConnector,
  isMagicConnector,
  isBloctoConnector,
  isPasskeyWalletConnector,
  isAccountAbstractionConnector,
  isBitcoinConnector,
  isHardwareWalletConnector,
  eventListenerHandlers,
  isPhantomRedirectConnector,
  getRpcUrlForChain,
  isCoinbaseMpcWalletConnector,
  isWalletConnectConnector,
  isSendBalanceWalletConnector,
  isSessionKeyCompatibleWalletConnector,
  isSessionKeyCompatibleWallet,
  ProviderChain,
  ChainRpcProviders
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=chunk-R3HKWNGI.js.map
