// node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs
function fromHex(hex) {
  if (hex.length % 2 != 0) {
    throw new Error("Hex string length must be multiple of 2");
  }
  const arr = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return arr;
}
function toHex(bytes) {
  let result = "";
  for (let i = 0; i < bytes.length; i++) {
    const hexByte = bytes[i].toString(16);
    result += hexByte.length > 1 ? hexByte : "0" + hexByte;
  }
  return result;
}
function toBase64(bytes, opt_webSafe) {
  const encoded = btoa(
    /* padding */
    toByteString(bytes)
  ).replace(/=/g, "");
  if (opt_webSafe) {
    return encoded.replace(/\+/g, "-").replace(/\//g, "_");
  }
  return encoded;
}
function toByteString(bytes) {
  let str = "";
  for (let i = 0; i < bytes.length; i += 1) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}

// node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs
function getModulus() {
  return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951");
}
function getB() {
  return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
}
function byteArrayToInteger(bytes) {
  return BigInt("0x" + toHex(bytes));
}
function integerToByteArray(i, length) {
  const input = i.toString(16);
  const numHexChars = length * 2;
  let padding = "";
  if (numHexChars < input.length) {
    throw new Error(`cannot pack integer with ${input.length} hex chars into ${length} bytes`);
  } else {
    padding = "0".repeat(numHexChars - input.length);
  }
  return fromHex(padding + input);
}
function testBit(n, i) {
  const m = BigInt(1) << BigInt(i);
  return (n & m) !== BigInt(0);
}
function modPow(b, exp, p) {
  if (exp === BigInt(0)) {
    return BigInt(1);
  }
  let result = b;
  const exponentBitString = exp.toString(2);
  for (let i = 1; i < exponentBitString.length; ++i) {
    result = result * result % p;
    if (exponentBitString[i] === "1") {
      result = result * b % p;
    }
  }
  return result;
}
function modSqrt(x, p) {
  if (p <= BigInt(0)) {
    throw new Error("p must be positive");
  }
  const base = x % p;
  if (testBit(p, 0) && /* istanbul ignore next */
  testBit(p, 1)) {
    const q = p + BigInt(1) >> BigInt(2);
    const squareRoot = modPow(base, q, p);
    if (squareRoot * squareRoot % p !== base) {
      throw new Error("could not find a modular square root");
    }
    return squareRoot;
  }
  throw new Error("unsupported modulus value");
}
function getY(x, lsb) {
  const p = getModulus();
  const a = p - BigInt(3);
  const b = getB();
  const rhs = ((x * x + a) * x + b) % p;
  let y = modSqrt(rhs, p);
  if (lsb !== testBit(y, 0)) {
    y = (p - y) % p;
  }
  return y;
}
function isP256CurvePoint(x, y) {
  const p = getModulus();
  const a = p - BigInt(3);
  const b = getB();
  const rhs = ((x * x + a) * x + b) % p;
  const lhs = y ** BigInt(2) % p;
  return lhs === rhs;
}
function pointDecode(point) {
  const fieldSize = fieldSizeInBytes();
  const compressedLength = fieldSize + 1;
  const uncompressedLength = 2 * fieldSize + 1;
  if (point.length !== compressedLength && point.length !== uncompressedLength) {
    throw new Error("Invalid length: point is not in compressed or uncompressed format");
  }
  if ((point[0] === 2 || point[0] === 3) && point.length == compressedLength) {
    const lsb = point[0] === 3;
    const x = byteArrayToInteger(point.subarray(1, point.length));
    const p = getModulus();
    if (x < BigInt(0) || x >= p) {
      throw new Error("x is out of range");
    }
    const y = getY(x, lsb);
    const result = {
      kty: "EC",
      crv: "P-256",
      x: toBase64(
        integerToByteArray(x, 32),
        /* websafe */
        true
      ),
      y: toBase64(
        integerToByteArray(y, 32),
        /* websafe */
        true
      ),
      ext: true
    };
    return result;
  } else if (point[0] === 4 && point.length == uncompressedLength) {
    const x = byteArrayToInteger(point.subarray(1, fieldSize + 1));
    const y = byteArrayToInteger(point.subarray(fieldSize + 1, 2 * fieldSize + 1));
    const p = getModulus();
    if (x < BigInt(0) || x >= p || y < BigInt(0) || y >= p || !isP256CurvePoint(x, y)) {
      throw new Error("invalid uncompressed x and y coordinates");
    }
    const result = {
      kty: "EC",
      crv: "P-256",
      x: toBase64(
        integerToByteArray(x, 32),
        /* websafe */
        true
      ),
      y: toBase64(
        integerToByteArray(y, 32),
        /* websafe */
        true
      ),
      ext: true
    };
    return result;
  }
  throw new Error("invalid format");
}
function fieldSizeInBytes() {
  return 32;
}

export {
  pointDecode
};
/*! Bundled license information:

@turnkey/api-key-stamper/dist/tink/bytes.mjs:
  (**
   * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
   *
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs:
  (**
   * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
   * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
   * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
   * - Method isP256CurvePoint added to check whether an uncompressed point is valid
   *
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=chunk-3LW4ENDT.js.map
