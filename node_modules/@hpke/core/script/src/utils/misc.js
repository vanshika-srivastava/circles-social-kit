(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCryptoKeyPair = void 0;
    exports.i2Osp = i2Osp;
    exports.concat = concat;
    exports.base64UrlToBytes = base64UrlToBytes;
    /**
     * Checks whetehr the type of input is CryptoKeyPair or not.
     */
    const isCryptoKeyPair = (x) => typeof x === "object" &&
        x !== null &&
        typeof x.privateKey === "object" &&
        typeof x.publicKey === "object";
    exports.isCryptoKeyPair = isCryptoKeyPair;
    /**
     * Converts integer to octet string. I2OSP implementation.
     */
    function i2Osp(n, w) {
        if (w <= 0) {
            throw new Error("i2Osp: too small size");
        }
        if (n >= 256 ** w) {
            throw new Error("i2Osp: too large integer");
        }
        const ret = new Uint8Array(w);
        for (let i = 0; i < w && n; i++) {
            ret[w - (i + 1)] = n % 256;
            n = n >> 8;
        }
        return ret;
    }
    /**
     * Concatenates two Uint8Arrays.
     */
    function concat(a, b) {
        const ret = new Uint8Array(a.length + b.length);
        ret.set(a, 0);
        ret.set(b, a.length);
        return ret;
    }
    /**
     * Decodes Base64Url-encoded data.
     */
    function base64UrlToBytes(v) {
        const base64 = v.replace(/-/g, "+").replace(/_/g, "/");
        const byteString = atob(base64);
        const ret = new Uint8Array(byteString.length);
        for (let i = 0; i < byteString.length; i++) {
            ret[i] = byteString.charCodeAt(i);
        }
        return ret;
    }
});
