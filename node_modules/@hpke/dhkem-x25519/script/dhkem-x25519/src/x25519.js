(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@noble/curves/ed25519", "@hpke/core"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.X25519 = void 0;
    const ed25519_1 = require("@noble/curves/ed25519");
    const core_1 = require("@hpke/core");
    const ALG_NAME = "X25519";
    const EMPTY = new Uint8Array();
    // The key usages for KEM.
    const KEM_USAGES = ["deriveBits"];
    // b"dkp_prk" deno-fmt-ignore
    const LABEL_DKP_PRK = new Uint8Array([
        100, 107, 112, 95, 112, 114, 107,
    ]);
    // b"sk"
    const LABEL_SK = new Uint8Array([115, 107]);
    function base64UrlToBytes(v) {
        const base64 = v.replace(/-/g, "+").replace(/_/g, "/");
        const byteString = atob(base64);
        const ret = new Uint8Array(byteString.length);
        for (let i = 0; i < byteString.length; i++) {
            ret[i] = byteString.charCodeAt(i);
        }
        return ret;
    }
    class X25519 {
        constructor(hkdf) {
            Object.defineProperty(this, "_hkdf", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_nPk", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_nSk", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._hkdf = hkdf;
            this._nPk = 32;
            this._nSk = 32;
        }
        async serializePublicKey(key) {
            try {
                return await this._serializePublicKey(key);
            }
            catch (e) {
                throw new core_1.SerializeError(e);
            }
        }
        async deserializePublicKey(key) {
            try {
                return await this._importRawKey(key, true);
            }
            catch (e) {
                throw new core_1.DeserializeError(e);
            }
        }
        async serializePrivateKey(key) {
            try {
                return await this._serializePrivateKey(key);
            }
            catch (e) {
                throw new core_1.SerializeError(e);
            }
        }
        async deserializePrivateKey(key) {
            try {
                return await this._importRawKey(key, false);
            }
            catch (e) {
                throw new core_1.DeserializeError(e);
            }
        }
        async importKey(format, key, isPublic) {
            try {
                if (format === "raw") {
                    return await this._importRawKey(key, isPublic);
                }
                // jwk
                if (key instanceof ArrayBuffer) {
                    throw new Error("Invalid jwk key format");
                }
                return await this._importJWK(key, isPublic);
            }
            catch (e) {
                throw new core_1.DeserializeError(e);
            }
        }
        async generateKeyPair() {
            try {
                const rawSk = ed25519_1.x25519.utils.randomPrivateKey();
                const sk = new core_1.XCryptoKey(ALG_NAME, rawSk, "private", KEM_USAGES);
                const pk = await this.derivePublicKey(sk);
                return { publicKey: pk, privateKey: sk };
            }
            catch (e) {
                throw new core_1.NotSupportedError(e);
            }
        }
        async deriveKeyPair(ikm) {
            try {
                const dkpPrk = await this._hkdf.labeledExtract(EMPTY, LABEL_DKP_PRK, new Uint8Array(ikm));
                const rawSk = await this._hkdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, this._nSk);
                const sk = new core_1.XCryptoKey(ALG_NAME, new Uint8Array(rawSk), "private", KEM_USAGES);
                return {
                    privateKey: sk,
                    publicKey: await this.derivePublicKey(sk),
                };
            }
            catch (e) {
                throw new core_1.DeriveKeyPairError(e);
            }
        }
        async derivePublicKey(key) {
            try {
                return await this._derivePublicKey(key);
            }
            catch (e) {
                throw new core_1.DeserializeError(e);
            }
        }
        async dh(sk, pk) {
            try {
                return await this._dh(sk, pk);
            }
            catch (e) {
                throw new core_1.SerializeError(e);
            }
        }
        _serializePublicKey(k) {
            return new Promise((resolve) => {
                resolve(k.key.buffer);
            });
        }
        _serializePrivateKey(k) {
            return new Promise((resolve) => {
                resolve(k.key.buffer);
            });
        }
        _importRawKey(key, isPublic) {
            return new Promise((resolve, reject) => {
                if (isPublic && key.byteLength !== this._nPk) {
                    reject(new Error("Invalid length of the key"));
                }
                if (!isPublic && key.byteLength !== this._nSk) {
                    reject(new Error("Invalid length of the key"));
                }
                resolve(new core_1.XCryptoKey(ALG_NAME, new Uint8Array(key), isPublic ? "public" : "private", isPublic ? [] : KEM_USAGES));
            });
        }
        _importJWK(key, isPublic) {
            return new Promise((resolve, reject) => {
                if (typeof key.kty === "undefined" || key.kty !== "OKP") {
                    reject(new Error(`Invalid kty: ${key.kty}`));
                }
                if (typeof key.crv === "undefined" || key.crv !== "X25519") {
                    reject(new Error(`Invalid crv: ${key.crv}`));
                }
                if (isPublic) {
                    if (typeof key.d !== "undefined") {
                        reject(new Error("Invalid key: `d` should not be set"));
                    }
                    if (typeof key.x === "undefined") {
                        reject(new Error("Invalid key: `x` not found"));
                    }
                    resolve(new core_1.XCryptoKey(ALG_NAME, base64UrlToBytes(key.x), "public"));
                }
                else {
                    if (typeof key.d !== "string") {
                        reject(new Error("Invalid key: `d` not found"));
                    }
                    resolve(new core_1.XCryptoKey(ALG_NAME, base64UrlToBytes(key.d), "private", KEM_USAGES));
                }
            });
        }
        _derivePublicKey(k) {
            return new Promise((resolve, reject) => {
                try {
                    const pk = ed25519_1.x25519.getPublicKey(k.key);
                    resolve(new core_1.XCryptoKey(ALG_NAME, pk, "public"));
                }
                catch (e) {
                    reject(e);
                }
            });
        }
        _dh(sk, pk) {
            return new Promise((resolve, reject) => {
                try {
                    resolve(ed25519_1.x25519.getSharedSecret(sk.key, pk.key).buffer);
                }
                catch (e) {
                    reject(e);
                }
            });
        }
    }
    exports.X25519 = X25519;
});
