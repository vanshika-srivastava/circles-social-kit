'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var EthereumProvider = require('@walletconnect/ethereum-provider');
var EventEmitter = require('eventemitter3');
var viem = require('viem');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var walletBook = require('@dynamic-labs/wallet-book');
var utils = require('@dynamic-labs/utils');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var parseIntSafe = require('../utils/parseIntSafe.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var EthereumProvider__default = /*#__PURE__*/_interopDefaultLegacy(EthereumProvider);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

const activeAccountKey = (walletName) => `dynamic-wc2-active-account-${walletName}`;
const sessionTopicKey = (walletName) => `dynamic-wc2-session-topic-${walletName}`;
const swicthedNetworkKey = (walletName) => `dynamic-wc2-switched-network-${walletName}`;
const currentChainKey = (walletName) => `dynamic-wc2-current-chain-${walletName}`;
const ee = new EventEmitter__default["default"]();
class WalletConnect extends ethereumCore.EthWalletConnector {
    constructor(opts) {
        var _a;
        super(opts);
        this.supportedChains = ['EVM', 'ETH'];
        this.connectedChain = 'EVM';
        this.isInitialized = false;
        this.canConnectViaQrCode = true;
        this.isWalletConnect = true;
        this.preferredChains = [];
        // When trying to switch network for MetaMask, the switch promise gets stuck
        // if the switch got trigged once already, so we need to keep track of that
        this._hasSwitchedNetwork = false;
        this.sessionEventHandler = () => { };
        this.sessionDeleteHandler = () => { };
        this.name = opts.walletName;
        this.projectId = opts.projectId;
        this.deepLinkPreference = opts.deepLinkPreference || 'native';
        this.preferredChains = opts.walletConnectPreferredChains || [];
        this.hasSwitchedNetwork =
            (_a = Boolean(localStorage.getItem(this.swicthedNetworkKey))) !== null && _a !== void 0 ? _a : false;
        const lsCurrentChain = localStorage.getItem(this.currentChainKey);
        this.currentChainId = lsCurrentChain
            ? parseIntSafe.parseIntSafe(lsCurrentChain)
            : undefined;
    }
    getMappedChains() {
        return (this.evmNetworks
            // Filters out palm that crashes Trust Wallet
            .filter((network) => network.chainId !== 11297108109)
            .map((network) => `eip155:${network.chainId}`));
    }
    getMappedChainsByPreferredOrder() {
        const allChains = this.getMappedChains();
        const reorderedChains = this.preferredChains.filter((chain) => allChains.includes(chain));
        const remainingChains = allChains.filter((chain) => !this.preferredChains.includes(chain));
        return [...reorderedChains, ...remainingChains].map((chain) => Number(chain.split(':')[1]));
    }
    initConnection() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { provider } = WalletConnect;
            if (!provider) {
                throw new utils.DynamicError('No provider found (init connection)');
            }
            // this means there is already a connection in progress, so don't call connect again
            if (provider === null || provider === void 0 ? void 0 : provider.signer.uri) {
                return;
            }
            provider.connect().catch((e) => {
                walletConnectorCore.logger.error(e);
                ee.emit('walletconnect_connection_failed', e);
            });
        });
    }
    createProvider() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return EthereumProvider__default["default"].init({
                events: ['chainChanged', 'accountsChanged'],
                methods: [],
                optionalChains: this.getMappedChainsByPreferredOrder(),
                optionalMethods: [
                    'eth_chainId',
                    'eth_signTypedData',
                    'eth_signTransaction',
                    'eth_sign',
                    'personal_sign',
                    'eth_sendTransaction',
                    'eth_signTypedData_v4',
                    'wallet_switchEthereumChain',
                    'wallet_addEthereumChain',
                ],
                projectId: this.projectId,
                rpcMap: this.evmNetworkRpcMap(),
                showQrModal: false,
            });
        });
    }
    getWalletClientFromInitializedProvider() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const walletConnect = this.createProvider();
            const walletClient = viem.createWalletClient({
                account: this.getActiveAccount(),
                transport: viem.custom(yield walletConnect),
            });
            return walletClient;
        });
    }
    createInitProviderPromise() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            WalletConnect.provider = yield this.createProvider();
            this.teardownEventListeners();
            this.setupEventListeners();
        });
    }
    // We need to add a gate to this method since we will be calling it asynchronously
    // from different places (such as setShowAuthFlow), which means there's a chance for
    // a race condition to happen where createInitProviderPromise is called multiple times
    initProvider() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { provider } = WalletConnect;
            if (!provider) {
                if (this.initializePromise === undefined) {
                    this.initializePromise = this.createInitProviderPromise();
                }
                yield this.initializePromise;
            }
        });
    }
    refreshSession() {
        var _a, _b, _c, _d, _e;
        if ((_b = (_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.topic) {
            if (localStorage.getItem(this.sessionTopicKey) ===
                ((_d = (_c = WalletConnect.provider) === null || _c === void 0 ? void 0 : _c.session) === null || _d === void 0 ? void 0 : _d.topic)) {
                this.session = WalletConnect.provider.session;
                this.setActiveAccount(((_e = localStorage.getItem(this.activeAccountKey)) !== null && _e !== void 0 ? _e : undefined));
            }
        }
    }
    init() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.initProvider();
            yield this.initConnection();
            this.isInitialized = true;
        });
    }
    get sessionTopicKey() {
        return sessionTopicKey(this.key);
    }
    get activeAccountKey() {
        return activeAccountKey(this.key);
    }
    get swicthedNetworkKey() {
        return swicthedNetworkKey(this.key);
    }
    get currentChainKey() {
        return currentChainKey(this.key);
    }
    set currentChainId(value) {
        this._currentChainId = value;
        if (value) {
            localStorage.setItem(this.currentChainKey, value.toString());
        }
        else {
            localStorage.removeItem(this.currentChainKey);
        }
    }
    get currentChainId() {
        return this._currentChainId;
    }
    set hasSwitchedNetwork(value) {
        this._hasSwitchedNetwork = value;
        if (value) {
            localStorage.setItem(this.swicthedNetworkKey, value.toString());
        }
        else {
            localStorage.removeItem(this.swicthedNetworkKey);
        }
    }
    get hasSwitchedNetwork() {
        return this._hasSwitchedNetwork;
    }
    supportsNetworkSwitching() {
        return true;
    }
    setupEventListeners() {
        if (!WalletConnect.provider) {
            return;
        }
        this.sessionEventHandler = ({ params, }) => {
            walletConnectorCore.logger.debug('session_event was called', { params });
            if (!params || !params.event) {
                walletConnectorCore.logger.debug('session_event was called without params or params.event');
                return;
            }
            const { name, data } = params.event;
            if (name === 'chainChanged') {
                const chainId = parseIntSafe.parseIntSafe(data);
                if (chainId === this.currentChainId) {
                    walletConnectorCore.logger.debug(`ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
                    return;
                }
                if (chainId === undefined) {
                    walletConnectorCore.logger.debug(`received unexpected data for chainChanged: ${data} with type ${typeof data}}`);
                    return;
                }
                this.currentChainId = chainId;
                this.emit('chainChange', { chain: String(chainId) });
                this.hasSwitchedNetwork = true;
                // When a user switches network from their wallet, we need the provider to change network
                // such that any future calls to `getNetwork` will return the correct network
                this.switchNetwork({ networkChainId: chainId });
            }
            else if (name === 'accountsChanged') {
                if (!Array.isArray(data)) {
                    walletConnectorCore.logger.debug(`received unexpected data for accountsChanged: ${data} with type ${typeof data}}`);
                    return;
                }
                // eslint-disable-next-line prefer-destructuring
                const account = data[0].split(':')[2];
                this.setWCActiveAccount(account);
            }
        };
        WalletConnect.provider.on('session_event', this.sessionEventHandler);
        this.sessionDeleteHandler = () => _tslib.__awaiter(this, void 0, void 0, function* () {
            this.endSession();
            this.emit('disconnect');
        });
        WalletConnect.provider.on('session_delete', this.sessionDeleteHandler);
    }
    teardownEventListeners() {
        if (!WalletConnect.provider) {
            return;
        }
        WalletConnect.provider.off('session_event', this.sessionEventHandler);
        WalletConnect.provider.off('session_delete', this.sessionDeleteHandler);
    }
    getWalletClient(chainId) {
        if (!WalletConnect.provider) {
            return;
        }
        return viem.createWalletClient({
            account: this.getActiveAccount(),
            chain: ethereumCore.chainsMap[chainId !== null && chainId !== void 0 ? chainId : String(this.currentChainId)],
            transport: viem.custom(WalletConnect.provider),
        });
    }
    getAddress(opts) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const activeAccount = this.getActiveAccount();
            if (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.address) {
                return activeAccount.address;
            }
            if (!WalletConnect.provider || !((_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.signer.uri)) {
                walletConnectorCore.logger.debug('No WC2 provider found, re-initializing...');
                yield this.endSession();
                yield this.init();
                // sleep 1 s to wait for connect call to finish
                // the connect call isn't await-ed because it only resolves once
                // the connection is established, but we need to wait for it to
                // finish setting up the connection URI and making it available
                // on the provider
                yield utils.sleep(1000);
                if (!WalletConnect.provider || !((_b = WalletConnect.provider) === null || _b === void 0 ? void 0 : _b.signer.uri)) {
                    walletConnectorCore.logger.debug('No WC2 provider found, escaping and throwing error');
                    throw new utils.DynamicError('No provider found');
                }
            }
            const metadata = walletBook.getWalletBookWallet(this.walletBook, this.key, this.walletFallback);
            walletConnectorCore.performPlatformSpecificConnectionMethod(WalletConnect.provider.signer.uri, metadata, {
                onDesktopUri: opts === null || opts === void 0 ? void 0 : opts.onDesktopUri,
                onDisplayUri: opts === null || opts === void 0 ? void 0 : opts.onDisplayUri,
            }, this.deepLinkPreference);
            return new Promise((resolve, reject) => {
                if (!WalletConnect.provider) {
                    reject(new utils.DynamicError('No provider found'));
                    return;
                }
                const onFail = () => {
                    const error = new utils.DynamicError('Connection rejected. Please try again.');
                    error.code = 'connection_rejected';
                    if (WalletConnect.provider) {
                        WalletConnect.provider.signer.uri = undefined;
                        // this is needed for mobile to work when using universal links.
                        // if the user cancels the connection, we need to re-initialize the provider
                        // so that the async work is done ahead of time, before the user tries to connect again,
                        // otherwise they will trigger the iOS bug where they are redirected to the app store
                        this.init();
                    }
                    reject(error);
                    // We must clean up the onConnect and onFail listeners
                    // whenever the connection attempt either succeeds or fails
                    cleanupListeners();
                };
                const onConnect = () => {
                    var _a;
                    const session = (_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.session;
                    if (!session) {
                        reject(new utils.DynamicError('No session found'));
                        return;
                    }
                    this.setSession(session);
                    this.setWCActiveAccount(session.namespaces.eip155.accounts[0].split(':')[2]);
                    this.getNetwork().then((chainId) => {
                        var _a;
                        this.currentChainId = chainId;
                        resolve((_a = this.getActiveAccount()) === null || _a === void 0 ? void 0 : _a.address);
                    });
                    // We must clean up the onConnect and onFail listeners
                    // whenever the connection attempt either succeeds or fails
                    cleanupListeners();
                };
                const cleanupListeners = () => {
                    var _a;
                    ee.off('walletconnect_connection_failed', onFail);
                    (_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.off('connect', onConnect);
                };
                ee.on('walletconnect_connection_failed', onFail);
                WalletConnect.provider.on('connect', onConnect);
            });
        });
    }
    /**
     * WalletConnect V2 will fail to send the sign message request if the chainId
     * is not the same as the one in the session. This method will wait for the
     * chainId to change and then retry the sign message request.
     *
     * Otherwise it will just return the result of the sign message request.
     *
     * @param signMessageFn - Function to sign message with provider
     * @param messageToSign - Message to sign
     * @returns
     */
    waitForSignMessage(signMessageFn, messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const raceConditionPromise = new Promise((resolve, reject) => {
                // Create listener for chain change event
                this.on('chainChange', () => resolve({ success: false }));
                signMessageFn(messageToSign)
                    .then((result) => resolve({ signedMessage: result, success: true }))
                    .catch(reject);
            });
            const signedMessageResult = yield raceConditionPromise;
            if (signedMessageResult.success === false) {
                return signMessageFn(messageToSign);
            }
            return signedMessageResult.signedMessage;
        });
    }
    getDeepLink() {
        var _a;
        if (!this.session) {
            return;
        }
        const metadata = walletBook.getWalletBookWallet(this.walletBook, this.key);
        const deepLink = walletConnectorCore.getDeepLink({
            metadata,
            mode: 'regular',
            preference: this.deepLinkPreference,
            uri: (_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.signer.uri,
        });
        if (!deepLink) {
            return;
        }
        // we need to include the session topic here because it helps the wallet
        // auto redirect back to the dapp after signing
        return `${deepLink}?sessionTopic=${this.session.topic}`;
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.session) {
                throw new utils.DynamicError('no session');
            }
            const deepLink = this.getDeepLink();
            if (utils.isMobile() && deepLink) {
                window.location.href = deepLink;
            }
            const signMessageFn = (messageToSign) => _tslib.__awaiter(this, void 0, void 0, function* () {
                const activeAccount = this.getActiveAccount();
                if (!activeAccount) {
                    return;
                }
                const walletClient = yield this.getWalletClientFromInitializedProvider();
                return walletClient.signMessage({
                    account: activeAccount,
                    message: messageToSign,
                });
            });
            const response = yield this.waitForSignMessage(signMessageFn, messageToSign);
            return response;
        });
    }
    clearActiveAccount() {
        localStorage.removeItem(this.activeAccountKey);
        this.setActiveAccount(undefined);
    }
    clearSession() {
        localStorage.removeItem(this.sessionTopicKey);
        this.session = undefined;
    }
    setWCActiveAccount(account) {
        localStorage.setItem(this.activeAccountKey, account);
        this.setActiveAccount(account);
        this.emit('accountChange', { accounts: [account] });
    }
    setSession(session) {
        localStorage.setItem(this.sessionTopicKey, session.topic);
        this.session = session;
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            this.clearActiveAccount();
            this.clearSession();
            this.hasSwitchedNetwork = false;
            this.currentChainId = undefined;
            if (!((_a = WalletConnect.provider) === null || _a === void 0 ? void 0 : _a.session)) {
                return;
            }
            try {
                yield WalletConnect.provider.disconnect();
                // We must unset provider on logout so that a new session can be established
                // If we don't then the provider will still have the old session and will hang
                WalletConnect.provider = undefined;
            }
            catch (e) {
                walletConnectorCore.logger.debug(e);
            }
        });
    }
    getNetwork() {
        const _super = Object.create(null, {
            getNetwork: { get: () => super.getNetwork }
        });
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.currentChainId) {
                return this.currentChainId;
            }
            yield this.initProvider();
            return _super.getNetwork.call(this);
        });
    }
    providerSwitchNetwork(_a) {
        const _super = Object.create(null, {
            providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
        });
        return _tslib.__awaiter(this, arguments, void 0, function* ({ network, }) {
            const supportedNetworks = yield this.getSupportedNetworks();
            if (!(supportedNetworks === null || supportedNetworks === void 0 ? void 0 : supportedNetworks.includes(network.chainId.toString()))) {
                const error = new utils.DynamicError('Network switching is not available at this time. The user should manually switch network in their wallet');
                error.code = 'network_switching_only_available_in_wallet';
                throw error;
            }
            const currentNetworkId = yield this.getNetwork();
            if (currentNetworkId && currentNetworkId === network.chainId) {
                return;
            }
            if (this.switchNetworkOnlyFromWallet) {
                throw new utils.DynamicError('Network switching is only supported through the wallet');
            }
            if (!this.supportsNetworkSwitching()) {
                throw new utils.DynamicError('Network switching not supported');
            }
            const walletClient = yield this.getWalletClientFromInitializedProvider();
            if (this.isMetaMask()) {
                const deepLink = this.getDeepLink();
                if (deepLink) {
                    window.location.href = deepLink;
                }
            }
            yield _super.providerSwitchNetwork.call(this, { network, provider: walletClient });
            this.currentChainId = network.chainId;
            this.hasSwitchedNetwork = true;
            this.emit('chainChange', { chain: String(network.chainId) });
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized === false) {
                yield this.initProvider();
                this.refreshSession();
                this.isInitialized = true;
            }
            const activeAccount = this.getActiveAccount();
            if (!(activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.address)) {
                return [];
            }
            return [activeAccount.address];
        });
    }
    isMetaMask() {
        var _a, _b, _c, _d, _e;
        return ((_e = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.peer) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.toLowerCase().startsWith('metamask')) !== null && _e !== void 0 ? _e : false);
    }
    getSupportedNetworks() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            yield this.initProvider();
            this.refreshSession();
            if (this.isMetaMask()) {
                if (this.hasSwitchedNetwork) {
                    return [String(this.currentChainId)];
                }
                return this.evmNetworks.map((network) => network.chainId.toString());
            }
            if (!this.session) {
                return [];
            }
            const chains = [];
            // Some wallet (i.e ZenGo) use namespaces.account to list supported chains
            // while others use keys within the namespaces object
            Object.keys(this.session.namespaces).forEach((key) => {
                if (key.startsWith('eip155:')) {
                    chains.push(key.split(':')[1]);
                }
            });
            (_a = this.session.namespaces.eip155) === null || _a === void 0 ? void 0 : _a.accounts.forEach((account) => chains.push(account.split(':')[1]));
            return chains.length
                ? chains
                : this.evmNetworks.map((network) => network.chainId.toString());
        });
    }
}

exports.WalletConnect = WalletConnect;
