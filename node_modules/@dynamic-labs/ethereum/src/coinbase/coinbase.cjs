'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var viem = require('viem');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var helpers = require('./helpers.cjs');

class Coinbase extends ethereumCore.EthWalletConnector {
    constructor(_a) {
        var { appName, appLogoUrl, evmNetworks, coinbaseWalletPreference } = _a, props = _tslib.__rest(_a, ["appName", "appLogoUrl", "evmNetworks", "coinbaseWalletPreference"]);
        super(Object.assign({ evmNetworks }, props));
        this.name = 'Coinbase';
        this.overrideKey = 'coinbase';
        this.supportedChains = ['EVM', 'ETH'];
        this.connectedChain = 'EVM';
        this.canConnectViaQrCode = false;
        this.canConnectViaCustodialService = !this.isInstalledOnBrowser();
        this.coinbaseProviderOpts = {
            appLogoUrl: appLogoUrl,
            appName: appName,
            evmNetworks: evmNetworks,
            walletPreference: coinbaseWalletPreference,
        };
    }
    get coinbaseProvider() {
        return helpers.getCoinbaseProvider(this.coinbaseProviderOpts);
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const accounts = yield this.coinbaseProvider.request({
                    method: 'eth_accounts',
                });
                if (accounts[0]) {
                    this.setActiveAccount(accounts[0]);
                }
                return accounts;
            }
            catch (error) {
                return [];
            }
        });
    }
    isInstalledOnBrowser() {
        var _a;
        return Boolean((_a = window === null || window === void 0 ? void 0 : window.coinbaseWalletExtension) === null || _a === void 0 ? void 0 : _a.isCoinbaseWallet);
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const [address] = yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            });
            this.setActiveAccount(address);
            return address;
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const [address] = yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            });
            try {
                return yield this.coinbaseProvider.request({
                    method: 'personal_sign',
                    params: [viem.toHex(viem.toBytes(messageToSign)), address.toLowerCase()],
                });
            }
            catch (err) {
                return undefined;
            }
        });
    }
    setupEventListeners() {
        const { handleAccountChange, handleChainChange, handleDisconnect } = walletConnectorCore.eventListenerHandlers(this);
        this.coinbaseProvider.on('accountsChanged', handleAccountChange);
        this.coinbaseProvider.on('chainChanged', handleChainChange);
        this.coinbaseProvider.on('disconnect', handleDisconnect);
        this.teardownEventListeners = () => {
            this.coinbaseProvider.removeListener('accountsChanged', handleAccountChange);
            this.coinbaseProvider.removeListener('chainChanged', handleChainChange);
            this.coinbaseProvider.removeListener('disconnect', handleDisconnect);
        };
    }
    getWalletClient(chainId) {
        return viem.createWalletClient({
            account: this.getActiveAccount(),
            chain: chainId ? ethereumCore.chainsMap[chainId] : undefined,
            transport: viem.custom(this.coinbaseProvider),
        });
    }
}

exports.Coinbase = Coinbase;
