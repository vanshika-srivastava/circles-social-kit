'use client'
'use strict';

var _tslib = require('../../_virtual/_tslib.cjs');
var walletBook = require('@dynamic-labs/wallet-book');
var utils = require('@dynamic-labs/utils');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var ethProviderHelper = require('../ethProviderHelper.cjs');
var walletConnect = require('../walletConnect/walletConnect.cjs');

class InjectedWalletBase extends ethereumCore.EthWalletConnector {
    constructor() {
        super(...arguments);
        this.supportedChains = ['ETH', 'EVM'];
        this.connectedChain = 'EVM';
        this.walletConnectorFallback = false;
    }
    getEthProviderHelper() {
        if (!this.wallet) {
            // changing this to findWalletBookWallet so it returns undefined if not found which
            // allows the getEthProviderHelper to return undefined if the wallet is not installed
            this.wallet = walletBook.findWalletBookWallet(this.walletBook, this.key);
        }
        if (this.wallet && !this.ethProviderHelper) {
            this.ethProviderHelper = new ethProviderHelper.EthProviderHelper(this.wallet, this);
        }
        // this.ethProviderHelper is undefined if the wallet is not installed or found in walletbook
        return this.ethProviderHelper;
    }
    getMobileOrInstalledWallet() {
        var _a, _b;
        if (!this.wallet) {
            this.wallet = walletBook.findWalletBookWallet(this.walletBook, this.key);
        }
        if (this.isInstalledOnBrowser()) {
            return this;
        }
        // this is to handle the case where the user is in a webview.
        // when the user is in a webview, customers should set the deepLinkPreference prop to universal,
        // in which case this condition will be false, and the SDK will use WalletConnect (if available)
        if (((_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.mobile) === null || _b === void 0 ? void 0 : _b.inAppBrowser) &&
            this.mobileExperience === 'in-app-browser' &&
            utils.isMobile()) {
            return this;
        }
        // this is the case where the wallet is not installed on the browser and
        // it does not support WalletConnect. in this case, the SDK will instruct
        // the user to download the wallet extension
        if (!this.walletConnectorFallback) {
            return this;
        }
        return new walletConnect.WalletConnect(Object.assign(Object.assign({}, this.constructorProps), { walletName: this.name }));
    }
    setupEventListeners() {
        const provider = this.getWalletClient();
        if (!provider)
            return;
        const ethProviderHelper = this.getEthProviderHelper();
        if (!ethProviderHelper)
            return;
        const { tearDownEventListeners } = ethProviderHelper._setupEventListeners(this);
        this.teardownEventListeners = tearDownEventListeners;
    }
    getWalletClient(chainId) {
        var _a;
        return (_a = this.getEthProviderHelper()) === null || _a === void 0 ? void 0 : _a.findWalletClient(chainId);
    }
    isInstalledOnBrowser() {
        var _a;
        return ((_a = this.getEthProviderHelper()) === null || _a === void 0 ? void 0 : _a.findProvider()) !== undefined;
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.getEthProviderHelper()) === null || _a === void 0 ? void 0 : _a.getAddress();
        });
    }
    connect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.getAddress();
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.getEthProviderHelper()) === null || _a === void 0 ? void 0 : _a.signMessage(messageToSign);
        });
    }
    proveOwnership(address, messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            return this.signMessage(messageToSign);
        });
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            // nothing to do on browser-based metamask
            return;
        });
    }
    providerSwitchNetwork(_a) {
        const _super = Object.create(null, {
            providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
        });
        return _tslib.__awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            return _super.providerSwitchNetwork.call(this, { network, provider });
        });
    }
}

module.exports = InjectedWalletBase;
