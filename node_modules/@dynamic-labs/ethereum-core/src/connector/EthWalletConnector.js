'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { getAddress, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { parseEvmNetworks, retryableFn, FALLBACK_UNDEFINED, DynamicError, UserRejectedRequestError } from '@dynamic-labs/utils';
import { WalletConnectorBase, logger } from '@dynamic-labs/wallet-connector-core';
import '../utils/logger.js';
import '../utils/viem/estimateL1Fee/opStack/estimateL1Fee.js';
import { chainsMap } from '../utils/viem/chainsMap/chainsMap.js';
import { createViemUiTransaction } from '../utils/viem/createViemUiTransaction/createViemUiTransaction.js';
import { getOrMapViemChain } from '../utils/viem/getOrMapViemChain/getOrMapViemChain.js';
import { findEvmNetwork } from '../utils/findEvmNetwork/findEvmNetwork.js';
import { getNameservice } from '../utils/getNameservice/getNameservice.js';
import { EthereumWallet } from '../wallet/EthereumWallet.js';

class EthWalletConnector extends WalletConnectorBase {
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const networkId = (_a = (yield this.getNetwork())) !== null && _a !== void 0 ? _a : 1;
            if (this.evmNetworks.length === 0) {
                return undefined;
            }
            const configurations = {
                cosmos: [],
                evm: this.evmNetworks,
                solana: [],
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    constructor(props) {
        var _a;
        super(props);
        this.ChainWallet = EthereumWallet;
        this.evmNetworkRpcMap = () => this.evmNetworks.reduce((acc, network) => {
            var _a;
            [acc[network.chainId]] = ((_a = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a.length)
                ? network.privateCustomerRpcUrls
                : network.rpcUrls;
            return acc;
        }, {});
        this.evmNetworks = parseEvmNetworks(props.evmNetworks);
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerEvmProviders();
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!this.supportsNetworkSwitching || !provider) {
                return Promise.resolve(undefined);
            }
            const chainId = yield retryableFn(provider.getChainId, {
                fallbackValue: FALLBACK_UNDEFINED,
                /**
                 * The timeout is set to 1 second because the getChainId method
                 * takes around 500ms to resolve on Brave. If the timeout is not set
                 * it will use 100ms by default and the method will fail.
                 * QNTM-815
                 */
                timeoutMs: 1000,
            });
            this.setActiveChain(chainsMap[chainId]);
            return chainId;
        });
    }
    getNameService(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcProvider = yield this.getPublicClient();
            if (!rpcProvider) {
                return;
            }
            return getNameservice({ address, rpcProvider });
        });
    }
    isTestnet() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            return (_c = (_b = (_a = (yield this.getPublicClient())) === null || _a === void 0 ? void 0 : _a.chain) === null || _b === void 0 ? void 0 : _b.testnet) !== null && _c !== void 0 ? _c : false;
        });
    }
    parseAddress(address) {
        try {
            // Ensures the address follows the EIP55 format.
            // see: https://eips.ethereum.org/EIPS/eip-55
            return getAddress(address);
        }
        catch (err) {
            logger.debug(`Failed to parse EVM address into EIP55 format: error getting checksum, returning default ${address}`, err);
        }
        return address;
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWalletClient();
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getPublicClient();
            const result = yield (client === null || client === void 0 ? void 0 : client.getBalance({
                address: address,
            }));
            if (!result && result !== BigInt(0))
                return;
            return formatEther(result);
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkName, networkChainId, }) {
            const network = findEvmNetwork({
                chainId: networkChainId,
                name: networkName,
                networks: this.evmNetworks,
            });
            if (!network) {
                throw new DynamicError(`Could not find network mapping for chain ${networkName ? networkName : networkChainId}`);
            }
            if (!this.supportsNetworkSwitching()) {
                throw new DynamicError('Network switching is not supported');
            }
            const provider = this.getWalletClient();
            if (!provider) {
                throw new DynamicError('Provider not found');
            }
            return this.providerSwitchNetwork({ network, provider });
        });
    }
    chooseAccountsToConnect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const provider = this.getWalletClient();
            if (!provider)
                return [];
            try {
                const result = yield provider.requestPermissions({ eth_accounts: {} });
                logger.debug('chooseAccountsToConnect - requestPermissions result', result);
                // this should return the connected addresses for MM
                const addresses = (_c = (_b = (_a = result === null || result === void 0 ? void 0 : result.find((r) => r.parentCapability === 'eth_accounts')) === null || _a === void 0 ? void 0 : _a.caveats) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.value;
                if (typeof addresses === 'string') {
                    return [addresses];
                }
                if (Array.isArray(addresses)) {
                    return addresses;
                }
                return [];
            }
            catch (error) {
                logger.debug('chooseAccountsToConnect - error', error);
                // might fail if method is not supported, but just throw if user rejected
                if (error.code === 4001) {
                    throw new UserRejectedRequestError();
                }
            }
            return [];
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!provider)
                return [];
            const addresses = yield retryableFn(provider.getAddresses, {
                fallbackValue: [],
                timeoutMs: 500,
            });
            if (addresses.length) {
                this.setActiveAccount(addresses[0]);
            }
            return addresses;
        });
    }
    providerSwitchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b, _c, _d, _e;
            const { chainId } = network;
            const currentNetworkId = yield this.getNetwork();
            if (currentNetworkId && currentNetworkId === chainId) {
                return;
            }
            try {
                if (!this.supportsNetworkSwitching()) {
                    throw new DynamicError('Network switching is not supported');
                }
                const viemChain = getOrMapViemChain(network);
                yield provider.switchChain(viemChain);
                if (this.key === 'magiceden') {
                    const newChainId = yield provider.getChainId();
                    this.emit('chainChange', { chain: newChainId.toString() });
                }
                else {
                    this.setActiveChain(viemChain);
                }
            }
            catch (error) {
                // we need to check for unrecognized chain error first because it also contains 'rejected' in message
                if (error.code === 4902 ||
                    ((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('Unrecognized chain')) ||
                    // https://github.com/MetaMask/metamask-mobile/issues/3312#issuecomment-1065923294
                    ((_d = (_c = error.data) === null || _c === void 0 ? void 0 : _c.orginalError) === null || _d === void 0 ? void 0 : _d.code) === 4902) {
                    // error code indicates the chain has not been added yet
                    // https://docs.metamask.io/guide/rpc-api.html#usage-with-wallet-switchethereumchain
                    return this.providerAddNetwork({ network, provider });
                }
                else if (((_e = error.message) === null || _e === void 0 ? void 0 : _e.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to switch network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    providerAddNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b;
            try {
                return yield provider.addChain({ chain: getOrMapViemChain(network) });
            }
            catch (error) {
                if (((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to add network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    setActiveAccount(account) {
        this.activeAccount = account ? toAccount(account) : undefined;
    }
    getActiveAccount() {
        return this.activeAccount;
    }
    setActiveChain(chain) {
        this.activeChain = chain;
    }
    getActiveChain() {
        return this.activeChain;
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = yield this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return createViemUiTransaction({
                from,
                publicClient,
                walletClient,
            });
        });
    }
    confirmTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicClient = yield this.getPublicClient();
            if (!publicClient) {
                throw new DynamicError('No public client available');
            }
            // The number of confirmations (blocks that have passed) to wait before resolving.
            const confirmations = 3;
            return publicClient.waitForTransactionReceipt({
                confirmations,
                hash: txHash,
            });
        });
    }
}

export { EthWalletConnector };
