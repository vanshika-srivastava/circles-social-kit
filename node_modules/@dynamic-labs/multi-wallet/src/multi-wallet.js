'use client'
import { logger, isEmbeddedConnector } from '@dynamic-labs/wallet-connector-core';
import { getWalletBookWallet, getWalletLinks } from '@dynamic-labs/wallet-book';
import { isMobile, isIPad, isIPhone } from '@dynamic-labs/utils';
import { ProviderEnum } from '@dynamic-labs/sdk-api-core';
import { getApiProviders } from './utils/getApiProviders.js';

let wallets = [];
const defaultWalletUiUtils = {
    createPassword: () => {
        throw Error('createPassword not implemented');
    },
    disabledConfirmationOnce: () => {
        throw Error('disabledConfirmationOnce, not implemented');
    },
    enterPassword: () => {
        throw Error('enterPassword not implemented');
    },
    sendTransaction: () => {
        throw Error('requestSendTransactionConfirmation not implemented');
    },
    signMessage: () => {
        throw Error('signMessage not implemented');
    },
    syncWallet: () => {
        throw Error('syncWallet not implemented');
    },
};
const getSupportedWallets = (args) => {
    const { appLogoUrl = '', appName = '', coinbaseWalletPreference, chainRpcProviders, deepLinkPreference, flowNetwork, mobileExperience = 'in-app-browser', networkConfigurations = { cosmos: [], evm: [], solana: [], starknet: [] }, settings, skipMemo = false, walletConnectProjectId = '', walletConnectorsProp, walletUiUtils = undefined, walletBook, walletConnectPreferredChains, } = args;
    if (!skipMemo && wallets.length > 0) {
        return wallets;
    }
    const evmNetworkConfigs = (networkConfigurations === null || networkConfigurations === void 0 ? void 0 : networkConfigurations.evm) || [];
    const solanaNetworkConfigs = (networkConfigurations === null || networkConfigurations === void 0 ? void 0 : networkConfigurations.solana) || [];
    const cosmosNetworkConfigs = (networkConfigurations === null || networkConfigurations === void 0 ? void 0 : networkConfigurations.cosmos) || [];
    const starknetNetworkConfigs = (networkConfigurations === null || networkConfigurations === void 0 ? void 0 : networkConfigurations.starknet) || [];
    const apiProviders = getApiProviders(getEnabledProviders(settings.providers));
    const opts = {
        apiProviders,
        appLogoUrl,
        appName,
        chainRpcProviders,
        coinbaseWalletPreference,
        cosmosNetworks: cosmosNetworkConfigs,
        deepLinkPreference,
        evmNetworks: evmNetworkConfigs,
        flowNetwork,
        mobileExperience,
        projectId: walletConnectProjectId,
        settings,
        solNetworks: solanaNetworkConfigs,
        starknetNetworks: starknetNetworkConfigs,
        walletBook,
        walletConnectPreferredChains,
        walletUiUtils: walletUiUtils || defaultWalletUiUtils,
    };
    const allWallets = walletConnectorsProp
        .map((walletConnector) => walletConnector(opts))
        .flat()
        .map((wallet) => {
        try {
            // This may contain third party code so we must be ready for anything
            return new wallet(opts);
        }
        catch (error) {
            logger.error(`Failed to construct wallet ${wallet.name}`, error);
            return undefined;
        }
    })
        .filter((wallet) => wallet === null || wallet === void 0 ? void 0 : wallet.filter())
        .map((wallet) => wallet.getMobileOrInstalledWallet());
    // Memoize the wallets
    const filteredWallets = filterWalletsForPlatform(walletBook, allWallets);
    wallets = applyLinksOverrides(walletBook, filteredWallets);
    return wallets;
};
const applyLinksOverrides = (walletBook, wallets) => wallets.map((wallet) => {
    const metadata = getWalletBookWallet(walletBook, wallet.key, wallet.walletFallback);
    if (metadata.switchNetworkOnlyFromWallet !== undefined) {
        wallet.switchNetworkOnlyFromWallet = metadata.switchNetworkOnlyFromWallet;
    }
    return wallet;
});
const filterWalletsForPlatform = (walletBook, wallets) => wallets.filter((wallet) => {
    const metadata = getWalletBookWallet(walletBook, wallet.key, wallet.walletFallback);
    if (wallet.isInstalledOnBrowser()) {
        return true;
    }
    else if (isEmbeddedConnector(wallet)) {
        return true;
    }
    else if (metadata.showOnlyIfInstalled) {
        return false;
    }
    else if (!isMobile()) {
        return true;
    }
    else {
        return handleMobileWalletFilter(walletBook, wallet.key, metadata);
    }
});
const handleMobileWalletFilter = (walletBook, walletKey, metadata) => {
    if (!metadata.mobile)
        return false;
    /**
     * WalletConnect provides a "universal" and "native" deep link. They recommend using
     * the universal deep link over the native one due to UX differences, and our current
     * implementation uses only universal. This means we need to filter for wallets that
     * have a universal deep link available.
     */
    const hasWalletConnectLink = Boolean(metadata.mobile.universal) || Boolean(metadata.mobile.native);
    const isWalletConnectWallet = metadata.walletConnect !== undefined;
    if (isIPad() || isIPhone()) {
        const hasIOSLink = Boolean(getWalletLinks(walletBook, walletKey).ios);
        return !isWalletConnectWallet
            ? hasIOSLink
            : hasIOSLink && hasWalletConnectLink;
    }
    else {
        const hasAndroidLink = Boolean(getWalletLinks(walletBook, walletKey).android);
        return !isWalletConnectWallet
            ? hasAndroidLink
            : hasAndroidLink && hasWalletConnectLink;
    }
};
const chainStringToChains = {
    'eip155:1': ['ETH', 'EVM'],
    'flow:mainnet': ['FLOW'],
};
const getSupportedChainsForWalletConnector = (walletBook, walletConnector) => {
    var _a;
    const metadata = getWalletBookWallet(walletBook, walletConnector.key, walletConnector.walletFallback);
    /**
     * chains could contain multiple eth networks eg
     *  "eip155:1",
     *  "eip155:10",
     *  "eip155:56",
     *  "eip155:100",
     *
     * so we will use a set to ensure uniqueness
     */
    const chainSet = new Set();
    const chainStringList = (_a = metadata.chains) !== null && _a !== void 0 ? _a : [];
    chainStringList.forEach((chainString) => {
        const chains = chainStringToChains[chainString];
        chains === null || chains === void 0 ? void 0 : chains.forEach((chain) => {
            chainSet.add(chain);
        });
    });
    walletConnector.supportedChains.forEach((chain) => {
        chainSet.add(chain);
    });
    return [...chainSet];
};
const getEnabledWallets = (props) => {
    const supportedWallets = getSupportedWallets(props.getSupportedWalletOpts);
    const allEnabledWallets = supportedWallets.filter((wallet) => props.enabledChains.some((chain) => getSupportedChainsForWalletConnector(props.getSupportedWalletOpts.walletBook, wallet).includes(chain)) || wallet.key === 'magiclink');
    return allEnabledWallets;
};
// get list of providers enabled in the sense that we should have wallet connectors for them
// note: magic and turnkey are considered enabled when a provider exists (for magic, a providerProjectId exists)
const getEnabledProviders = (providers) => {
    var _a;
    return (_a = providers === null || providers === void 0 ? void 0 : providers.filter((provider) => Boolean(provider.enabledAt) ||
        (provider.provider === ProviderEnum.MagicLink &&
            Boolean(provider.providerProjectId)) ||
        provider.provider === ProviderEnum.Turnkey)) !== null && _a !== void 0 ? _a : [];
};

export { getEnabledProviders, getEnabledWallets, getSupportedChainsForWalletConnector, getSupportedWallets };
