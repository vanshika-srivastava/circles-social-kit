'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';
import { TurnkeyClient } from '@turnkey/http';
import { IframeStamper } from '@turnkey/iframe-stamper';
import { createAccount } from '@turnkey/viem';
import { WebauthnStamper } from '@turnkey/webauthn-stamper';
import { http, createPublicClient, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { parseEvmNetworks, getTLD, PlatformService, DynamicError } from '@dynamic-labs/utils';
import { EthereumWallet, createWalletClientWithUiConfirmation, getOrMapViemChain, createViemUiTransaction } from '@dynamic-labs/ethereum-core';
import { getRpcUrlForChain, isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { TurnkeyWalletConnectorBase, findTurnkeyVerifiedCredentialsWithSmartWalletRef, PasskeyService, TURNKEY_API_BASE_URL, logger, TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS } from '@dynamic-labs/embedded-wallet';

class TurnkeyEVMWalletConnector extends TurnkeyWalletConnectorBase {
    constructor(nameAndKey, props) {
        var _a;
        super(nameAndKey, props);
        this.walletFallback = {
            brand: {
                alt: 'Turnkey Wallet',
                spriteId: 'turnkey',
            },
            name: 'Turnkey HD',
        };
        // Public fields
        this.ChainWallet = EthereumWallet;
        this.connectedChain = 'EVM';
        this.supportedChains = ['ETH', 'EVM'];
        this.verifiedCredentialChain = 'eip155';
        this.stampCreateWalletAccountRequest = (_b) => __awaiter(this, [_b], void 0, function* ({ request, }) {
            yield this.createOrRestoreSession();
            const turnkeyClient = this.getTurnkeyClient();
            return turnkeyClient.stampCreateWalletAccounts(request);
        });
        this.evmNetworks = parseEvmNetworks(props.evmNetworks);
        this.walletUiUtils = props.walletUiUtils;
        this._turnkeyAccount = undefined;
        this._selectedChainId = this.getLastUsedChainId();
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerEvmProviders();
        this.__turnkeyClient = this.getTurnkeyClient();
    }
    getLastUsedChainId() {
        var _a;
        if (this.lastUsedChainId) {
            return this.lastUsedChainId;
        }
        if (!((_a = this.evmNetworks) === null || _a === void 0 ? void 0 : _a.length)) {
            return undefined;
        }
        return this.evmNetworks[0].chainId;
    }
    // Public methods
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = (yield this.getSigner())) === null || _a === void 0 ? void 0 : _a.getChainId();
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            this.lastUsedChainId = networkChainId;
            this._selectedChainId = networkChainId;
            yield this.refreshTurnkeyAccount();
            this.emit('chainChange', {
                chain: networkChainId.toString(),
            });
        });
    }
    setVerifiedCredentials(verifiedCredentials) {
        const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentialsWithSmartWalletRef(verifiedCredentials, 'eip155');
        const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
        const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !==
            JSON.stringify(turnkeyVerifiedCredentials);
        if (!didTurnkeyVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = turnkeyVerifiedCredential;
        this.verifiedCredentials = turnkeyVerifiedCredentials;
        this.refreshTurnkeyAccount();
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const activeAddress = ((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address) || '';
            const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (!isWalletActive) {
                const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc) => (vc === null || vc === void 0 ? void 0 : vc.address) === expectedAddress);
                if (!targetActiveAccount) {
                    throw new DynamicError('Account not found');
                }
                this.verifiedCredential = targetActiveAccount;
                this.refreshTurnkeyAccount();
            }
        });
    }
    getRpcUrl() {
        const chain = this._selectedChainId;
        return getRpcUrlForChain({
            chainId: chain,
            networks: this.evmNetworks,
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcUrl = this.getRpcUrl();
            if (!rpcUrl) {
                return undefined;
            }
            const client = createPublicClient({
                transport: http(rpcUrl),
            });
            const balance = yield client.getBalance({
                address: address,
            });
            return formatEther(balance);
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = yield this.getSigner();
            if (!signer) {
                throw new Error('Signer not found');
            }
            return signer.signMessage({
                message: messageToSign,
            });
        });
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.evmNetworks.length === 0) {
                return undefined;
            }
            const networkId = (_a = (yield this.getNetwork())) !== null && _a !== void 0 ? _a : 1;
            const configurations = {
                cosmos: [],
                evm: this.evmNetworks,
                solana: [],
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getTurnkeyAccount();
            return this.getWalletClient();
        });
    }
    getTurnkeyClient() {
        var _a;
        let rpId = getTLD();
        if (!rpId) {
            rpId = PlatformService.getHostname();
        }
        const passkeyStamper = PasskeyService.createWebauthnStamper({
            rpId,
        });
        const apiKeyStamper = TurnkeyWalletConnectorBase === null || TurnkeyWalletConnectorBase === void 0 ? void 0 : TurnkeyWalletConnectorBase.apiKeyStamper;
        const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
        this.__turnkeyClient =
            (_a = this.getAuthenticatorHandler().client) !== null && _a !== void 0 ? _a : new TurnkeyClient({
                baseUrl: TURNKEY_API_BASE_URL,
            }, stamper);
        return this.__turnkeyClient;
    }
    // decides in runtime which stamper to use and creates the corresponding account
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (this.isSessionKeyCompatible() &&
                ((_a = this.__turnkeyClient) === null || _a === void 0 ? void 0 : _a.stamper) instanceof ApiKeyStamper) {
                return this._turnkeyAccount;
            }
            if ((this.getAuthenticatorHandler().recoveryType === 'passkey' &&
                ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper) ||
                (this.getAuthenticatorHandler().recoveryType === 'email' &&
                    ((_c = this.__turnkeyClient) === null || _c === void 0 ? void 0 : _c.stamper) instanceof WebauthnStamper) ||
                this.__turnkeyClient !== this.getAuthenticatorHandler().client) {
                yield this.refreshTurnkeyAccount();
            }
            return this._turnkeyAccount;
        });
    }
    getWalletClient() {
        const rpcUrl = this.networkRpcUrl;
        const account = this._turnkeyAccount;
        const evmNetwork = this.currentEvmNetwork;
        if (!account || !rpcUrl || !evmNetwork) {
            return undefined;
        }
        return createWalletClientWithUiConfirmation({
            account: this.getAccount.bind(this),
            address: this.turnkeyAddress,
            chain: getOrMapViemChain(evmNetwork),
            transport: http(rpcUrl),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this.walletUiUtils,
        });
    }
    // Private methods
    get currentChainId() {
        var _a, _b, _c;
        return (_a = this._selectedChainId) !== null && _a !== void 0 ? _a : (_c = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.chainId;
    }
    get lastUsedChainId() {
        const lastUsedChainIdLS = localStorage.getItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
        if (!lastUsedChainIdLS)
            return undefined;
        try {
            const chainId = parseInt(lastUsedChainIdLS);
            if (isNaN(chainId)) {
                return undefined;
            }
            const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
            if (!isChainCurrentlyEnabled) {
                const lastUsedChainId = this.evmNetworks[0].chainId;
                this.lastUsedChainId = lastUsedChainId;
                return this.lastUsedChainId;
            }
            return chainId;
        }
        catch (err) {
            logger.error(err);
            return undefined;
        }
    }
    set lastUsedChainId(chainId) {
        if (chainId === undefined) {
            localStorage.removeItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
        }
        else {
            localStorage.setItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey, chainId.toString());
        }
    }
    get networkRpcUrl() {
        const chainId = this.currentChainId;
        const evmNetwork = this.evmNetworks.find((network) => network.chainId === chainId);
        if (!evmNetwork) {
            return undefined;
        }
        const rpcUrl = getRpcUrlForChain({
            chainId: chainId,
            networks: this.evmNetworks,
        });
        return rpcUrl;
    }
    get currentEvmNetwork() {
        const chainId = this.currentChainId;
        return this.evmNetworks.find((network) => network.chainId === chainId);
    }
    internalSignTransaction(_a) {
        return __awaiter(this, arguments, void 0, function* ({ transaction, args, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signTransaction(transaction, args),
                activityType: 'SignTransaction',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    internalSignTypedData(_a) {
        return __awaiter(this, arguments, void 0, function* ({ typedData, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signTypedData(typedData),
                activityType: 'SignTypedData',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    internalSignMessage(_a) {
        return __awaiter(this, arguments, void 0, function* ({ message, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signMessage({ message }),
                activityType: 'SignMessage',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    doRetryableTurnkeyAction(_a) {
        return __awaiter(this, arguments, void 0, function* ({ action, activityType, address, turnkeySubOrganizationId, }) {
            yield this.createOrRestoreSession();
            let newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
                address,
                turnkeySubOrganizationId,
            });
            try {
                return yield action(newTurnkeyAccountRaw);
            }
            catch (err) {
                if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message.includes(errorMsg))) {
                    yield this.removeSessionKeys();
                    yield this.createOrRestoreSession({
                        ignoreRestore: true,
                    });
                    newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
                        address,
                        turnkeySubOrganizationId,
                    });
                    return action(newTurnkeyAccountRaw);
                }
                logger.error(`[TK] failed to perform ${activityType} activity`, err);
                throw err;
            }
        });
    }
    createTurnkeyAccount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ address, turnkeySubOrganizationId, }) {
            return createAccount({
                client: this.getTurnkeyClient(),
                ethereumAddress: address,
                organizationId: turnkeySubOrganizationId,
                signWith: address,
            });
        });
    }
    refreshTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            this._turnkeyAccount = undefined;
            return this.getTurnkeyAccount();
        });
    }
    getTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this._turnkeyAccount) {
                return this._turnkeyAccount;
            }
            const { turnkeySubOrganizationId } = (_a = this.walletProperties) !== null && _a !== void 0 ? _a : {};
            const { address } = (_b = this.verifiedCredential) !== null && _b !== void 0 ? _b : {};
            if (!turnkeySubOrganizationId || !address) {
                return;
            }
            this._turnkeyAccount = toAccount({
                address: address,
                signMessage: (_c) => __awaiter(this, [_c], void 0, function* ({ message, }) {
                    return this.internalSignMessage({
                        address: address,
                        message,
                        turnkeySubOrganizationId,
                    });
                }),
                signTransaction: (transaction, args) => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTransaction({
                        address: address,
                        args,
                        transaction,
                        turnkeySubOrganizationId,
                    });
                }),
                signTypedData: (typedData) => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTypedData({
                        address: address,
                        turnkeySubOrganizationId,
                        typedData,
                    });
                }),
            });
            this.setLoggerMetadata();
            return this._turnkeyAccount;
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return createViemUiTransaction({ from, publicClient, walletClient });
        });
    }
}
TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey = 'turnkey-last-used-chain-id';

export { TurnkeyEVMWalletConnector };
