'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { parseErrorFromTransport } from '../utils/parseErrorFromTransport/parseErrorFromTransport.js';
import { serializeErrorForTransport } from '../utils/serializeErrorForTransport/serializeErrorForTransport.js';
import { isSerializedError } from '../utils/isSerializedError/isSerializedError.js';

/** Given a request event name, returns the event name for its resolve */
const getResolveMessageType = (type) => `${type}__resolve`;
/** Given a request event name, returns the event name for its reject */
const getRejectMessageType = (type) => `${type}__reject`;
/**
 * Allows handling and submitting requests to and from a webview.
 * Requests are messages that (can) expect some response.
 *
 * Functions similarly to an event emitter, but adds a response feature:
 * - Emitting an event type is the act of making a "request" of a specific type,
 * and it returns a promise that will resolve to the request's response.
 * - Listening to an event type is the act of "handling" requests of a specific type.
 * This handler callback must return a promise if this request type expects responses.
 *
 * Think of it this way:
 * Whenever I emit an event, I am submitting a request.
 * Whoever listens to the event will handle my request.
 * If the request type expects some kind of response, they will
 * return a promise that resolves (or rejects) after my request is fulfilled.
 *
 * This is an abstraction built on top of the MessageTransport interface.
 */
const createRequestChannel = (messageTransport) => {
    /** Used to generated unique ids */
    let uniqueIdCounter = 0;
    /** Id prefix unique to this channel */
    const idPrefix = Math.random().toString();
    /** Always returns a different string */
    const getUniqueId = () => `${idPrefix}-${uniqueIdCounter++}`;
    return {
        emit: (requestName, ...params) => {
            // Generate the unique id for this message exchange session
            // Although we won't listen for a response, it must still be unique
            // to avoid tangling with other requests.
            const messageSessionId = getUniqueId();
            messageTransport.emit({
                args: params,
                messageSessionId,
                type: requestName,
            });
        },
        handle: (requestType, handler) => {
            const messageHandler = (_a) => __awaiter(void 0, [_a], void 0, function* ({ args, messageSessionId, type: incomingType, }) {
                if (requestType !== incomingType)
                    return;
                const result = handler(...args);
                // If the handler doesn't return a promise,
                // that means we don't need to respond.
                if (!(result instanceof Promise))
                    return;
                try {
                    const response = yield result;
                    messageTransport.emit({
                        args: [response],
                        messageSessionId,
                        type: getResolveMessageType(requestType),
                    });
                }
                catch (error) {
                    messageTransport.emit({
                        args: [serializeErrorForTransport(error)],
                        messageSessionId,
                        type: getRejectMessageType(requestType),
                    });
                }
            });
            messageTransport.on(messageHandler);
            return () => {
                messageTransport.off(messageHandler);
            };
        },
        request: (requestName, ...params) => new Promise((resolve, reject) => {
            const requestType = requestName;
            // Generate the unique id for this message exchange session
            const messageSessionId = getUniqueId();
            const resolveMessageType = getResolveMessageType(requestType);
            const rejectMessageType = getRejectMessageType(requestType);
            // Before actually emitting the event, we start listening to the
            // response events
            const handleMessage = ({ args: [result], messageSessionId: incomingSessionId, type: incomingType, }) => {
                if (incomingSessionId !== messageSessionId)
                    return;
                if (incomingType === resolveMessageType) {
                    resolve(result);
                    cleanup();
                }
                if (incomingType === rejectMessageType) {
                    if (isSerializedError(result)) {
                        reject(parseErrorFromTransport(result));
                    }
                    else {
                        reject(result);
                    }
                    cleanup();
                }
            };
            const cleanup = () => messageTransport.off(handleMessage);
            messageTransport.on(handleMessage);
            // Now we emit the event to set off the request
            messageTransport.emit({
                args: params,
                messageSessionId,
                type: requestType,
            });
        }),
    };
};

export { createRequestChannel, getRejectMessageType, getResolveMessageType };
