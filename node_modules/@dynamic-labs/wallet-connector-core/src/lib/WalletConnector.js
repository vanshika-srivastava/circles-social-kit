'use client'
import { __classPrivateFieldGet, __awaiter } from '../../_virtual/_tslib.js';
import EventEmitter from 'eventemitter3';
import { getWalletBookWallet } from '@dynamic-labs/wallet-book';
import { WalletAddressMismatchError } from '@dynamic-labs/utils';
import { logger } from '../utils/logger.js';
import { isSameAddress } from '../utils/isSameAddress/isSameAddress.js';
import { getMobileExperience } from '../utils/getMobileExperience/getMobileExperience.js';
import { isConnectorMethodSupported } from '../utils/isConnectorMethodSupported/isConnectorMethodSupported.js';
import { WalletBookSingleton } from './WalletBookSingleton.js';

/* eslint-disable @typescript-eslint/triple-slash-reference */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable prefer-arrow/prefer-arrow-functions */
/* eslint-disable @typescript-eslint/no-unused-vars */
var _WalletConnectorBase_registeredExtensions;
/* eslint-disable @typescript-eslint/no-empty-interface */
const Chains = [
    'ETH',
    'FLOW',
    'SOL',
    'EVM',
    'ALGO',
    'STARK',
    'ATOM',
    'COSMOS',
    'BTC',
];
const socialProviders = [
    'google',
    'facebook',
    'apple',
    'github',
    'bitbucket',
    'gitlab',
    'linkedin',
    'twitter',
    'discord',
    'twitch',
    'microsoft',
];
class WalletConnectorBase extends EventEmitter {
    createWallet(props) {
        const wallet = new this.ChainWallet(props);
        return wallet;
    }
    /**
     * We store the constructor props so that we can use them later on
     * in getMobileOrInstalledWallet which may fall back to a different class
     * but will need the original constructor props.
     * @param props - constructor props
     */
    constructor(props) {
        super();
        this.chainRpcProviders = undefined;
        this.isGlobalTransaction = false;
        _WalletConnectorBase_registeredExtensions.set(this, []);
        this.didSetup = false;
        /**
         * This flag corresponds to whether this wallet connector also requires its own email otp outside dynamic
         * @default false
         */
        this.requiresNonDynamicEmailOtp = false;
        /**
         * IF the wallet needs to be connected via a custodial service
         * such as Blocto, this will be true.
         * @default false
         */
        this.canConnectViaCustodialService = false;
        /**
         * If the wallet is not installed, and can be connected via a QR code,
         * this will be true.
         * @default false
         */
        this.canConnectViaQrCode = false;
        /**
         * Whether this connector can be connected via social login.
         * @default false
         */
        this.canConnectViaSocial = false;
        /**
         * Flag if connector/provider is available
         *
         * @default true
         */
        this.isAvailable = true;
        /**
         * If the wallet generated by a valid embedded wallet provider
         * For example: magic wallets
         * @default false
         */
        this.isEmbeddedWallet = false;
        /**
         * Flag if it is wallet Connect
         *
         * @default false
         */
        this.isWalletConnect = false;
        /**
         * Override key for the wallet (used for injected wallet linking)
         */
        this.overrideKey = undefined;
        /**
         * Additional resources to add to the message to be signed
         *
         * @default undefined
         */
        this.providerResources = undefined;
        /**
         * Requires switching network in the wallet itself
         * @default undefined
         */
        this.switchNetworkOnlyFromWallet = undefined;
        /**
         * Whether the connector has been initialized
         * @default true
         */
        this.isInitialized = true;
        this.constructorProps = props;
        this._walletBookInstance = WalletBookSingleton.getOrCreate(props.walletBook);
        if (this.walletBook === undefined) {
            throw new Error('WalletConnectorBase was not called with super(props) and is missing wallet-book');
        }
    }
    extend(extension) {
        if (__classPrivateFieldGet(this, _WalletConnectorBase_registeredExtensions, "f").includes(extension.name)) {
            throw new Error(`You can only register a single extension of: ${extension.name}`);
        }
        if (extension.name === 'global-wallet-extension') {
            // only allow global wallet extension for evm embedded wallets
            if (!this.isEmbeddedWallet || !this.supportedChains.includes('EVM'))
                return;
        }
        __classPrivateFieldGet(this, _WalletConnectorBase_registeredExtensions, "f").push(extension.name);
        extension.extend(this);
    }
    /**
     * Add the event listeners for the wallet and connect
     * with event emitter.
     */
    initEventListener() {
        if (this.didSetup)
            return;
        this.didSetup = true;
        this.setupEventListeners();
    }
    get walletBook() {
        return this._walletBookInstance.walletBook;
    }
    filter() {
        try {
            getWalletBookWallet(this.walletBook, this.key, this.walletFallback);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    get mobileExperience() {
        return getMobileExperience({
            mobileExperienceProp: this.constructorProps.mobileExperience,
            walletBook: this.walletBook,
            walletKey: this.key,
        });
    }
    /**
     * Prompt the user to choose accounts to connect (see behavior in MM)
     * @default Promise<[]>
     */
    chooseAccountsToConnect() {
        return Promise.resolve([]);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getAddress();
        });
    }
    /**
     * Generic function to close the wallet connection
     * Originally implemented for WalletConnect, but it is used
     * for anything that needs to be "logged out" or cleaned up
     *
     * @default Promise<undefined>
     */
    endSession() {
        return Promise.resolve();
    }
    /**
     * Gets the public address of the wallet
     *
     * @default Promise<undefined>
     */
    getAddress(opts) {
        return Promise.resolve(undefined);
    }
    /**
     * Parses a public address to ensure it follows a correct format.
     *
     * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
     *
     * @default string
     */
    parseAddress(address) {
        return address;
    }
    /**
     * Whether this wallet connector is targeting a testnet.
     * So far only supported for EVM connectors.
     *
     * @default Promise<false>
     */
    isTestnet() {
        return Promise.resolve(false);
    }
    /**
     * Gets the additional addresses of the wallet, given the main address
     *
     * @default Promise<[]>
     */
    getAdditionalAddresses(mainAddress) {
        return Promise.resolve([]);
    }
    /**
     * Sets the additional addresses of the wallet, given the main address
     *
     * @default Promise<void>
     */
    setAdditionalAddresses(mainAddress, additionalAddresses) {
        return Promise.resolve();
    }
    /**
     * Gets the balance of the wallet
     *
     * @default Promise<undefined>
     */
    getBalance(address) {
        return Promise.resolve(undefined);
    }
    /**
     * Get the address silently
     *
     * @default Promise<[]>
     */
    getConnectedAccounts() {
        return Promise.resolve([]);
    }
    /**
     * Gets the deep link of the wallet
     *
     * @default undefined
     */
    getDeepLink() {
        return undefined;
    }
    getNetwork() {
        return Promise.resolve(undefined);
    }
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     */
    getNameService(address) {
        return Promise.resolve(undefined);
    }
    getPublicClient() {
        return Promise.resolve(undefined);
    }
    getSession() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    getSigner() {
        return Promise.resolve(undefined);
    }
    getWalletClient(chainId) {
        return undefined;
    }
    /**
     * Initialize the wallet connector with any async operations
     *
     * @default Promise<void>
     */
    init() {
        return Promise.resolve();
    }
    /**
     * Check if the wallet is installed on the browser
     *
     * @default false
     */
    isInstalledOnBrowser() {
        return false;
    }
    /**
     * Override key or the normalized wallet name if needed
     */
    get key() {
        return this.overrideKey || this.name.replace(/\W/g, '').toLowerCase();
    }
    /**
     * Whether the wallet connector should fall back to a different wallet connector
     * This is called after the object is instantiated, so it can't be a static property
     * and will return the appropriate instance of the wallet connector
     * @returns WalletConnector
     * @default this
     */
    getMobileOrInstalledWallet() {
        return this;
    }
    /**
     * In most cases this is an alias for `signMessage`
     *
     * @default Promise<undefined>
     */
    proveOwnership(address, messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            return this.signMessage(messageToSign);
        });
    }
    /**
     * Set up event listeners for the wallet
     *
     * @default void
     */
    setupEventListeners() {
        return;
    }
    /**
     * Sign a message
     *
     * @default Promise<undefined>
     */
    signMessage(messageToSign, withAddress) {
        return Promise.resolve(undefined);
    }
    /**
     * Whether the wallet supports network switching
     *
     * @default false
     */
    supportsNetworkSwitching() {
        return false;
    }
    switchNetwork({ networkName, networkChainId, }) {
        return Promise.resolve(undefined);
    }
    /**
     * Tear down event listeners for the wallet
     * @default void
     */
    teardownEventListeners() {
        return;
    }
    /**
     * Receive the user verified credentials
     */
    setVerifiedCredentials(verifiedCredentials) {
        return;
    }
    /**
     * Whether the wallet allow for getting the address in the
     * current chain.
     * This is used for multi chain wallets.
     * @default true
     */
    canGetChainAddress() {
        return true;
    }
    /**
     * Prompts the user to make expected wallet active
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
     * otherwise rejects with an error.
     */
    handleWalletNotActive(_a) {
        return __awaiter(this, arguments, void 0, function* ({ activeAddress, expectedAddress, reconnectedAddress, }) {
            logger.debug('validateActiveWallet - wallet is not active', {
                activeAddress,
                expectedAddress,
                reconnectedAddress,
            });
            const currentActiveAddress = activeAddress || reconnectedAddress || '';
            const walletUiUtils = this.constructorProps
                .walletUiUtils;
            if (!walletUiUtils) {
                throw new WalletAddressMismatchError(`Wallet ${expectedAddress !== null && expectedAddress !== void 0 ? expectedAddress : ''} is not currently active in ${this.name || this.key}.`, {
                    activeAddress: currentActiveAddress,
                    expectedAddress,
                    walletName: this.name || this.key,
                });
            }
            return walletUiUtils.syncWallet({
                activeAddress: currentActiveAddress,
                expectedAddress,
                walletConnector: this,
            });
        });
    }
    /**
     * Validates if the address is connected and active in the wallet app
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
     * otherwise rejects with an error.
     */
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('validateActiveWallet - validating wallet', expectedAddress);
            const canFetchConnectedAccounts = isConnectorMethodSupported(this, 'getConnectedAccounts', 'browserExtension');
            logger.debug('validateActiveWallet - getting connected accounts', {
                canFetchConnectedAccounts,
            });
            const [activeAddress] = canFetchConnectedAccounts
                ? yield this.getConnectedAccounts()
                : [];
            const isWalletActive = activeAddress &&
                isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (isWalletActive) {
                logger.debug('validateActiveWallet - wallet is active');
                return;
            }
            logger.debug('validateActiveWallet - trying to reconnect wallet...');
            const getReconnectedAddress = () => __awaiter(this, void 0, void 0, function* () {
                if (this.isWalletConnect || !this.canGetChainAddress()) {
                    return undefined;
                }
                return this.getAddress().catch((err) => {
                    logger.debug('validateActiveWallet - error getting address', err);
                    return undefined;
                });
            });
            //  not possible to auto-reconnect walletconnect
            const reconnectedAddress = yield getReconnectedAddress();
            if (reconnectedAddress &&
                isSameAddress(reconnectedAddress, expectedAddress, this.connectedChain)) {
                logger.debug('validateActiveWallet - wallet reconnected successfuly');
                return;
            }
            return this.handleWalletNotActive({
                activeAddress,
                expectedAddress,
                reconnectedAddress,
            });
        });
    }
}
_WalletConnectorBase_registeredExtensions = new WeakMap();

export { Chains, WalletConnectorBase, socialProviders };
