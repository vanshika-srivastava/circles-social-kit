import EventEmitter from 'eventemitter3';
import { WalletBookSchema, WalletSchema } from '@dynamic-labs/wallet-book';
import type { JwtVerifiedCredential, WalletAdditionalAddress } from '@dynamic-labs/sdk-api-core';
import { IChainRpcProviders } from '@dynamic-labs/rpc-providers';
import { MobileExperience } from '@dynamic-labs/types';
import { WalletBookSingleton } from './WalletBookSingleton';
import { WalletConnectorExtension } from './WalletConnectorExtension';
import { WalletConnectorCore } from './types';
import { WalletConstructor, WalletProps } from './wallets';
export declare const Chains: readonly ["ETH", "FLOW", "SOL", "EVM", "ALGO", "STARK", "ATOM", "COSMOS", "BTC"];
export type Chain = typeof Chains[number];
export declare const socialProviders: readonly ["google", "facebook", "apple", "github", "bitbucket", "gitlab", "linkedin", "twitter", "discord", "twitch", "microsoft"];
export type SocialProvider = typeof socialProviders[number];
export type PayloadParams = {
    params: {
        accounts: string[];
        chainId: number;
        message: string;
    }[];
};
export type GetAddressOpts = {
    chainId?: string;
    onConnect?(payload: PayloadParams): void;
    onDesktopUri?(uri: string): void;
    onDisplayUri?(uri: string): void;
};
export type NameServiceData = {
    avatar?: string;
    name?: string;
};
declare module './types' {
    namespace WalletConnectorCore {
        interface WalletConnector extends WalletConnectorBase {
        }
    }
}
export type InternalWalletConnector = WalletConnectorCore.WalletConnector;
export type WalletConnector = Pick<InternalWalletConnector, 'canConnectViaCustodialService' | 'canConnectViaQrCode' | 'canConnectViaSocial' | 'chainRpcProviders' | 'connect' | 'connectedChain' | 'createWallet' | 'constructorProps' | 'endSession' | 'getAddress' | 'getAdditionalAddresses' | 'getConnectedAccounts' | 'getDeepLink' | 'getMobileOrInstalledWallet' | 'getNetwork' | 'getSession' | 'initEventListener' | 'isAvailable' | 'isEmbeddedWallet' | 'isInitialized' | 'isInstalledOnBrowser' | 'isTestnet' | 'isWalletConnect' | 'key' | 'name' | 'parseAddress' | 'proveOwnership' | 'providerResources' | 'supportedChains' | 'supportsNetworkSwitching' | 'switchNetwork' | 'switchNetworkOnlyFromWallet' | 'teardownEventListeners'> & EventEmitter<WalletConnectorEventTypes>;
export interface WalletConnectorConstructor {
    new (props?: any): InternalWalletConnector;
}
export type WalletConnectorsMethod = (props?: any) => WalletConnectorConstructor[];
export type WalletConnectorEventTypes = {
    chainChange: (props: {
        chain: string;
    }) => void;
    accountChange: (props: {
        accounts: string[];
    }) => void;
    disconnect: () => void;
};
export declare abstract class WalletConnectorBase<C extends WalletConstructor<any> = WalletConstructor<any>> extends EventEmitter<WalletConnectorEventTypes> {
    #private;
    abstract ChainWallet: C;
    createWallet(props: WalletProps<InternalWalletConnector>): import("./wallets").Wallet<any>;
    chainRpcProviders: IChainRpcProviders | undefined;
    constructorProps: any;
    _walletBookInstance: WalletBookSingleton;
    walletFallback: WalletSchema | undefined;
    isGlobalTransaction: boolean;
    /**
     * We store the constructor props so that we can use them later on
     * in getMobileOrInstalledWallet which may fall back to a different class
     * but will need the original constructor props.
     * @param props - constructor props
     */
    constructor(props: {
        walletBook: WalletBookSchema;
    });
    extend(extension: WalletConnectorExtension): void;
    didSetup: boolean;
    /**
     * Add the event listeners for the wallet and connect
     * with event emitter.
     */
    initEventListener(): void;
    get walletBook(): WalletBookSchema;
    filter(): boolean;
    get mobileExperience(): MobileExperience | undefined;
    /**
     * This flag corresponds to whether this wallet connector also requires its own email otp outside dynamic
     * @default false
     */
    requiresNonDynamicEmailOtp: boolean;
    /**
     * IF the wallet needs to be connected via a custodial service
     * such as Blocto, this will be true.
     * @default false
     */
    canConnectViaCustodialService: boolean;
    /**
     * If the wallet is not installed, and can be connected via a QR code,
     * this will be true.
     * @default false
     */
    canConnectViaQrCode: boolean;
    /**
     * Whether this connector can be connected via social login.
     * @default false
     */
    canConnectViaSocial: boolean;
    /**
     * Prompt the user to choose accounts to connect (see behavior in MM)
     * @default Promise<[]>
     */
    chooseAccountsToConnect(): Promise<string[]>;
    /**
     * Connect to the wallet or custodial service
     *
     * Historically, this was used for starting the connect process to be able to fetch
     * public address. But it can be used for different connection initialization.
     *
     * @default string - the public address of the wallet
     */
    connect(args?: unknown): Promise<void>;
    connect<T = undefined>(args: T): Promise<void>;
    /**
     * The chain this wallet is connected
     */
    abstract connectedChain: Chain;
    /**
     * Generic function to close the wallet connection
     * Originally implemented for WalletConnect, but it is used
     * for anything that needs to be "logged out" or cleaned up
     *
     * @default Promise<undefined>
     */
    endSession(): Promise<void>;
    /**
     * Gets the public address of the wallet
     *
     * @default Promise<undefined>
     */
    getAddress(opts?: GetAddressOpts): Promise<string | undefined>;
    /**
     * Parses a public address to ensure it follows a correct format.
     *
     * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
     *
     * @default string
     */
    parseAddress(address: string): string;
    /**
     * Whether this wallet connector is targeting a testnet.
     * So far only supported for EVM connectors.
     *
     * @default Promise<false>
     */
    isTestnet(): Promise<boolean>;
    /**
     * Gets the additional addresses of the wallet, given the main address
     *
     * @default Promise<[]>
     */
    getAdditionalAddresses(mainAddress?: string): Promise<WalletAdditionalAddress[]>;
    /**
     * Sets the additional addresses of the wallet, given the main address
     *
     * @default Promise<void>
     */
    setAdditionalAddresses(mainAddress: string, additionalAddresses: WalletAdditionalAddress[]): Promise<void>;
    /**
     * Gets the balance of the wallet
     *
     * @default Promise<undefined>
     */
    getBalance(address: string): Promise<string | undefined>;
    /**
     * Get the address silently
     *
     * @default Promise<[]>
     */
    getConnectedAccounts(): Promise<string[]>;
    /**
     * Gets the deep link of the wallet
     *
     * @default undefined
     */
    getDeepLink(): string | undefined;
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     */
    getNetwork(): Promise<number | string | undefined>;
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     */
    getNameService(address: string): Promise<NameServiceData | undefined>;
    /**
     * Get the RPC provider for the wallet
     *
     * @default Promise<undefined>
     */
    getPublicClient(): Promise<unknown>;
    getPublicClient<T>(): Promise<T>;
    /**
     * Get the session for the wallet
     * @default Promise<undefined>
     */
    getSession(): unknown;
    getSession<T>(): Promise<T>;
    /**
     * Get the signer for the wallet
     *
     * @default Promise<undefined>
     */
    getSigner(): Promise<unknown>;
    getSigner<T>(): Promise<T>;
    /**
     * Get the wallet client
     *
     * @default undefined
     */
    getWalletClient(chainId?: string): unknown;
    getWalletClient<T>(chainId?: string): T;
    /**
     * Initialize the wallet connector with any async operations
     *
     * @default Promise<void>
     */
    init(): Promise<void>;
    /**
     * Flag if connector/provider is available
     *
     * @default true
     */
    isAvailable: boolean;
    /**
     * If the wallet generated by a valid embedded wallet provider
     * For example: magic wallets
     * @default false
     */
    isEmbeddedWallet: boolean;
    /**
     * Check if the wallet is installed on the browser
     *
     * @default false
     */
    isInstalledOnBrowser(): boolean;
    /**
     * Flag if it is wallet Connect
     *
     * @default false
     */
    isWalletConnect: boolean;
    /**
     * Override key or the normalized wallet name if needed
     */
    get key(): string;
    /**
     * Wallet name
     */
    abstract name: string;
    /**
     * Override key for the wallet (used for injected wallet linking)
     */
    overrideKey: string | undefined;
    /**
     * Whether the wallet connector should fall back to a different wallet connector
     * This is called after the object is instantiated, so it can't be a static property
     * and will return the appropriate instance of the wallet connector
     * @returns WalletConnector
     * @default this
     */
    getMobileOrInstalledWallet(): InternalWalletConnector;
    /**
     * In most cases this is an alias for `signMessage`
     *
     * @default Promise<undefined>
     */
    proveOwnership(address: string, messageToSign: string): Promise<string | undefined>;
    /**
     * Additional resources to add to the message to be signed
     *
     * @default undefined
     */
    providerResources: string[] | undefined;
    /**
     * Set up event listeners for the wallet
     *
     * @default void
     */
    setupEventListeners(): void;
    /**
     * Sign a message
     *
     * @default Promise<undefined>
     */
    signMessage(messageToSign: string, withAddress?: string): Promise<string | undefined>;
    /**
     * List of supported chains for this wallet
     */
    abstract readonly supportedChains: Chain[];
    /**
     * Whether the wallet supports network switching
     *
     * @default false
     */
    supportsNetworkSwitching(): boolean;
    /**
     * Switch the network
     * @default Promise<undefined>
     */
    switchNetwork({ networkName, networkChainId, }: {
        networkChainId?: number | string;
        networkName?: string;
    }): Promise<void>;
    /**
     * Requires switching network in the wallet itself
     * @default undefined
     */
    switchNetworkOnlyFromWallet: boolean | undefined;
    /**
     * Tear down event listeners for the wallet
     * @default void
     */
    teardownEventListeners(): void;
    /**
     * Whether the connector has been initialized
     * @default true
     */
    isInitialized: boolean;
    /**
     * Receive the user verified credentials
     */
    setVerifiedCredentials(verifiedCredentials: JwtVerifiedCredential[]): void;
    /**
     * Whether the wallet allow for getting the address in the
     * current chain.
     * This is used for multi chain wallets.
     * @default true
     */
    canGetChainAddress(): boolean;
    /**
     * Prompts the user to make expected wallet active
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
     * otherwise rejects with an error.
     */
    handleWalletNotActive({ activeAddress, expectedAddress, reconnectedAddress, }: {
        expectedAddress: string;
        activeAddress?: string;
        reconnectedAddress?: string;
    }): Promise<void>;
    /**
     * Validates if the address is connected and active in the wallet app
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
     * otherwise rejects with an error.
     */
    validateActiveWallet(expectedAddress: string): Promise<void>;
}
