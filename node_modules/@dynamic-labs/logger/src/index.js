'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import EventEmitter from 'eventemitter3';
import { LogLevel } from './types.js';
export { LogLevel } from './types.js';
import { deepMerge } from './utils/deepMerge.js';
import { processArgs } from './utils/processArgs.js';

/* eslint-disable @typescript-eslint/no-explicit-any, no-console */
const IGNORE_MESSAGES = ['Failed to send logs to server'];
const messageQueue = [];
class Logger {
    constructor(name, level) {
        this.name = name;
        this.meta = undefined;
        if (level === undefined && process.env['NODE_ENV'] !== 'production') {
            this.level = LogLevel.DEBUG;
        }
        else if (level === undefined) {
            this.level = LogLevel.WARN;
        }
        else {
            this.level = level;
        }
    }
    static setEmitErrors(emit) {
        if (emit !== undefined) {
            Logger.globalKeys.emitErrors = emit;
        }
    }
    static setEnvironmentId(environmentId) {
        if (environmentId !== undefined) {
            Logger.globalKeys.environmentId = environmentId;
        }
    }
    setMetaData(key, value) {
        if (!this.meta) {
            this.meta = {};
        }
        const data = {};
        key.split('.').reduce((acc, k, i, arr) => {
            if (i === arr.length - 1) {
                acc[k] = value;
            }
            else {
                if (!acc[k]) {
                    acc[k] = {};
                }
                return acc[k];
            }
        }, data);
        this.meta = deepMerge(this.meta, data);
    }
    getNameArray(name) {
        return Array.isArray(name) ? name : [name];
    }
    createLogger(name, level) {
        return new Logger([...this.getNameArray(this.name), ...this.getNameArray(name)], level !== null && level !== void 0 ? level : this.level);
    }
    get logLevel() {
        return LogLevel[this.level];
    }
    setLogLevel(level) {
        if (level in LogLevel && typeof level === 'string') {
            this.level = LogLevel[level];
        }
        else if (level in LogLevel && typeof level === 'number') {
            this.level = level;
        }
        else {
            throw new Error(`Invalid log level: ${level}`);
        }
    }
    formatMessage(level, message) {
        var _a;
        if (message instanceof Error) {
            message = message.stack;
        }
        else if (
        // Handle Error-Like Objects
        message instanceof Object &&
            Object.prototype.hasOwnProperty.call(message, 'stack')) {
            message = message.stack;
        }
        else if (message instanceof Object) {
            message = JSON.stringify(message);
        }
        const names = (Array.isArray(this.name) ? this.name : [this.name]).map((name) => `[${name}]`);
        return `${names.join('')} [${(_a = LogLevel[level]) !== null && _a !== void 0 ? _a : 'TROUBLESHOOTING'}]: ${message}`;
    }
    captureAndSend(level, message, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Logger.globalKeys.emitErrors &&
                !IGNORE_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.toString()) &&
                typeof window !== 'undefined') {
                this.emitHttpLogs(level, message, { args });
            }
        });
    }
    emitHttpLogs(level, message, { args = [], transformMeta = (meta) => meta }) {
        messageQueue.push({ args, level, message });
        if (messageQueue.length === 1) {
            /**
             * Batching the logs to send them in a single request
             * https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#batching_operations
             *
             * Essentially, multiple calls to log in the same event loop will be batched into a single request
             */
            queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const messages = [];
                messageQueue.forEach((msg) => {
                    var _a, _b, _c, _d, _e;
                    const body = {};
                    const { objectArgs, remainingArgs } = processArgs(msg);
                    Object.assign(body, ...objectArgs);
                    Object.assign(body, {
                        level: LogLevel[msg.level],
                        message: [msg.message, ...remainingArgs].join(' '),
                        meta: transformMeta(this.meta),
                        url: {
                            hostname: (_a = window.location) === null || _a === void 0 ? void 0 : _a.hostname,
                            origin: (_b = window.location) === null || _b === void 0 ? void 0 : _b.origin,
                            pathname: (_c = window.location) === null || _c === void 0 ? void 0 : _c.pathname,
                            port: (_d = window.location) === null || _d === void 0 ? void 0 : _d.port,
                            protocol: (_e = window.location) === null || _e === void 0 ? void 0 : _e.protocol,
                        },
                    });
                    messages.push(body);
                });
                try {
                    if (!((_a = Logger.globalKeys) === null || _a === void 0 ? void 0 : _a.environmentId)) {
                        throw new Error('Environment ID not set');
                    }
                    yield fetch(`https://logs.dynamicauth.com/api/v1/${(_b = Logger.globalKeys) === null || _b === void 0 ? void 0 : _b.environmentId}`, {
                        body: JSON.stringify(messages),
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        method: 'POST',
                        mode: 'cors',
                        referrerPolicy: 'origin-when-cross-origin',
                    });
                }
                catch (error) {
                    this.debug('Failed to send logs to server', error);
                }
                messageQueue.length = 0;
            }));
        }
    }
    /**
     * Emits an INFO type message to the backend for analysis and debugging
     */
    instrument(message, options) {
        return this.emitHttpLogs(LogLevel.INFO, message, {
            args: [options],
            // Don't send any meta to avoid storing PII
            transformMeta: () => undefined,
        });
    }
    log(level, message, ...args) {
        const enableTroubleshootMode = typeof window !== 'undefined' &&
            (window === null || window === void 0 ? void 0 : window.dynamic_enableTroubleshootMode) === true;
        if (!enableTroubleshootMode &&
            (level < this.level || level === LogLevel.MUTE)) {
            return;
        }
        const fmtMsg = this.formatMessage(level, message);
        switch (level) {
            case LogLevel.WARN:
                console.warn(fmtMsg, ...args);
                break;
            case LogLevel.ERROR:
                console.error(fmtMsg, ...args);
                break;
            default:
                console.log(fmtMsg, ...args);
        }
        if (level === LogLevel.ERROR) {
            this.captureAndSend(level, message, ...args);
        }
    }
    logVerboseTroubleshootingMessage(message, ...args) {
        this.log(-1, message, ...args);
    }
    debug(message, ...args) {
        this.log(LogLevel.DEBUG, message, ...args);
    }
    info(message, ...args) {
        this.log(LogLevel.INFO, message, ...args);
    }
    warn(message, ...args) {
        this.log(LogLevel.WARN, message, ...args);
    }
    error(message, ...args) {
        Logger.events.emit('error', message);
        this.log(LogLevel.ERROR, message, ...args);
    }
}
Logger.globalKeys = {
    emitErrors: true,
};
Logger.events = new EventEmitter();

export { Logger };
