'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { sleep } from './sleep/sleep.js';

const FALLBACK_UNDEFINED = 'FALLBACK_UNDEFINED';
const retryableFn = (fn_1, ...args_1) => __awaiter(void 0, [fn_1, ...args_1], void 0, function* (fn, options = {}) {
    const { maxRetries = 3, currentRetry = 0, timeoutMs = 100, fallbackValue = new Error('Max retries reached'), retryStrategy = 'timeout-only', retryIntervalMs = 0, logger, } = options;
    logger === null || logger === void 0 ? void 0 : logger.debug('Configured retryableFn with options: ', {
        currentRetry,
        fallbackValue,
        maxRetries,
        retryStrategy,
        timeoutMs,
    });
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error('Timeout'));
        }, timeoutMs);
    });
    try {
        const result = yield Promise.race([fn(), timeoutPromise]);
        return result;
    }
    catch (err) {
        logger === null || logger === void 0 ? void 0 : logger.debug('retryableFn caught error: ', err);
        if (currentRetry >= maxRetries) {
            logger === null || logger === void 0 ? void 0 : logger.error('Error while retrying function, returning/throwing fallback value', err, fallbackValue);
            if (fallbackValue instanceof Error) {
                throw fallbackValue;
            }
            else if (fallbackValue === FALLBACK_UNDEFINED) {
                return undefined;
            }
            return fallbackValue;
        }
        const isTimeout = (err === null || err === void 0 ? void 0 : err.message) === 'Timeout';
        const shouldRetry = retryStrategy === 'timeout-and-rejection' ||
            (retryStrategy === 'timeout-only' && isTimeout) ||
            (retryStrategy === 'rejection-only' && !isTimeout);
        logger === null || logger === void 0 ? void 0 : logger.debug('retryableFn shouldRetry: ', shouldRetry);
        if (!shouldRetry) {
            if (fallbackValue instanceof Error) {
                logger === null || logger === void 0 ? void 0 : logger.debug('retryableFn throwing fallbackValue error: ', fallbackValue);
                throw err;
            }
            else if (fallbackValue === FALLBACK_UNDEFINED) {
                logger === null || logger === void 0 ? void 0 : logger.debug('retryableFn returning undefined');
                return undefined;
            }
            logger === null || logger === void 0 ? void 0 : logger.debug('retryableFn returning fallbackValue: ', fallbackValue);
            logger === null || logger === void 0 ? void 0 : logger.error('Error while retrying function, returning fallback value', err);
            return fallbackValue;
        }
        if (retryIntervalMs)
            yield sleep(retryIntervalMs);
        return retryableFn(fn, {
            currentRetry: currentRetry + 1,
            fallbackValue,
            logger,
            maxRetries,
            retryIntervalMs,
            retryStrategy,
            timeoutMs,
        });
    }
});

export { FALLBACK_UNDEFINED, retryableFn };
