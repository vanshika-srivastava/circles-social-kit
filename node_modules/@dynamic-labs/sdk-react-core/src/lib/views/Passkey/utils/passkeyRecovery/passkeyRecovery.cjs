'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../../_virtual/_tslib.cjs');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var utils = require('@dynamic-labs/utils');
require('@dynamic-labs/sdk-api-core');
require('../../../../shared/logger.cjs');
require('@dynamic-labs/iconic');
require('react/jsx-runtime');
require('../../../../context/ViewContext/ViewContext.cjs');
require('react');
require('@dynamic-labs/wallet-book');
var localStorage = require('../../../../utils/constants/localStorage.cjs');
require('../../../../utils/constants/colors.cjs');
require('../../../../utils/constants/values.cjs');
require('../../../../store/state/loadingAndLifecycle.cjs');
require('../../../../shared/consts/index.cjs');
require('../../../../config/ApiEndpoint.cjs');
var findEmbeddedWalletFromVerifiedCredentials = require('../../../../utils/functions/findEmbeddedWalletFromVerifiedCredentials/findEmbeddedWalletFromVerifiedCredentials.cjs');
var errors = require('../../../../utils/constants/errors.cjs');
require('@dynamic-labs/multi-wallet');
require('react-international-phone');
var removeElementById = require('../../../../utils/functions/removeElementById/removeElementById.cjs');
require('../../../../store/state/projectSettings/projectSettings.cjs');
var embeddedWallets = require('../../../../data/api/embeddedWallets/embeddedWallets.cjs');
require('../../../../store/state/user/user.cjs');
require('../../../../locale/locale.cjs');
var user = require('../../../../data/api/user/user.cjs');
var constants = require('../../PasskeyRecovery/constants.cjs');

const initEmbeddedWalletSession = (_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ authenticatorType, iframeContainer, iframeElementId, environmentId, user, wallet, sessionExpiration, }) {
    var _b;
    if (!user) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !(wallet === null || wallet === void 0 ? void 0 : wallet.id) ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    const turnkeyRecoveryHandler = (_b = wallet.connector) === null || _b === void 0 ? void 0 : _b.getAuthenticatorHandler();
    if (authenticatorType === 'passkey' &&
        turnkeyRecoveryHandler.isSessionActive()) {
        return addNewPasskeyAuthenticator({
            environmentId,
            user,
            wallet,
        });
    }
    const publicKey = yield turnkeyRecoveryHandler.initRecovery(authenticatorType, iframeContainer, iframeElementId, sessionExpiration);
    if (!publicKey) {
        throw new utils.DynamicError('Something went wrong');
    }
    const response = yield embeddedWallets.initEmbeddedWalletSession({
        authenticatorType,
        environmentId,
        publicKey,
        walletId: wallet.id,
    });
    turnkeyRecoveryHandler.recoveryUserId =
        authenticatorType === 'passkey'
            ? response.turnkeyRecoveryUserId
            : response.turnkeyUserId;
    return;
});
const passkeyRecoveryBundleValidation = (_c) => _tslib.__awaiter(void 0, [_c], void 0, function* ({ user, bundleInput, wallet, }) {
    var _d, _e, _f, _g;
    if (!bundleInput) {
        throw new utils.DynamicError('Code must be informed');
    }
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !(wallet === null || wallet === void 0 ? void 0 : wallet.id) ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    if (!user) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    const organizationId = (_f = (_e = (_d = user.verifiedCredentials) === null || _d === void 0 ? void 0 : _d.find(({ walletName }) => walletName === null || walletName === void 0 ? void 0 : walletName.startsWith('turnkey'))) === null || _e === void 0 ? void 0 : _e.walletProperties) === null || _f === void 0 ? void 0 : _f.turnkeySubOrganizationId;
    const turnkeyRecoveryHandler = (_g = wallet.connector) === null || _g === void 0 ? void 0 : _g.getAuthenticatorHandler();
    yield turnkeyRecoveryHandler.verifyRecoveryCode(bundleInput, organizationId);
    const sessionSettings = {
        createdAt: new Date().getTime(),
        emailCode: bundleInput,
        userId: turnkeyRecoveryHandler.recoveryUserId,
    };
    utils.StorageService.setItem(localStorage.EMBEDDED_WALLET_SESSION_SETTINGS, sessionSettings);
});
const resentRecoveryEmail = (_h) => _tslib.__awaiter(void 0, [_h], void 0, function* ({ authenticatorType, user, environmentId, wallet, }) {
    var _j;
    if (!user) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !(wallet === null || wallet === void 0 ? void 0 : wallet.id) ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    const publicKey = (_j = wallet.connector) === null || _j === void 0 ? void 0 : _j.getAuthenticatorHandler().publicKey;
    if (!publicKey) {
        throw new utils.DynamicError('Could not proceed with your request. Please restart the process.');
    }
    return embeddedWallets.initEmbeddedWalletSession({
        authenticatorType,
        environmentId,
        publicKey,
        walletId: wallet === null || wallet === void 0 ? void 0 : wallet.id,
    });
});
const completePasskeyRecovery = (_k) => _tslib.__awaiter(void 0, [_k], void 0, function* ({ user, environmentId, wallet, }) {
    const { connector, user: updatedUser } = yield recoverTurnkeyWallet({
        addPasskeyAuthenticator: false,
        environmentId,
        user,
        wallet,
    });
    // clear iframeStamper and its reference
    connector.getAuthenticatorHandler().clear();
    // deletes iframe container after usage
    removeElementById.removeElementById(constants.iframeElementId);
    return updatedUser;
});
const addNewPasskeyAuthenticator = (_l) => _tslib.__awaiter(void 0, [_l], void 0, function* ({ user, environmentId, wallet, }) {
    const { user: updatedUser } = yield recoverTurnkeyWallet({
        addPasskeyAuthenticator: true,
        environmentId,
        user,
        wallet,
    });
    return updatedUser;
});
const recoverTurnkeyWallet = (_m) => _tslib.__awaiter(void 0, [_m], void 0, function* ({ wallet, user, environmentId, addPasskeyAuthenticator, }) {
    var _o, _p, _q;
    if (!user) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    if (!wallet ||
        !wallet.connector ||
        !wallet.id ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    const connector = wallet.connector;
    connector.setEmail(user.email);
    const turnkeySubOrganizationId = (_q = (_p = (_o = user.verifiedCredentials) === null || _o === void 0 ? void 0 : _o.find(({ walletName }) => walletName === null || walletName === void 0 ? void 0 : walletName.startsWith('turnkey'))) === null || _p === void 0 ? void 0 : _p.walletProperties) === null || _q === void 0 ? void 0 : _q.turnkeySubOrganizationId;
    if (!turnkeySubOrganizationId) {
        throw new utils.DynamicError('The authentication token is invalid - turnkeySubOrganizationId is missing');
    }
    const turnkeyRecoveryHandler = wallet.connector.getAuthenticatorHandler();
    const { attestation, challenge } = yield connector.getWebAuthnAttestation();
    if (addPasskeyAuthenticator) {
        yield turnkeyRecoveryHandler.addPasskeyAuthenticator({
            attestation,
            challenge,
            turnkeySubOrganizationId,
        });
    }
    else {
        yield turnkeyRecoveryHandler.completeRecovery({
            attestation,
            challenge,
            turnkeySubOrganizationId,
        });
    }
    const updatedUser = yield embeddedWallets.completePasskeyRecovery({
        attestation: attestation,
        challenge,
        environmentId,
        walletId: wallet.id,
    });
    if (!updatedUser) {
        throw new utils.DynamicError('No user returned from passkey recovery');
    }
    const chain = connector.connectedChain;
    const embeddedWalletVerifiedCredential = findEmbeddedWalletFromVerifiedCredentials.findEmbeddedWalletFromVerifiedCredentials(updatedUser, [chain]);
    if (!embeddedWalletVerifiedCredential) {
        throw new utils.DynamicError('EmbeddedWalletVerifiedCredential not found');
    }
    connector.setVerifiedCredentials(updatedUser.verifiedCredentials);
    return {
        connector,
        user: updatedUser,
    };
});
const canRestoreEmbeddedWalletSession = (sessionExpirationTime) => {
    if (!(sessionExpirationTime === null || sessionExpirationTime === void 0 ? void 0 : sessionExpirationTime.amount)) {
        return false;
    }
    const sessionSettings = utils.StorageService.getItem(localStorage.EMBEDDED_WALLET_SESSION_SETTINGS);
    if (!sessionSettings) {
        return false;
    }
    const sessionExpiration = sessionExpirationTime.amount *
        (sessionExpirationTime.unit === 'minutes' ? 60 : 3600);
    const recoveryExpirationSeconds = (sessionSettings === null || sessionSettings === void 0 ? void 0 : sessionSettings.createdAt) + sessionExpiration * 1000;
    const expirationTime = new Date(recoveryExpirationSeconds);
    if (new Date() >= expirationTime) {
        utils.StorageService.removeItem(localStorage.EMBEDDED_WALLET_SESSION_SETTINGS);
        return false;
    }
    return true;
};
const restoreEmbeddedWalletSession = (_r) => _tslib.__awaiter(void 0, [_r], void 0, function* ({ user, iframeContainer, iframeElementId, wallet, sessionExpiration, }) {
    var _s, _t, _u, _v;
    if (!user) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !(wallet === null || wallet === void 0 ? void 0 : wallet.id) ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    const sessionSettings = utils.StorageService.getItem(localStorage.EMBEDDED_WALLET_SESSION_SETTINGS);
    const turnkeyRecoveryHandler = (_s = wallet.connector) === null || _s === void 0 ? void 0 : _s.getAuthenticatorHandler();
    if (!sessionSettings || Boolean(turnkeyRecoveryHandler.recoveryUserId)) {
        return false;
    }
    const publicKey = yield turnkeyRecoveryHandler.initRecovery('email', iframeContainer, iframeElementId, sessionExpiration);
    if (!publicKey) {
        throw new utils.DynamicError('Could not open embedded wallet connection communication');
    }
    turnkeyRecoveryHandler.recoveryUserId = sessionSettings.userId;
    const organizationId = (_v = (_u = (_t = user.verifiedCredentials) === null || _t === void 0 ? void 0 : _t.find(({ walletName }) => walletName === null || walletName === void 0 ? void 0 : walletName.startsWith('turnkey'))) === null || _u === void 0 ? void 0 : _u.walletProperties) === null || _v === void 0 ? void 0 : _v.turnkeySubOrganizationId;
    yield turnkeyRecoveryHandler.verifyRecoveryCode(sessionSettings.emailCode, organizationId);
    return true;
});
const addEmailRecovery = (_w) => _tslib.__awaiter(void 0, [_w], void 0, function* ({ user: user$1, environmentId, wallet, }) {
    var _x, _y;
    if (!(user$1 === null || user$1 === void 0 ? void 0 : user$1.email)) {
        throw new utils.DynamicError(errors.USER_NOT_LOGGED_IN);
    }
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !(wallet === null || wallet === void 0 ? void 0 : wallet.id) ||
        !walletConnectorCore.isPasskeyWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector) ||
        !walletConnectorCore.isEmailWalletConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
        throw new utils.DynamicError('Connector is missing. Please make sure you added EthereumWalletConnectors and/or SolanaWalletConnectors to DynamicProvider settings');
    }
    const { turnkeySubOrganizationId, turnkeyUserId } = (_y = (_x = user$1.verifiedCredentials) === null || _x === void 0 ? void 0 : _x.find(({ walletName }) => walletName === null || walletName === void 0 ? void 0 : walletName.startsWith('turnkey'))) === null || _y === void 0 ? void 0 : _y.walletProperties;
    if (!turnkeySubOrganizationId || !turnkeyUserId) {
        throw new utils.DynamicError('The authentication token is invalid - turnkeySubOrganizationId or turnkeyUserID is missing');
    }
    const turnkeyRecoveryHandler = wallet.connector.getAuthenticatorHandler();
    const { signedRequest } = (yield turnkeyRecoveryHandler.addEmailRecovery({
        email: user$1.email,
        organizationId: turnkeySubOrganizationId,
        turnkeyUserId,
    }));
    yield embeddedWallets.updatePasskeyRecoveryEmail({
        environmentId,
        updateRecoveryEmailRequest: { turnkeySignedRequest: signedRequest },
    });
    wallet.connector.setEmail(user$1.email);
    return user.refreshUserJwt({ environmentId });
});

exports.addEmailRecovery = addEmailRecovery;
exports.addNewPasskeyAuthenticator = addNewPasskeyAuthenticator;
exports.canRestoreEmbeddedWalletSession = canRestoreEmbeddedWalletSession;
exports.completePasskeyRecovery = completePasskeyRecovery;
exports.initEmbeddedWalletSession = initEmbeddedWalletSession;
exports.passkeyRecoveryBundleValidation = passkeyRecoveryBundleValidation;
exports.resentRecoveryEmail = resentRecoveryEmail;
exports.restoreEmbeddedWalletSession = restoreEmbeddedWalletSession;
