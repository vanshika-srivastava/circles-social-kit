'use client'
import { __awaiter } from '../../../../_virtual/_tslib.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useState, useRef, useCallback, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { isSessionKeyCompatibleWallet } from '@dynamic-labs/wallet-connector-core';
import { classNames } from '../../utils/functions/classNames/classNames.js';
import '../../components/Accordion/components/AccordionItem/AccordionItem.js';
import '../../components/Alert/Alert.js';
import { dynamicEvents } from '../../events/dynamicEvents.js';
import '@dynamic-labs/utils';
import '../../context/DynamicContext/DynamicContext.js';
import '@dynamic-labs/sdk-api-core';
import { logger } from '../../shared/logger.js';
import '@dynamic-labs/iconic';
import { useViewContext } from '../../context/ViewContext/ViewContext.js';
import { ReactComponent as SvgCheck } from '../../shared/assets/check.js';
import { ReactComponent as SvgSignInWithEmail } from '../../shared/assets/sign-in-with-email.js';
import '@dynamic-labs/wallet-book';
import '../../utils/constants/colors.js';
import '../../utils/constants/values.js';
import '../../store/state/loadingAndLifecycle.js';
import '../../shared/consts/index.js';
import { useInternalDynamicContext } from '../../context/DynamicContext/useDynamicContext/useInternalDynamicContext.js';
import '../../context/CaptchaContext/CaptchaContext.js';
import { useErrorContext } from '../../context/ErrorContext/ErrorContext.js';
import { createUserProfileFromSdkUser } from '../../utils/functions/createUserProfile/createUserProfile.js';
import { findEmbeddedWalletFromVerifiedCredentials } from '../../utils/functions/findEmbeddedWalletFromVerifiedCredentials/findEmbeddedWalletFromVerifiedCredentials.js';
import '@dynamic-labs/multi-wallet';
import 'react-international-phone';
import { shortenEmail } from '../../shared/utils/functions/shortenEmail/shortenEmail.js';
import { isTurnkeyEnabled } from '../../utils/functions/isTurnkeyEnabled/isTurnkeyEnabled.js';
import { signInWithEmailVerification, retryEmailVerification } from '../../data/api/email/email.js';
import { storeAuthTokenAndUser } from '../../store/state/user/storeAuthTokenAndUser/storeAuthTokenAndUser.js';
import '../../store/state/user/user.js';
import '../../config/ApiEndpoint.js';
import '../../locale/locale.js';
import '../../store/state/projectSettings/projectSettings.js';
import '../../context/AccessDeniedContext/AccessDeniedContext.js';
import '../../context/AccountExistsContext/AccountExistsContext.js';
import '../../context/UserWalletsContext/UserWalletsContext.js';
import { useOtpVerificationRequest } from '../../utils/hooks/authenticationHooks/useOtpVerificationRequest/useOtpVerificationRequest.js';
import 'react-dom';
import '../../context/WalletContext/WalletContext.js';
import { useIsTurnkeyWallet } from '../../utils/hooks/useIsTurnkeyWallet/useIsTurnkeyWallet.js';
import { usePasskeyRecovery } from '../../utils/hooks/usePasskeyRecovery/usePasskeyRecovery.js';
import { useSmartWallets } from '../../utils/hooks/useSmartWallets/useSmartWallets.js';
import '../../utils/hooks/useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/constants.js';
import '../../context/ThemeContext/ThemeContext.js';
import { useVerification } from '../../context/VerificationContext/VerificationContext.js';
import '../../utils/hooks/useUserUpdateRequest/useUpdateUser/userFieldsSchema.js';
import { useOnUnmount } from '../../utils/hooks/useOnUnmount/useOnUnmount.js';
import '@dynamic-labs/types';
import { useUserAuth } from '../../utils/hooks/useUserAuth/useUserAuth.js';
import { useEmbeddedWalletSessionKeys } from '../../utils/hooks/useEmbeddedWalletSessionKeys/useEmbeddedWalletSessionKeys.js';
import 'yup';
import '../../context/MockContext/MockContext.js';
import '../CollectUserDataView/useFields.js';
import '../../context/FieldsStateContext/FieldsStateContext.js';
import '../../context/UserFieldEditorContext/UserFieldEditorContext.js';
import '@dynamic-labs/rpc-providers';
import '../../store/state/environmentId.js';
import '../../store/state/walletConnectorOptions.js';
import { Typography } from '../../components/Typography/Typography.js';
import '../../context/FooterAnimationContext/index.js';
import '../../components/ShadowDOM/ShadowDOM.js';
import '../../components/Transition/ZoomTransition/ZoomTransition.js';
import '../../components/Transition/SlideInUpTransition/SlideInUpTransition.js';
import '../../components/Transition/OpacityTransition/OpacityTransition.js';
import '../../components/OverlayCard/OverlayCardTarget/OverlayCardTarget.js';
import '../../context/SocialRedirectContext/SocialRedirectContext.js';
import '../../context/WalletGroupContext/WalletGroupContext.js';
import '../../widgets/DynamicWidget/components/DynamicWidgetHeader/DynamicWidgetHeader.js';
import 'react-focus-lock';
import { IconWithSpinner } from '../../components/IconWithSpinner/IconWithSpinner.js';
import { Icon } from '../../components/Icon/Icon.js';
import { useLoadingContext } from '../../context/LoadingContext/LoadingContext.js';
import '../../widgets/DynamicWidget/context/DynamicWidgetContext.js';
import '../../components/IconButton/IconButton.js';
import '../../components/MenuList/Dropdown/Dropdown.js';
import { ErrorContainer } from '../../components/ErrorContainer/ErrorContainer.js';
import 'formik';
import '../../store/state/sendBalances.js';
import '../../components/Input/Input.js';
import '../TransactionConfirmationView/helpers/transactionErrorMessage.js';
import '../../context/PasskeyContext/PasskeyContext.js';
import '../../widgets/DynamicWidget/views/ManagePasskeysWidgetView/PasskeyCard/PasskeyCard.js';
import '../../../polyfills.js';
import '../../context/ErrorBoundary/ErrorBoundaryBase.js';
import '../../context/ErrorBoundary/ErrorBoundaryContext.js';
import '../../widgets/DynamicBridgeWidget/context/DynamicBridgeWidgetContext/DynamicBridgeWidgetContext.js';
import '../../widgets/DynamicWidget/components/DynamicWidgetCard/DynamicWidgetCard.js';
import '../../components/IsBrowser/IsBrowser.js';
import '../../context/WidgetRegistry/WidgetRegistryContextProvider.js';
import '../../context/FundingContext/FundingContext.js';
import '../../components/Popper/Popper/Popper.js';
import '../../components/Popper/PopperContext/PopperContext.js';
import '../../widgets/DynamicBridgeWidget/views/WalletsView/components/SecondaryWallets/SecondaryWallets.js';
import '@hcaptcha/react-hcaptcha';
import { IconWithStatus } from '../../components/IconWithStatus/IconWithStatus.js';
import { PinField } from '../../components/PinField/PinField.js';
import { RetrySendVerificationCodeSection } from '../../components/RetrySendVerificationCodeSection/RetrySendVerificationCodeSection.js';
import '../../context/IpConfigurationContext/IpConfigurationContext.js';
import { TextButton } from '../../components/TextButton/TextButton.js';
import '../../components/PasskeyCreatedSuccessBanner/PasskeyCreatedSuccessBanner.js';
import '../../context/SendBalanceContext/SendBalanceContext.js';
import '../../context/ConnectWithOtpContext/ConnectWithOtpContext.js';
import '../../context/ConnectWithOtpContext/constants.js';
import '../../context/ReinitializeContext/ReinitializeContextProvider.js';
import '../../store/state/tokenBalances.js';
import '../../components/InlineWidget/InlineWidget.js';
import 'qrcode';

const SECONDS_TO_RETRY = 15;
const EmailVerification = ({ isEmailRecoveryFlow = false, showRetryButton: _showRetryButton = true, showTransferMessage: _showTransferMessage = false, }) => {
    var _a, _b, _c, _d;
    const { environmentId, handleLogOut, setPrimaryWalletId, setShowAuthFlow, projectSettings, user, userWithMissingInfo, walletConnectorOptions, primaryWallet, } = useInternalDynamicContext();
    const { setView, goToInitialView } = useViewContext();
    const { error, setError, setErrorMessage } = useErrorContext();
    const { loading, setLoading } = useLoadingContext();
    const [showRetryButton, setShowRetryButton] = useState(_showRetryButton);
    const [showTransferMessage, setShowTransferMessage] = useState(_showTransferMessage);
    const { getEOAWallet } = useSmartWallets();
    // Use a state to ensure UI is updated, but also a ref to access in effect cleanup
    const [isValidated, _setIsValidated] = useState(false);
    const isValidatedRef = useRef(isValidated);
    const setIsValidated = (value) => {
        _setIsValidated(value);
        isValidatedRef.current = value;
    };
    const { displayedDestination: email, verificationUUID, setVerificationUUID, } = useVerification();
    const { t } = useTranslation();
    const { addRecoveryEmail } = usePasskeyRecovery();
    const { isTurnkeyWallet, hasTurnkeyVerifiedCredentialAuthenticator, hasRecoveryEmail, } = useIsTurnkeyWallet();
    const isTurnkeyProviderEnabled = isTurnkeyEnabled(projectSettings);
    const { initAuth, completeAuth, cancelAuth } = useUserAuth({
        authMethod: 'email',
    });
    const { generateSessionKey, shouldRegisterSessionKeysOnSignin } = useEmbeddedWalletSessionKeys(environmentId);
    // When true, causes the component to call emailVerificationX callback on unmount
    const callCallbackOnUnmount = useRef(true);
    useOnUnmount(() => {
        if (!callCallbackOnUnmount.current)
            return;
        const emailString = email !== null && email !== void 0 ? email : '';
        dynamicEvents.emit('emailVerificationResult', isValidatedRef.current, emailString);
        if (!isValidatedRef.current)
            dynamicEvents.emit('authFailure', { email: emailString, option: emailString, type: 'email' }, 'user-cancelled');
        if (!email)
            logger.warn("WARNING: emitted emailVerificationResult with incomplete params because useVerification's displayedDestination was undefined");
    });
    const { verifyOtp } = useOtpVerificationRequest();
    const completeSignInFlow = useCallback((updateUserProfileResponse) => __awaiter(void 0, void 0, void 0, function* () {
        var _e, _f, _g, _h, _j, _k;
        if (updateUserProfileResponse.nextView === 'verified-and-transferred') {
            setShowTransferMessage === null || setShowTransferMessage === void 0 ? void 0 : setShowTransferMessage(true);
        }
        if (isEmailRecoveryFlow) {
            setView('passkey-recovery-add-email', {
                canSkipAddingEmail: false,
                isFromEmailVerification: true,
            });
            return true;
        }
        if (!isTurnkeyWallet) {
            return false;
        }
        // If the user has a turnkey embedded wallet and no recovery email, add the email as a recovery email
        // This logic should run even if the turnkey provider is not enabled anymore
        // (e.g. user created the wallet and then the settings were disalbed)
        if (hasTurnkeyVerifiedCredentialAuthenticator &&
            !hasRecoveryEmail &&
            ((_e = updateUserProfileResponse === null || updateUserProfileResponse === void 0 ? void 0 : updateUserProfileResponse.user) === null || _e === void 0 ? void 0 : _e.email)) {
            storeAuthTokenAndUser(updateUserProfileResponse);
            yield addRecoveryEmail(updateUserProfileResponse.user.email);
            setShowAuthFlow(false);
            return true;
        }
        // The logic below is needed when we capture an email after a user
        // authenticated with Sms/Twitter etc And we need to capture and email.
        if (isTurnkeyProviderEnabled) {
            const isAutomaticWalletCreation = (_g = (_f = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _f === void 0 ? void 0 : _f.embeddedWallets) === null || _g === void 0 ? void 0 : _g.automaticEmbeddedWalletCreation;
            const eoaWallet = primaryWallet && getEOAWallet(primaryWallet);
            const isSessionKeyCompatible = (primaryWallet && isSessionKeyCompatibleWallet(primaryWallet)) ||
                (eoaWallet && isSessionKeyCompatibleWallet(eoaWallet));
            const isUsingPregeneratedWallets = Boolean(isAutomaticWalletCreation &&
                (!((_j = (_h = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _h === void 0 ? void 0 : _h.embeddedWallets) === null || _j === void 0 ? void 0 : _j.forceAuthenticatorAtSignup) ||
                    isSessionKeyCompatible));
            if (isUsingPregeneratedWallets) {
                // Pregenerated wallet was created during an
                // additional email validation step as part of onboarding
                // cannot rely on newUser JWT field here due to session being counted twice
                // when authentication happens followed by a separate email kyc step
                const embeddedWalletVerifiedCredential = findEmbeddedWalletFromVerifiedCredentials(createUserProfileFromSdkUser(updateUserProfileResponse.user));
                if (!embeddedWalletVerifiedCredential) {
                    throw new Error('Could not find an embedded wallet');
                }
                const walletOption = walletConnectorOptions === null || walletConnectorOptions === void 0 ? void 0 : walletConnectorOptions.find((option) => option.key === embeddedWalletVerifiedCredential.walletName);
                if (!(walletOption === null || walletOption === void 0 ? void 0 : walletOption.walletConnector)) {
                    throw new Error('Could not find connector for embedded wallet');
                }
                const wallet = walletOption.walletConnector.createWallet({
                    address: embeddedWalletVerifiedCredential.address || '',
                    chain: walletOption.walletConnector.connectedChain,
                    connector: walletOption.walletConnector,
                    id: embeddedWalletVerifiedCredential.id,
                    isAuthenticated: false,
                    key: (_k = embeddedWalletVerifiedCredential.walletName) !== null && _k !== void 0 ? _k : '',
                });
                setPrimaryWalletId(embeddedWalletVerifiedCredential.id);
                dynamicEvents.emit('embeddedWalletCreated', wallet, embeddedWalletVerifiedCredential, user);
            }
            if (isUsingPregeneratedWallets || !isAutomaticWalletCreation) {
                setShowAuthFlow(false);
                return true;
            }
        }
        return false;
    }), [
        isEmailRecoveryFlow,
        isTurnkeyWallet,
        hasTurnkeyVerifiedCredentialAuthenticator,
        hasRecoveryEmail,
        isTurnkeyProviderEnabled,
        setView,
        addRecoveryEmail,
        setShowAuthFlow,
        (_b = (_a = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _a === void 0 ? void 0 : _a.embeddedWallets) === null || _b === void 0 ? void 0 : _b.automaticEmbeddedWalletCreation,
        (_d = (_c = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _c === void 0 ? void 0 : _c.embeddedWallets) === null || _d === void 0 ? void 0 : _d.forceAuthenticatorAtSignup,
        primaryWallet,
        getEOAWallet,
        walletConnectorOptions,
        setPrimaryWalletId,
        user,
    ]);
    const handleEmailVerification = useCallback((verificationToken) => __awaiter(void 0, void 0, void 0, function* () {
        setError(undefined);
        setLoading(true);
        if (!verificationUUID) {
            return cancelAuth();
        }
        if (!user && !userWithMissingInfo) {
            return initAuth({
                onVerifySuccess: () => setIsValidated(true),
                options: { email },
                showSuccessMessage: true,
                verifyFunction: () => __awaiter(void 0, void 0, void 0, function* () {
                    let sessionPublicKey = undefined;
                    if (shouldRegisterSessionKeysOnSignin()) {
                        const keypair = yield generateSessionKey();
                        sessionPublicKey = keypair.publicKey;
                    }
                    return signInWithEmailVerification({
                        environmentId,
                        sessionPublicKey,
                        verificationToken,
                        verificationUUID,
                    });
                }),
            });
        }
        return completeAuth({
            completeSignInFlow: (updateUserResponse) => __awaiter(void 0, void 0, void 0, function* () { return completeSignInFlow(updateUserResponse); }),
            onValidUpdatedJwt: () => {
                // This causes emaiLVerificationSuccess to be raised, so it should be set as soon
                // as verification doesn't fail. Don't move it below
                setIsValidated(true);
            },
            options: { email, isEmailRecoveryFlow },
            updateJwtFunction: () => __awaiter(void 0, void 0, void 0, function* () { return verifyOtp(verificationToken, 'email', verificationUUID); }),
        });
    }), [
        setError,
        setLoading,
        verificationUUID,
        user,
        userWithMissingInfo,
        completeAuth,
        email,
        isEmailRecoveryFlow,
        cancelAuth,
        initAuth,
        environmentId,
        completeSignInFlow,
        verifyOtp,
    ]);
    const handleRetry = () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!verificationUUID || !email) {
                return;
            }
            setLoading(true);
            const { verificationUUID: newVerificationUUID } = yield retryEmailVerification({
                email,
                environmentId,
                verificationUUID,
            });
            setVerificationUUID(newVerificationUUID);
            setError(undefined);
        }
        catch (error) {
            logger.debug(error);
            setErrorMessage(error.code);
            if (error.code === 'too_many_email_verification_attempts') {
                setShowRetryButton(false);
            }
            if (error.code === 'invalid_email_verification') {
                goToInitialView();
            }
        }
        finally {
            setLoading(false);
        }
    });
    const EmailIcon = useMemo(() => {
        const EmailIcon = (props) => (jsx(Icon, { color: 'brand-primary', children: jsx(SvgSignInWithEmail, Object.assign({}, props)) }));
        return EmailIcon;
    }, []);
    return (jsxs(Fragment, { children: [error && (jsx(ErrorContainer, { withIcon: false, className: 'email-verification__error-message', children: error })), jsxs("div", { className: classNames('email-verification__container', {
                    'email-verification__container--error': Boolean(error),
                }), children: [showTransferMessage && (jsx("div", { className: 'email-verification__transfer-message', copykey: 'dyn_otp_verification.email.complete', children: t('dyn_otp_verification.email.complete') })), isValidated ? (jsx("div", { className: 'email-verification__icon-container', children: jsx(IconWithStatus, { containerClassName: 'email-verification__icon--verified', Icon: EmailIcon, iconSize: 64, InnerIcon: SvgCheck }) })) : (jsx(IconWithSpinner, { Icon: EmailIcon, iconSize: 96, isSpinning: true, className: 'email-verification__icon-with-spinner' })), jsxs("div", { className: 'email-verification__copy-text-container', children: [jsx(Typography, { variant: 'body_normal', weight: 'regular', color: 'secondary', copykey: 'dyn_otp_verification.description', children: t('dyn_otp_verification.description') }), jsx(Typography, { variant: 'body_normal', weight: 'bold', color: 'secondary', children: shortenEmail(email) })] }), jsx(PinField, { initialValue: Array(6).join('.').split('.'), isLoading: loading, handleComplete: handleEmailVerification, isValidated: isValidated, inputMode: 'numeric', pattern: '[0-9]*', hasError: Boolean(error), onChange: () => setError(undefined) }), showRetryButton && (jsx(RetrySendVerificationCodeSection, { className: 'email-verification__retry-container', retryHandler: handleRetry, secondsToRetry: SECONDS_TO_RETRY })), (user || userWithMissingInfo) && !isEmailRecoveryFlow && (jsx(TextButton, { className: 'email-verification__log-out', onClick: handleLogOut, copykey: 'dyn_otp_verification.log_out_button', children: t('dyn_otp_verification.log_out_button') }))] })] }));
};

export { EmailVerification };
