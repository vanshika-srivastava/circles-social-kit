'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useState, useMemo, useEffect, useCallback } from 'react';
import { DynamicError } from '@dynamic-labs/utils';
import { isEmbeddedConnector, isEmailWalletConnector } from '@dynamic-labs/wallet-connector-core';
import { useInternalUserWallets } from '../../../context/UserWalletsContext/UserWalletsContext.js';
import '@dynamic-labs/sdk-api-core';
import { logger } from '../../../shared/logger.js';
import '@dynamic-labs/iconic';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '../../constants/colors.js';
import '../../constants/values.js';
import '../../../store/state/loadingAndLifecycle.js';
import '../../../shared/consts/index.js';
import { createLinkedWalletsFromWalletOptions } from './utils/createLinkedWalletsFromWalletOptions/createLinkedWalletsFromWalletOptions.js';
import { updateUserWalletsFromLinkedWallets } from './utils/updateUserWalletsFromLinkedWallets/updateUserWalletsFromLinkedWallets.js';

const useWalletConnectors = ({ authMode, connectedWallets, walletConnectorOptions, setMultiWalletWidgetState, primaryWalletId, setPrimaryWalletId, user, canHaveMultipleWalletsConnected, }) => {
    const [showQrcodeModal, setShowQrcodeModal] = useState(false);
    const linkedWallets = useMemo(() => {
        if (!user) {
            return [];
        }
        return createLinkedWalletsFromWalletOptions({
            primaryWalletId,
            user,
            walletConnectorOptions,
        });
    }, [user, primaryWalletId, walletConnectorOptions]);
    logger.logVerboseTroubleshootingMessage('linkedWallets', linkedWallets);
    const wallets = useMemo(() => {
        // Before signing the first message we are using connected wallets list
        // This is because we want the first connected wallet to have events applied by useWalletEventListeners
        // In connect-and-sign mode, events are only applied after the message is signed.
        // This change ensures that events will be applied even before the signature.
        // After signing the message user could be undefined in scenarios like OTP
        if (authMode === 'connect-and-sign' && user) {
            return linkedWallets;
        }
        /**
         * This is to handle users in connect-only who are signing in with social/email
         * with an embedded wallet
         */
        if (authMode === 'connect-only' &&
            linkedWallets.find((wallet) => isEmbeddedConnector(wallet.connector))) {
            return linkedWallets;
        }
        return connectedWallets !== null && connectedWallets !== void 0 ? connectedWallets : [];
    }, [authMode, connectedWallets, linkedWallets, user]);
    logger.logVerboseTroubleshootingMessage('wallets', wallets);
    /**
     * This useEffect is temporary.
     * While the wallet connectors don't use the event emitter, we need to manually
     * initialize the bridge between the old event listeners and the new event emitter.
     * When the wallet connectors are migrated to the new event emitter, there will be no
     * need to initialize or teardown event listeners, then we can remove this useEffect.
     */
    useEffect(() => wallets.forEach((wallet) => {
        wallet.connector.initEventListener();
    }), [wallets]);
    const { setUserWallets } = useInternalUserWallets();
    // Keep userWallets in sync whenever linkedWallets changes
    useEffect(() => {
        logger.logVerboseTroubleshootingMessage('[useWalletConnectors] will call setUserWallets', wallets);
        setUserWallets((userWallets) => updateUserWalletsFromLinkedWallets(userWallets, wallets));
    }, [setUserWallets, wallets]);
    const primaryWallet = useMemo(() => { var _a; return (_a = wallets.find((wallet) => wallet.id === primaryWalletId)) !== null && _a !== void 0 ? _a : null; }, [primaryWalletId, wallets]);
    const secondaryWallets = useMemo(() => canHaveMultipleWalletsConnected
        ? wallets.filter((wallet) => wallet.id !== primaryWalletId)
        : [], [primaryWalletId, wallets, canHaveMultipleWalletsConnected]);
    const getSelectedWallet = useCallback((walletId) => __awaiter(void 0, void 0, void 0, function* () {
        const newWallet = wallets.find(({ id }) => id === walletId);
        if (!newWallet) {
            throw new DynamicError(`Wallet with id: ${walletId} not found`);
        }
        return newWallet;
    }), [wallets]);
    const setPrimaryWallet = useCallback((walletId) => __awaiter(void 0, void 0, void 0, function* () {
        const newPrimaryWallet = yield getSelectedWallet(walletId);
        if (!primaryWalletId) {
            yield newPrimaryWallet.connector.connect();
            setPrimaryWalletId(walletId);
            return;
        }
        if (primaryWalletId === walletId)
            return;
        if (isEmailWalletConnector(newPrimaryWallet.connector)) {
            const emailConnector = newPrimaryWallet.connector;
            const email = localStorage.getItem('magic-link-email');
            if (email) {
                emailConnector.setEmail(email);
            }
        }
        setPrimaryWalletId(walletId);
        setMultiWalletWidgetState('idle');
    }), [
        getSelectedWallet,
        primaryWalletId,
        setMultiWalletWidgetState,
        setPrimaryWalletId,
    ]);
    return {
        primaryWallet,
        secondaryWallets,
        setPrimaryWallet,
        setShowQrcodeModal,
        showQrcodeModal,
        wallets,
    };
};

export { useWalletConnectors };
