'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
require('@dynamic-labs/sdk-api-core');
var logger = require('../../../shared/logger.cjs');
require('@dynamic-labs/iconic');
require('react/jsx-runtime');
require('../../../context/ViewContext/ViewContext.cjs');
require('@dynamic-labs/wallet-book');
require('@dynamic-labs/utils');
require('../../constants/colors.cjs');
require('../../constants/values.cjs');
require('../../../store/state/loadingAndLifecycle.cjs');
require('../../../shared/consts/index.cjs');
var useDynamicEvents = require('../events/useDynamicEvents/useDynamicEvents.cjs');
var useWalletConnectorEvent = require('../events/useWalletConnectorEvent/useWalletConnectorEvent.cjs');
var dynamicEvents = require('../../../events/dynamicEvents.cjs');

const useWalletEventListeners = ({ disconnectWallet, handleLogOut, multiWallet, multiWalletWidgetState, primaryWallet, secondaryWallets, selectedWalletConnector, selectedWalletWithAction, setSelectedWalletConnectorKey, setSelectedWalletWithAction, setMultiWalletWidgetState, user, setPrimaryWalletId, authMode, refreshConnectedWallet, detectNewWalletsForLinking, }) => {
    useWalletConnectorEvent.useWalletConnectorEvent(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector, 'chainChange', ({ chain }) => {
        logger.logger.debug('primary wallet chain change', { chain });
        if (!primaryWallet) {
            return;
        }
        refreshConnectedWallet(primaryWallet.id, primaryWallet.connector);
    });
    const handleAccountChangeWhenAwaitingAccountSwitch = React.useCallback((isPrimaryWallet, newAddress) => {
        logger.logger.debug('handleAccountChangeWhenAwaitingAccountSwitch', {
            isPrimaryWallet,
            newAddress,
        });
        const linkedSecondaryWallet = secondaryWallets.find((wallet) => walletConnectorCore.isSameAddress(wallet.address, newAddress, wallet.chain));
        logger.logger.logVerboseTroubleshootingMessage('[handleAccountChangeWhenAwaitingAccountSwitch]', { linkedSecondaryWallet });
        // this means the user is linking a new account, so we need proof of ownership...
        if (!linkedSecondaryWallet) {
            setMultiWalletWidgetState('awaiting_signature', undefined, 'linking_new_wallet');
            if (isPrimaryWallet && primaryWallet) {
                setSelectedWalletConnectorKey(primaryWallet.connector.key);
            }
            return;
        }
        const isTryingToUpdateUnkownWallet = linkedSecondaryWallet.connector.key === 'unknown';
        if (isTryingToUpdateUnkownWallet) {
            //prompt the user to connect and sign with the wallet
            dynamicEvents.dynamicEvents.emit('triggerConnectAndSign');
            return;
        }
        // ...otherwise, the user is switching primary accounts betweeen the same wallet
        setSelectedWalletWithAction(null);
        setPrimaryWalletId(linkedSecondaryWallet.id);
        setMultiWalletWidgetState('idle');
    }, [
        setMultiWalletWidgetState,
        primaryWallet,
        secondaryWallets,
        setSelectedWalletConnectorKey,
        setSelectedWalletWithAction,
        setPrimaryWalletId,
    ]);
    const calculatePrimaryWalletMultiWalletStateFromAccounts = React.useCallback(({ accounts }) => {
        logger.logger.debug('calculatePrimaryWalletMultiWalletStateFromAccounts', {
            accounts,
            authMode,
            multiWallet,
            multiWalletWidgetState,
            primaryWallet,
        });
        // change the api here
        if (!primaryWallet)
            return;
        const [newAddress] = accounts;
        const changedAddress = !walletConnectorCore.isSameAddress(newAddress, primaryWallet.address, primaryWallet.chain);
        if (!changedAddress) {
            setMultiWalletWidgetState('idle');
            return;
        }
        if (authMode === 'connect-only') {
            refreshConnectedWallet(primaryWallet.id, primaryWallet.connector);
            return;
        }
        if (!multiWallet) {
            return;
        }
        if (multiWalletWidgetState === 'awaiting_account_switch') {
            handleAccountChangeWhenAwaitingAccountSwitch(true, newAddress);
            return;
        }
        if (multiWalletWidgetState !== 'idle') {
            logger.logger.error(`Unexpected multiWalletWidgetState (${multiWalletWidgetState}) and onAccountChange combination. Resetting state to idle.`);
            setMultiWalletWidgetState('idle');
        }
        const newWallet = secondaryWallets.find((wallet) => walletConnectorCore.isSameAddress(wallet.address, newAddress, wallet.chain));
        if (newWallet) {
            setPrimaryWalletId(newWallet.id);
            return;
        }
        if (user && detectNewWalletsForLinking) {
            setMultiWalletWidgetState('detected_new_wallet');
            setSelectedWalletConnectorKey(primaryWallet.connector.key);
        }
    }, [
        authMode,
        detectNewWalletsForLinking,
        handleAccountChangeWhenAwaitingAccountSwitch,
        multiWallet,
        multiWalletWidgetState,
        primaryWallet,
        refreshConnectedWallet,
        secondaryWallets,
        setMultiWalletWidgetState,
        setPrimaryWalletId,
        setSelectedWalletConnectorKey,
        user,
    ]);
    useDynamicEvents.useInternalDynamicEvents('triggerComputePrimaryWalletMultiWalletStateFromAccounts', calculatePrimaryWalletMultiWalletStateFromAccounts);
    useWalletConnectorEvent.useWalletConnectorEvent(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector, 'accountChange', ({ accounts }) => {
        logger.logger.debug('primary wallet account change', {
            accounts,
        });
        calculatePrimaryWalletMultiWalletStateFromAccounts({ accounts });
    });
    const uniqueNonPrimaryWallets = React.useMemo(() => {
        const primaryConnector = primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector;
        const secondaryConnectors = secondaryWallets.map(({ connector }) => connector);
        const allWalletConnectors = new Set([
            ...secondaryConnectors,
            primaryConnector,
            selectedWalletConnector,
        ].filter((connector) => Boolean(connector)));
        if (primaryConnector) {
            allWalletConnectors.delete(primaryConnector);
        }
        return Array.from(allWalletConnectors);
    }, [secondaryWallets, selectedWalletConnector, primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector]);
    useWalletConnectorEvent.useWalletConnectorEvent(uniqueNonPrimaryWallets, 'accountChange', (_, changedConnector) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        logger.logger.debug('secondary wallet account change');
        if (authMode === 'connect-only' && secondaryWallets.length) {
            const affectedWallets = secondaryWallets.filter(({ connector }) => connector.key === changedConnector.key);
            for (const wallet of affectedWallets)
                refreshConnectedWallet(wallet.id, wallet.connector);
            return;
        }
        if (multiWalletWidgetState === 'awaiting_account_switch') {
            handleAccountChangeWhenAwaitingAccountSwitch(false, (selectedWalletWithAction === null || selectedWalletWithAction === void 0 ? void 0 : selectedWalletWithAction.wallet.address) || '');
        }
    }));
    useWalletConnectorEvent.useWalletConnectorEvent(uniqueNonPrimaryWallets, 'chainChange', (_, changedConnector) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        logger.logger.debug('secondary wallet chain change');
        // Get all wallets with this connector
        const affectedWallets = secondaryWallets.filter(({ connector }) => connector.key === changedConnector.key);
        for (const wallet of affectedWallets)
            refreshConnectedWallet(wallet.id, wallet.connector);
    }));
    useWalletConnectorEvent.useWalletConnectorEvent(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector, 'disconnect', () => {
        logger.logger.debug('primary wallet disconnect');
        if (authMode === 'connect-only') {
            handleLogOut();
        }
    });
    useWalletConnectorEvent.useWalletConnectorEvent(uniqueNonPrimaryWallets, 'disconnect', (affectedConnector) => {
        logger.logger.debug('secondary wallet disconnect');
        if (authMode === 'connect-only') {
            // Get all wallets with this connector
            const affectedWallets = secondaryWallets.filter(({ connector }) => connector.key === affectedConnector.key);
            for (const wallet of affectedWallets) {
                disconnectWallet(wallet.id);
            }
        }
    });
};

exports.useWalletEventListeners = useWalletEventListeners;
