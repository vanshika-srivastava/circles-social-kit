'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var logger = require('../../../shared/logger.cjs');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
require('react/jsx-runtime');
require('../../../context/ViewContext/ViewContext.cjs');
require('@dynamic-labs/wallet-book');
require('@dynamic-labs/utils');
require('../../constants/colors.cjs');
require('../../constants/values.cjs');
require('../../../store/state/loadingAndLifecycle.cjs');
require('../../../shared/consts/index.cjs');
require('@dynamic-labs/multi-wallet');
require('react-international-phone');
require('../../../config/ApiEndpoint.cjs');
var user = require('../../../store/state/user/user.cjs');
require('../../../locale/locale.cjs');
var user$1 = require('../../../data/api/user/user.cjs');
var isCookieEnabled = require('../../functions/isCookieEnabled/isCookieEnabled.cjs');

const useResetCookieLocalStorage = ({ environmentId, projectSettings, setPrimaryWalletId, }) => {
    const didRefreshUserRef = React.useRef(false);
    const user$2 = user.getUser();
    /**
     * run this effect every time the user or project settings change
     * but not when the process was already done.
     */
    React.useEffect(() => {
        /**
         * this method is called on refresh of DynamicContext and attempts to refresh local storage
         * when cookies are enabled for the environment.
         * the use case here is when an end user logs in to sub1.example.com and navigates to sub2.example.com.
         * if they are signed in to sub1.example.com with a cookie for `.example.com`, but the LS is specific
         * to sub1, then navigating to sub2 will mean they are not automatically signed in.
         * this method attempts to fetch the user from the backend using the cookie (if aavailable), and if successful,
         * this will ensure local storage is properly set with the user.
         *
         * this will also attempt to set the primaryWalletId, if the last verified credential is a wallet
         * the user might have signed in with a wallet in the other subdomain, but the primary wallet
         * in local storage does not carry over to other subdomains (LS is subdomain-specific),
         * so attempt to set it here.
         */
        const maybeInitUserRefresh = () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            if (!user$2 && isCookieEnabled.isCookieEnabled()) {
                // Disable all next calls to this method
                didRefreshUserRef.current = true;
                try {
                    const user = yield user$1.refreshUserJwt({ environmentId });
                    /**
                     * attempt to set primary wallet in this subdomain because LS does not
                     * carry over between different subdomains, even if the cookie does
                     */
                    const lastVerifiedWallet = user === null || user === void 0 ? void 0 : user.verifiedCredentials.find((vc) => vc.format === sdkApiCore.JwtVerifiedCredentialFormatEnum.Blockchain &&
                        vc.id === user.lastVerifiedCredentialId);
                    if (lastVerifiedWallet)
                        setPrimaryWalletId(lastVerifiedWallet.id);
                }
                catch (e) {
                    logger.logger.debug('Ignore failed refreshUserJwt in useResetCookieLocalStorage');
                }
            }
        });
        // Ensure this effect only runs once
        if (didRefreshUserRef.current)
            return;
        maybeInitUserRefresh();
    }, [user$2, projectSettings]);
};

exports.useResetCookieLocalStorage = useResetCookieLocalStorage;
