'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useRef, useEffect } from 'react';
import { JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';
import { logger } from '../../../shared/logger.js';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '@dynamic-labs/utils';
import '../../constants/colors.js';
import '../../constants/values.js';
import '../../../store/state/loadingAndLifecycle.js';
import '../../../shared/consts/index.js';
import '@dynamic-labs/multi-wallet';
import 'react-international-phone';
import '../../../config/ApiEndpoint.js';
import { getUser } from '../../../store/state/user/user.js';
import '../../../locale/locale.js';
import { refreshUserJwt } from '../../../data/api/user/user.js';
import { isCookieEnabled } from '../../functions/isCookieEnabled/isCookieEnabled.js';

const useResetCookieLocalStorage = ({ environmentId, projectSettings, setPrimaryWalletId, }) => {
    const didRefreshUserRef = useRef(false);
    const user = getUser();
    /**
     * run this effect every time the user or project settings change
     * but not when the process was already done.
     */
    useEffect(() => {
        /**
         * this method is called on refresh of DynamicContext and attempts to refresh local storage
         * when cookies are enabled for the environment.
         * the use case here is when an end user logs in to sub1.example.com and navigates to sub2.example.com.
         * if they are signed in to sub1.example.com with a cookie for `.example.com`, but the LS is specific
         * to sub1, then navigating to sub2 will mean they are not automatically signed in.
         * this method attempts to fetch the user from the backend using the cookie (if aavailable), and if successful,
         * this will ensure local storage is properly set with the user.
         *
         * this will also attempt to set the primaryWalletId, if the last verified credential is a wallet
         * the user might have signed in with a wallet in the other subdomain, but the primary wallet
         * in local storage does not carry over to other subdomains (LS is subdomain-specific),
         * so attempt to set it here.
         */
        const maybeInitUserRefresh = () => __awaiter(void 0, void 0, void 0, function* () {
            if (!user && isCookieEnabled()) {
                // Disable all next calls to this method
                didRefreshUserRef.current = true;
                try {
                    const user = yield refreshUserJwt({ environmentId });
                    /**
                     * attempt to set primary wallet in this subdomain because LS does not
                     * carry over between different subdomains, even if the cookie does
                     */
                    const lastVerifiedWallet = user === null || user === void 0 ? void 0 : user.verifiedCredentials.find((vc) => vc.format === JwtVerifiedCredentialFormatEnum.Blockchain &&
                        vc.id === user.lastVerifiedCredentialId);
                    if (lastVerifiedWallet)
                        setPrimaryWalletId(lastVerifiedWallet.id);
                }
                catch (e) {
                    logger.debug('Ignore failed refreshUserJwt in useResetCookieLocalStorage');
                }
            }
        });
        // Ensure this effect only runs once
        if (didRefreshUserRef.current)
            return;
        maybeInitUserRefresh();
    }, [user, projectSettings]);
};

export { useResetCookieLocalStorage };
