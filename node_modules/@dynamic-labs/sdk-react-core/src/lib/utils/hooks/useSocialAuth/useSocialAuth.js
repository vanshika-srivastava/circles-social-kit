'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useMemo, useState } from 'react';
import { ProviderEnum } from '@dynamic-labs/sdk-api-core';
import { SocialOAuthErrorCode } from '@dynamic-labs/types';
import { isMobile, Oauth2Service, PlatformService, SocialAccountAlreadyExistsError } from '@dynamic-labs/utils';
import '../../../context/DynamicContext/DynamicContext.js';
import { logger } from '../../../shared/logger.js';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '../../constants/colors.js';
import '../../constants/values.js';
import '../../../store/state/loadingAndLifecycle.js';
import '../../../shared/consts/index.js';
import { dynamicEvents } from '../../../events/dynamicEvents.js';
import '../../../context/CaptchaContext/CaptchaContext.js';
import { useErrorContext } from '../../../context/ErrorContext/ErrorContext.js';
import { digestSHA256 } from '../../functions/digestSHA256/digestSHA256.js';
import { encodeBase64URL } from '../../functions/encodeBase64URL/encodeBase64URL.js';
import '@dynamic-labs/multi-wallet';
import 'react-international-phone';
import { getOauthLoginUrl } from '../../functions/getOauthLoginUrl/getOauthLoginUrl.js';
import { setSocialStorageFor } from '../../functions/socialStorage/socialStorage.js';
import { getProviderByType } from '../../functions/getProviderByType/getProviderByType.js';
import { randomString } from '../../functions/randomString/randomString.js';
import '../../../config/ApiEndpoint.js';
import '../../../store/state/user/user.js';
import { getOAuthResult, initAuth, telegramSignIn, signInOAuth, telegramVerify, verifyOAuth, farcasterSignIn, farcasterVerify } from '../../../data/api/oauth/oauth.js';
import '../../../locale/locale.js';
import '../../../store/state/projectSettings/projectSettings.js';
import '../../../context/AccessDeniedContext/AccessDeniedContext.js';
import '../../../context/AccountExistsContext/AccountExistsContext.js';
import '../../../context/UserWalletsContext/UserWalletsContext.js';
import '../../../context/VerificationContext/VerificationContext.js';
import 'react-dom';
import '../../../context/WalletContext/WalletContext.js';
import '../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/constants.js';
import '../../../context/ThemeContext/ThemeContext.js';
import '../useUserUpdateRequest/useUpdateUser/userFieldsSchema.js';
import { useUserAuth } from '../useUserAuth/useUserAuth.js';
import { useEmbeddedWalletSessionKeys } from '../useEmbeddedWalletSessionKeys/useEmbeddedWalletSessionKeys.js';
import { connect, watchStatus } from './farcaster/farcaster.js';
import 'yup';
import '../../../context/MockContext/MockContext.js';
import '../../../views/CollectUserDataView/useFields.js';
import '../../../context/FieldsStateContext/FieldsStateContext.js';
import '../../../context/UserFieldEditorContext/UserFieldEditorContext.js';
import '@dynamic-labs/rpc-providers';
import '../../../store/state/environmentId.js';
import '../../../store/state/walletConnectorOptions.js';
import 'react-i18next';
import '../../../components/Accordion/components/AccordionItem/AccordionItem.js';
import '../../../components/Alert/Alert.js';
import '../../../components/ShadowDOM/ShadowDOM.js';
import '../../../components/IconButton/IconButton.js';
import '../../../components/InlineWidget/InlineWidget.js';
import '../../../components/Input/Input.js';
import '../../../components/IsBrowser/IsBrowser.js';
import '../../../components/MenuList/Dropdown/Dropdown.js';
import '../../../components/Transition/ZoomTransition/ZoomTransition.js';
import '../../../components/Transition/SlideInUpTransition/SlideInUpTransition.js';
import '../../../components/Transition/OpacityTransition/OpacityTransition.js';
import '../../../components/OverlayCard/OverlayCardTarget/OverlayCardTarget.js';
import '../../../components/PasskeyCreatedSuccessBanner/PasskeyCreatedSuccessBanner.js';
import '../../../components/Popper/Popper/Popper.js';
import '../../../components/Popper/PopperContext/PopperContext.js';
import 'react-focus-lock';
import 'qrcode';
import 'formik';
import '../../../context/FooterAnimationContext/index.js';
import '../../../context/WalletGroupContext/WalletGroupContext.js';
import '../../../context/SocialRedirectContext/SocialRedirectContext.js';
import '../../../widgets/DynamicBridgeWidget/views/WalletsView/components/SecondaryWallets/SecondaryWallets.js';
import '@hcaptcha/react-hcaptcha';
import '../../../context/LoadingContext/LoadingContext.js';
import '../../../widgets/DynamicWidget/context/DynamicWidgetContext.js';
import '../../../context/IpConfigurationContext/IpConfigurationContext.js';
import '../../../context/PasskeyContext/PasskeyContext.js';
import '../../../store/state/sendBalances.js';
import '../../../widgets/DynamicWidget/components/DynamicWidgetHeader/DynamicWidgetHeader.js';
import '../../../views/TransactionConfirmationView/helpers/transactionErrorMessage.js';
import '../../../widgets/DynamicWidget/views/ManagePasskeysWidgetView/PasskeyCard/PasskeyCard.js';
import '../../../../polyfills.js';
import '../../../context/ErrorBoundary/ErrorBoundaryBase.js';
import '../../../context/ErrorBoundary/ErrorBoundaryContext.js';
import '../../../widgets/DynamicBridgeWidget/context/DynamicBridgeWidgetContext/DynamicBridgeWidgetContext.js';
import '../../../widgets/DynamicWidget/components/DynamicWidgetCard/DynamicWidgetCard.js';
import '../../../context/WidgetRegistry/WidgetRegistryContextProvider.js';
import '../../../context/FundingContext/FundingContext.js';
import '../../../context/SendBalanceContext/SendBalanceContext.js';
import '../../../context/ConnectWithOtpContext/ConnectWithOtpContext.js';
import '../../../context/ConnectWithOtpContext/constants.js';
import '../../../context/ReinitializeContext/ReinitializeContextProvider.js';
import '../../../store/state/tokenBalances.js';
import { useInternalDynamicContext } from '../../../context/DynamicContext/useDynamicContext/useInternalDynamicContext.js';

const socialProviders = [
    'apple',
    'coinbasesocial',
    'discord',
    'facebook',
    'farcaster',
    'github',
    'google',
    'instagram',
    'telegram',
    'twitch',
    'twitter',
];
// pkce params are only required for twitter and break if added for other providers, like google
// so we should only add provider that support pkce to this list
const providersRequiringPkce = ['twitter', 'github'];
// Hook to handle common social auth logic (for social linking and social sign in)
const useSocialAuth = ({ sessionTimeout, onSettled, onError, onFarcasterUrl, }) => {
    const { environmentId, setShowAuthFlow, socialSettings, projectSettings, consumeNonce, redirectUrl: defaultRedirectUrl, } = useInternalDynamicContext();
    /**
     * Represents if the SDK will use a popup or redirect for social auth
     */
    const strategy = useMemo(() => (socialSettings === null || socialSettings === void 0 ? void 0 : socialSettings.strategy) || 'redirect', [socialSettings]);
    const { setErrorMessage, setError: setContextError } = useErrorContext();
    const { initAuth: initAuth$1 } = useUserAuth({
        authMethod: 'social',
    });
    const { generateSessionKey, shouldRegisterSessionKeysOnSignin } = useEmbeddedWalletSessionKeys(environmentId);
    const [isProcessing, setIsProcessing] = useState(false);
    const [error, setError] = useState();
    const clearError = () => {
        setError(undefined);
        setContextError(undefined);
    };
    const onFailed = (provider, reason, options) => {
        setIsProcessing(false);
        onError === null || onError === void 0 ? void 0 : onError();
        onSettled === null || onSettled === void 0 ? void 0 : onSettled();
        if (provider && (options === null || options === void 0 ? void 0 : options.raiseAuthFailure))
            dynamicEvents.emit('authFailure', {
                option: provider,
                provider,
                type: 'social',
            }, reason);
    };
    const handleError = (provider, code, message, options) => {
        const error = { code, message };
        logger.error(message);
        setError(error);
        setErrorMessage(code);
        onFailed(provider, { error }, options);
    };
    const checkValidProvider = (provider, authMode) => {
        if (!provider) {
            handleError(provider, SocialOAuthErrorCode.NO_PROVIDER, 'Provider is required', { raiseAuthFailure: authMode === 'signin' });
            return false;
        }
        if (!socialProviders.includes(provider)) {
            handleError(provider, SocialOAuthErrorCode.INVALID_PROVIDER, `Invalid social provider. Valid providers are: ${socialProviders.join(', ')}`, { raiseAuthFailure: authMode === 'signin' });
            return false;
        }
        return true;
    };
    const linkAccount = (provider, apiCall) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const response = yield apiCall();
            if (!response) {
                handleError(provider, SocialOAuthErrorCode.VERIFICATION_ERROR, `Failed to link social account: ${provider}`, { raiseAuthFailure: false });
                return;
            }
            onSettled === null || onSettled === void 0 ? void 0 : onSettled();
        }
        catch (error) {
            if (error instanceof SocialAccountAlreadyExistsError) {
                handleError(provider, SocialOAuthErrorCode.ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE, `Social account already linked to a different profile: ${provider}`, { raiseAuthFailure: false });
            }
        }
    });
    const signInAccount = (provider, apiCall) => __awaiter(void 0, void 0, void 0, function* () {
        yield initAuth$1({
            onError: () => handleError(provider, SocialOAuthErrorCode.SIGNIN_ERROR, `Failed to sign-in with social account: ${provider}`, { raiseAuthFailure: true }),
            onSettled,
            options: { provider },
            verifyFunction: () => apiCall(),
        });
    });
    const connectSocialAccount = (_a) => __awaiter(void 0, [_a], void 0, function* ({ authMode, provider, validator, captchaToken, redirectUrl, telegramAuthToken, }) {
        var _b, _c;
        clearError();
        setIsProcessing(true);
        if (!authMode) {
            logger.error('Auth mode is required. Please use either "link" or "signin"');
            return;
        }
        if (!checkValidProvider(provider, authMode)) {
            return;
        }
        // invalid connect request
        if (validator && !validator(provider)) {
            return;
        }
        dynamicEvents.emit('authInit', {
            option: provider,
            provider,
            type: 'social',
        });
        if (provider === ProviderEnum.Farcaster) {
            return connectWithFarcaster(authMode, {
                captchaToken,
                redirectUrl,
            });
        }
        const state = randomString(32);
        const verifier = randomString(43);
        // Whether we will use PKCE (code verifier/challenge) for this provider
        const usingPkce = providersRequiringPkce.includes(provider);
        setSocialStorageFor(provider, {
            captchaToken,
            codeVerifier: usingPkce ? verifier : undefined,
            state,
        });
        const loginUrlString = getOauthLoginUrl((_b = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.providers) !== null && _b !== void 0 ? _b : [], provider);
        if (!loginUrlString) {
            handleError(provider, SocialOAuthErrorCode.NO_OAUTH_URL, `Failed to get login url to connect social account: ${provider}`, { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        const oauthLoginUrl = new URL(loginUrlString);
        oauthLoginUrl.searchParams.set('state', state);
        // only add pkce params for providers that support/require it
        if (usingPkce) {
            const digest = yield digestSHA256(verifier);
            oauthLoginUrl.searchParams.set('code_challenge', encodeBase64URL(digest));
            oauthLoginUrl.searchParams.set('code_challenge_method', 'S256');
        }
        const isMobile$1 = isMobile();
        try {
            const authCode = yield Oauth2Service.getOauthCode({
                apiProvider: getProviderByType((_c = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.providers) !== null && _c !== void 0 ? _c : [], provider),
                getOAuthResultFromApi: () => getOAuthResult(environmentId, provider, {
                    state,
                }),
                initWebAuth: ({ redirectUrl } = {}) => initAuth(environmentId, provider, {
                    redirectUrl: redirectUrl
                        ? removeDynamicOauthParamsFromUrl(redirectUrl)
                        : undefined,
                    state,
                }),
                isMobile: isMobile$1,
                oauthLoginUrl,
                onSettled,
                provider,
                redirectUrl: redirectUrl !== null && redirectUrl !== void 0 ? redirectUrl : defaultRedirectUrl,
                sessionTimeout,
                setIsProcessing,
                state,
                strategy,
            });
            yield completeConnection({
                authCode,
                authMode,
                captchaToken,
                provider,
                state,
                telegramAuthToken,
                verifier,
            });
        }
        catch (error) {
            if (!Oauth2Service.isGetOauthCodeError(error)) {
                logger.error('Social connection failed with unexpected error:', error);
                onFailed(provider, { error }, { raiseAuthFailure: authMode === 'signin' });
                return;
            }
            if (error === 'user-cancelled')
                onFailed(provider, 'user-cancelled');
            else {
                handleError(provider, error.code, error.message, {
                    raiseAuthFailure: authMode === 'signin',
                });
            }
        }
    });
    const completeConnection = (_d) => __awaiter(void 0, [_d], void 0, function* ({ authMode, provider, state, authCode, captchaToken, verifier, telegramAuthToken, }) {
        try {
            let sessionPublicKey = undefined;
            if (shouldRegisterSessionKeysOnSignin()) {
                const keypair = yield generateSessionKey();
                sessionPublicKey = keypair.publicKey;
            }
            if (authMode === 'signin') {
                if (provider === ProviderEnum.Telegram && telegramAuthToken) {
                    const apiCall = () => telegramSignIn(environmentId, {
                        sessionPublicKey,
                        telegramAuthToken,
                    });
                    yield signInAccount(provider, apiCall);
                }
                else if (provider === ProviderEnum.Telegram) {
                    const apiCall = () => telegramSignIn(environmentId, {
                        code: authCode,
                        sessionPublicKey,
                        state,
                    });
                    yield signInAccount(provider, apiCall);
                }
                else {
                    const apiCall = () => signInOAuth(environmentId, provider, {
                        captchaToken,
                        code: authCode,
                        codeVerifier: verifier,
                        sessionPublicKey,
                        state,
                    });
                    yield signInAccount(provider, apiCall);
                }
            }
            else {
                if (provider === ProviderEnum.Telegram) {
                    const apiCall = () => telegramVerify(environmentId, {
                        code: authCode,
                        state,
                    });
                    yield linkAccount(provider, apiCall);
                }
                else {
                    const apiCall = () => verifyOAuth(environmentId, provider, {
                        code: authCode,
                        codeVerifier: verifier,
                        state,
                    });
                    yield linkAccount(provider, apiCall);
                }
            }
        }
        catch (error) {
            logger.error('Social connection failed with unexpected error:', error);
            onFailed(provider, { error }, { raiseAuthFailure: authMode === 'signin' });
        }
    });
    const connectWithFarcaster = (authMode_1, _e) => __awaiter(void 0, [authMode_1, _e], void 0, function* (authMode, { captchaToken, redirectUrl }) {
        const dynamicNonce = consumeNonce();
        const domain = PlatformService.getHost();
        const data = yield connect({
            domain,
            nonce: dynamicNonce,
            redirectUrl: redirectUrl || defaultRedirectUrl,
            siweUri: PlatformService.getOrigin(),
        });
        if (!(data === null || data === void 0 ? void 0 : data.url) || !(data === null || data === void 0 ? void 0 : data.channelToken)) {
            handleError(ProviderEnum.Farcaster, SocialOAuthErrorCode.GENERAL_ERROR, "Farcaster didn't return a valid url.", { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        // If on mobile, we want to redirect to the Warpcast app.
        if (isMobile()) {
            yield PlatformService.openURL(data.url);
        }
        else {
            setShowAuthFlow(true);
            onFarcasterUrl === null || onFarcasterUrl === void 0 ? void 0 : onFarcasterUrl(data.url);
        }
        const status = yield watchStatus({
            channelToken: data.channelToken,
        });
        if (status === 'cancelled') {
            setIsProcessing(false);
            return;
        }
        // Error
        if (status === 'timeout' ||
            status === 'rejected' ||
            !(status === null || status === void 0 ? void 0 : status.message) ||
            !(status === null || status === void 0 ? void 0 : status.custody) ||
            !(status === null || status === void 0 ? void 0 : status.signature) ||
            !(status === null || status === void 0 ? void 0 : status.nonce)) {
            handleError(ProviderEnum.Farcaster, SocialOAuthErrorCode.GENERAL_ERROR, "Farcaster didn't return valid data.", { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        const { custody: address, message, signature, nonce } = status;
        if (authMode === 'signin') {
            let sessionPublicKey = undefined;
            if (shouldRegisterSessionKeysOnSignin()) {
                const keypair = yield generateSessionKey();
                sessionPublicKey = keypair.publicKey;
            }
            const apiCall = () => farcasterSignIn(environmentId, {
                address,
                captchaToken,
                domain,
                message,
                nonce,
                sessionPublicKey,
                signature,
            });
            yield signInAccount(ProviderEnum.Farcaster, apiCall);
        }
        else {
            const apiCall = () => farcasterVerify({
                environmentId,
                farcasterSignInRequest: {
                    address,
                    captchaToken,
                    domain,
                    message,
                    nonce,
                    signature,
                },
            });
            yield linkAccount(ProviderEnum.Farcaster, apiCall);
            setShowAuthFlow(false, { clearErrors: false });
        }
        setIsProcessing(false);
    });
    return {
        checkValidProvider,
        completeConnection,
        connectSocialAccount,
        error,
        handleError,
        isProcessing,
        setError,
        setIsProcessing,
    };
};
const removeDynamicOauthParamsFromUrl = (url) => {
    const urlObject = new URL(url);
    urlObject.searchParams.delete('dynamicOauthState');
    urlObject.searchParams.delete('dynamicOauthCode');
    return urlObject.toString();
};

export { useSocialAuth };
