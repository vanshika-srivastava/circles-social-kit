'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var types = require('@dynamic-labs/types');
var utils = require('@dynamic-labs/utils');
require('../../../context/DynamicContext/DynamicContext.cjs');
var logger = require('../../../shared/logger.cjs');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
require('react/jsx-runtime');
require('../../../context/ViewContext/ViewContext.cjs');
require('@dynamic-labs/wallet-book');
require('../../constants/colors.cjs');
require('../../constants/values.cjs');
require('../../../store/state/loadingAndLifecycle.cjs');
require('../../../shared/consts/index.cjs');
var dynamicEvents = require('../../../events/dynamicEvents.cjs');
require('../../../context/CaptchaContext/CaptchaContext.cjs');
var ErrorContext = require('../../../context/ErrorContext/ErrorContext.cjs');
var digestSHA256 = require('../../functions/digestSHA256/digestSHA256.cjs');
var encodeBase64URL = require('../../functions/encodeBase64URL/encodeBase64URL.cjs');
require('@dynamic-labs/multi-wallet');
require('react-international-phone');
var getOauthLoginUrl = require('../../functions/getOauthLoginUrl/getOauthLoginUrl.cjs');
var socialStorage = require('../../functions/socialStorage/socialStorage.cjs');
var getProviderByType = require('../../functions/getProviderByType/getProviderByType.cjs');
var randomString = require('../../functions/randomString/randomString.cjs');
require('../../../config/ApiEndpoint.cjs');
require('../../../store/state/user/user.cjs');
var oauth = require('../../../data/api/oauth/oauth.cjs');
require('../../../locale/locale.cjs');
require('../../../store/state/projectSettings/projectSettings.cjs');
require('../../../context/AccessDeniedContext/AccessDeniedContext.cjs');
require('../../../context/AccountExistsContext/AccountExistsContext.cjs');
require('../../../context/UserWalletsContext/UserWalletsContext.cjs');
require('../../../context/VerificationContext/VerificationContext.cjs');
require('react-dom');
require('../../../context/WalletContext/WalletContext.cjs');
require('../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/constants.cjs');
require('../../../context/ThemeContext/ThemeContext.cjs');
require('../useUserUpdateRequest/useUpdateUser/userFieldsSchema.cjs');
var useUserAuth = require('../useUserAuth/useUserAuth.cjs');
var useEmbeddedWalletSessionKeys = require('../useEmbeddedWalletSessionKeys/useEmbeddedWalletSessionKeys.cjs');
var farcaster = require('./farcaster/farcaster.cjs');
require('yup');
require('../../../context/MockContext/MockContext.cjs');
require('../../../views/CollectUserDataView/useFields.cjs');
require('../../../context/FieldsStateContext/FieldsStateContext.cjs');
require('../../../context/UserFieldEditorContext/UserFieldEditorContext.cjs');
require('@dynamic-labs/rpc-providers');
require('../../../store/state/environmentId.cjs');
require('../../../store/state/walletConnectorOptions.cjs');
require('react-i18next');
require('../../../components/Accordion/components/AccordionItem/AccordionItem.cjs');
require('../../../components/Alert/Alert.cjs');
require('../../../components/ShadowDOM/ShadowDOM.cjs');
require('../../../components/IconButton/IconButton.cjs');
require('../../../components/InlineWidget/InlineWidget.cjs');
require('../../../components/Input/Input.cjs');
require('../../../components/IsBrowser/IsBrowser.cjs');
require('../../../components/MenuList/Dropdown/Dropdown.cjs');
require('../../../components/Transition/ZoomTransition/ZoomTransition.cjs');
require('../../../components/Transition/SlideInUpTransition/SlideInUpTransition.cjs');
require('../../../components/Transition/OpacityTransition/OpacityTransition.cjs');
require('../../../components/OverlayCard/OverlayCardTarget/OverlayCardTarget.cjs');
require('../../../components/PasskeyCreatedSuccessBanner/PasskeyCreatedSuccessBanner.cjs');
require('../../../components/Popper/Popper/Popper.cjs');
require('../../../components/Popper/PopperContext/PopperContext.cjs');
require('react-focus-lock');
require('qrcode');
require('formik');
require('../../../context/FooterAnimationContext/index.cjs');
require('../../../context/WalletGroupContext/WalletGroupContext.cjs');
require('../../../context/SocialRedirectContext/SocialRedirectContext.cjs');
require('../../../widgets/DynamicBridgeWidget/views/WalletsView/components/SecondaryWallets/SecondaryWallets.cjs');
require('@hcaptcha/react-hcaptcha');
require('../../../context/LoadingContext/LoadingContext.cjs');
require('../../../widgets/DynamicWidget/context/DynamicWidgetContext.cjs');
require('../../../context/IpConfigurationContext/IpConfigurationContext.cjs');
require('../../../context/PasskeyContext/PasskeyContext.cjs');
require('../../../store/state/sendBalances.cjs');
require('../../../widgets/DynamicWidget/components/DynamicWidgetHeader/DynamicWidgetHeader.cjs');
require('../../../views/TransactionConfirmationView/helpers/transactionErrorMessage.cjs');
require('../../../widgets/DynamicWidget/views/ManagePasskeysWidgetView/PasskeyCard/PasskeyCard.cjs');
require('../../../../polyfills.cjs');
require('../../../context/ErrorBoundary/ErrorBoundaryBase.cjs');
require('../../../context/ErrorBoundary/ErrorBoundaryContext.cjs');
require('../../../widgets/DynamicBridgeWidget/context/DynamicBridgeWidgetContext/DynamicBridgeWidgetContext.cjs');
require('../../../widgets/DynamicWidget/components/DynamicWidgetCard/DynamicWidgetCard.cjs');
require('../../../context/WidgetRegistry/WidgetRegistryContextProvider.cjs');
require('../../../context/FundingContext/FundingContext.cjs');
require('../../../context/SendBalanceContext/SendBalanceContext.cjs');
require('../../../context/ConnectWithOtpContext/ConnectWithOtpContext.cjs');
require('../../../context/ConnectWithOtpContext/constants.cjs');
require('../../../context/ReinitializeContext/ReinitializeContextProvider.cjs');
require('../../../store/state/tokenBalances.cjs');
var useInternalDynamicContext = require('../../../context/DynamicContext/useDynamicContext/useInternalDynamicContext.cjs');

const socialProviders = [
    'apple',
    'coinbasesocial',
    'discord',
    'facebook',
    'farcaster',
    'github',
    'google',
    'instagram',
    'telegram',
    'twitch',
    'twitter',
];
// pkce params are only required for twitter and break if added for other providers, like google
// so we should only add provider that support pkce to this list
const providersRequiringPkce = ['twitter', 'github'];
// Hook to handle common social auth logic (for social linking and social sign in)
const useSocialAuth = ({ sessionTimeout, onSettled, onError, onFarcasterUrl, }) => {
    const { environmentId, setShowAuthFlow, socialSettings, projectSettings, consumeNonce, redirectUrl: defaultRedirectUrl, } = useInternalDynamicContext.useInternalDynamicContext();
    /**
     * Represents if the SDK will use a popup or redirect for social auth
     */
    const strategy = React.useMemo(() => (socialSettings === null || socialSettings === void 0 ? void 0 : socialSettings.strategy) || 'redirect', [socialSettings]);
    const { setErrorMessage, setError: setContextError } = ErrorContext.useErrorContext();
    const { initAuth } = useUserAuth.useUserAuth({
        authMethod: 'social',
    });
    const { generateSessionKey, shouldRegisterSessionKeysOnSignin } = useEmbeddedWalletSessionKeys.useEmbeddedWalletSessionKeys(environmentId);
    const [isProcessing, setIsProcessing] = React.useState(false);
    const [error, setError] = React.useState();
    const clearError = () => {
        setError(undefined);
        setContextError(undefined);
    };
    const onFailed = (provider, reason, options) => {
        setIsProcessing(false);
        onError === null || onError === void 0 ? void 0 : onError();
        onSettled === null || onSettled === void 0 ? void 0 : onSettled();
        if (provider && (options === null || options === void 0 ? void 0 : options.raiseAuthFailure))
            dynamicEvents.dynamicEvents.emit('authFailure', {
                option: provider,
                provider,
                type: 'social',
            }, reason);
    };
    const handleError = (provider, code, message, options) => {
        const error = { code, message };
        logger.logger.error(message);
        setError(error);
        setErrorMessage(code);
        onFailed(provider, { error }, options);
    };
    const checkValidProvider = (provider, authMode) => {
        if (!provider) {
            handleError(provider, types.SocialOAuthErrorCode.NO_PROVIDER, 'Provider is required', { raiseAuthFailure: authMode === 'signin' });
            return false;
        }
        if (!socialProviders.includes(provider)) {
            handleError(provider, types.SocialOAuthErrorCode.INVALID_PROVIDER, `Invalid social provider. Valid providers are: ${socialProviders.join(', ')}`, { raiseAuthFailure: authMode === 'signin' });
            return false;
        }
        return true;
    };
    const linkAccount = (provider, apiCall) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const response = yield apiCall();
            if (!response) {
                handleError(provider, types.SocialOAuthErrorCode.VERIFICATION_ERROR, `Failed to link social account: ${provider}`, { raiseAuthFailure: false });
                return;
            }
            onSettled === null || onSettled === void 0 ? void 0 : onSettled();
        }
        catch (error) {
            if (error instanceof utils.SocialAccountAlreadyExistsError) {
                handleError(provider, types.SocialOAuthErrorCode.ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE, `Social account already linked to a different profile: ${provider}`, { raiseAuthFailure: false });
            }
        }
    });
    const signInAccount = (provider, apiCall) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        yield initAuth({
            onError: () => handleError(provider, types.SocialOAuthErrorCode.SIGNIN_ERROR, `Failed to sign-in with social account: ${provider}`, { raiseAuthFailure: true }),
            onSettled,
            options: { provider },
            verifyFunction: () => apiCall(),
        });
    });
    const connectSocialAccount = (_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ authMode, provider, validator, captchaToken, redirectUrl, telegramAuthToken, }) {
        var _b, _c;
        clearError();
        setIsProcessing(true);
        if (!authMode) {
            logger.logger.error('Auth mode is required. Please use either "link" or "signin"');
            return;
        }
        if (!checkValidProvider(provider, authMode)) {
            return;
        }
        // invalid connect request
        if (validator && !validator(provider)) {
            return;
        }
        dynamicEvents.dynamicEvents.emit('authInit', {
            option: provider,
            provider,
            type: 'social',
        });
        if (provider === sdkApiCore.ProviderEnum.Farcaster) {
            return connectWithFarcaster(authMode, {
                captchaToken,
                redirectUrl,
            });
        }
        const state = randomString.randomString(32);
        const verifier = randomString.randomString(43);
        // Whether we will use PKCE (code verifier/challenge) for this provider
        const usingPkce = providersRequiringPkce.includes(provider);
        socialStorage.setSocialStorageFor(provider, {
            captchaToken,
            codeVerifier: usingPkce ? verifier : undefined,
            state,
        });
        const loginUrlString = getOauthLoginUrl.getOauthLoginUrl((_b = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.providers) !== null && _b !== void 0 ? _b : [], provider);
        if (!loginUrlString) {
            handleError(provider, types.SocialOAuthErrorCode.NO_OAUTH_URL, `Failed to get login url to connect social account: ${provider}`, { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        const oauthLoginUrl = new URL(loginUrlString);
        oauthLoginUrl.searchParams.set('state', state);
        // only add pkce params for providers that support/require it
        if (usingPkce) {
            const digest = yield digestSHA256.digestSHA256(verifier);
            oauthLoginUrl.searchParams.set('code_challenge', encodeBase64URL.encodeBase64URL(digest));
            oauthLoginUrl.searchParams.set('code_challenge_method', 'S256');
        }
        const isMobile = utils.isMobile();
        try {
            const authCode = yield utils.Oauth2Service.getOauthCode({
                apiProvider: getProviderByType.getProviderByType((_c = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.providers) !== null && _c !== void 0 ? _c : [], provider),
                getOAuthResultFromApi: () => oauth.getOAuthResult(environmentId, provider, {
                    state,
                }),
                initWebAuth: ({ redirectUrl } = {}) => oauth.initAuth(environmentId, provider, {
                    redirectUrl: redirectUrl
                        ? removeDynamicOauthParamsFromUrl(redirectUrl)
                        : undefined,
                    state,
                }),
                isMobile,
                oauthLoginUrl,
                onSettled,
                provider,
                redirectUrl: redirectUrl !== null && redirectUrl !== void 0 ? redirectUrl : defaultRedirectUrl,
                sessionTimeout,
                setIsProcessing,
                state,
                strategy,
            });
            yield completeConnection({
                authCode,
                authMode,
                captchaToken,
                provider,
                state,
                telegramAuthToken,
                verifier,
            });
        }
        catch (error) {
            if (!utils.Oauth2Service.isGetOauthCodeError(error)) {
                logger.logger.error('Social connection failed with unexpected error:', error);
                onFailed(provider, { error }, { raiseAuthFailure: authMode === 'signin' });
                return;
            }
            if (error === 'user-cancelled')
                onFailed(provider, 'user-cancelled');
            else {
                handleError(provider, error.code, error.message, {
                    raiseAuthFailure: authMode === 'signin',
                });
            }
        }
    });
    const completeConnection = (_d) => _tslib.__awaiter(void 0, [_d], void 0, function* ({ authMode, provider, state, authCode, captchaToken, verifier, telegramAuthToken, }) {
        try {
            let sessionPublicKey = undefined;
            if (shouldRegisterSessionKeysOnSignin()) {
                const keypair = yield generateSessionKey();
                sessionPublicKey = keypair.publicKey;
            }
            if (authMode === 'signin') {
                if (provider === sdkApiCore.ProviderEnum.Telegram && telegramAuthToken) {
                    const apiCall = () => oauth.telegramSignIn(environmentId, {
                        sessionPublicKey,
                        telegramAuthToken,
                    });
                    yield signInAccount(provider, apiCall);
                }
                else if (provider === sdkApiCore.ProviderEnum.Telegram) {
                    const apiCall = () => oauth.telegramSignIn(environmentId, {
                        code: authCode,
                        sessionPublicKey,
                        state,
                    });
                    yield signInAccount(provider, apiCall);
                }
                else {
                    const apiCall = () => oauth.signInOAuth(environmentId, provider, {
                        captchaToken,
                        code: authCode,
                        codeVerifier: verifier,
                        sessionPublicKey,
                        state,
                    });
                    yield signInAccount(provider, apiCall);
                }
            }
            else {
                if (provider === sdkApiCore.ProviderEnum.Telegram) {
                    const apiCall = () => oauth.telegramVerify(environmentId, {
                        code: authCode,
                        state,
                    });
                    yield linkAccount(provider, apiCall);
                }
                else {
                    const apiCall = () => oauth.verifyOAuth(environmentId, provider, {
                        code: authCode,
                        codeVerifier: verifier,
                        state,
                    });
                    yield linkAccount(provider, apiCall);
                }
            }
        }
        catch (error) {
            logger.logger.error('Social connection failed with unexpected error:', error);
            onFailed(provider, { error }, { raiseAuthFailure: authMode === 'signin' });
        }
    });
    const connectWithFarcaster = (authMode_1, _e) => _tslib.__awaiter(void 0, [authMode_1, _e], void 0, function* (authMode, { captchaToken, redirectUrl }) {
        const dynamicNonce = consumeNonce();
        const domain = utils.PlatformService.getHost();
        const data = yield farcaster.connect({
            domain,
            nonce: dynamicNonce,
            redirectUrl: redirectUrl || defaultRedirectUrl,
            siweUri: utils.PlatformService.getOrigin(),
        });
        if (!(data === null || data === void 0 ? void 0 : data.url) || !(data === null || data === void 0 ? void 0 : data.channelToken)) {
            handleError(sdkApiCore.ProviderEnum.Farcaster, types.SocialOAuthErrorCode.GENERAL_ERROR, "Farcaster didn't return a valid url.", { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        // If on mobile, we want to redirect to the Warpcast app.
        if (utils.isMobile()) {
            yield utils.PlatformService.openURL(data.url);
        }
        else {
            setShowAuthFlow(true);
            onFarcasterUrl === null || onFarcasterUrl === void 0 ? void 0 : onFarcasterUrl(data.url);
        }
        const status = yield farcaster.watchStatus({
            channelToken: data.channelToken,
        });
        if (status === 'cancelled') {
            setIsProcessing(false);
            return;
        }
        // Error
        if (status === 'timeout' ||
            status === 'rejected' ||
            !(status === null || status === void 0 ? void 0 : status.message) ||
            !(status === null || status === void 0 ? void 0 : status.custody) ||
            !(status === null || status === void 0 ? void 0 : status.signature) ||
            !(status === null || status === void 0 ? void 0 : status.nonce)) {
            handleError(sdkApiCore.ProviderEnum.Farcaster, types.SocialOAuthErrorCode.GENERAL_ERROR, "Farcaster didn't return valid data.", { raiseAuthFailure: authMode === 'signin' });
            return;
        }
        const { custody: address, message, signature, nonce } = status;
        if (authMode === 'signin') {
            let sessionPublicKey = undefined;
            if (shouldRegisterSessionKeysOnSignin()) {
                const keypair = yield generateSessionKey();
                sessionPublicKey = keypair.publicKey;
            }
            const apiCall = () => oauth.farcasterSignIn(environmentId, {
                address,
                captchaToken,
                domain,
                message,
                nonce,
                sessionPublicKey,
                signature,
            });
            yield signInAccount(sdkApiCore.ProviderEnum.Farcaster, apiCall);
        }
        else {
            const apiCall = () => oauth.farcasterVerify({
                environmentId,
                farcasterSignInRequest: {
                    address,
                    captchaToken,
                    domain,
                    message,
                    nonce,
                    signature,
                },
            });
            yield linkAccount(sdkApiCore.ProviderEnum.Farcaster, apiCall);
            setShowAuthFlow(false, { clearErrors: false });
        }
        setIsProcessing(false);
    });
    return {
        checkValidProvider,
        completeConnection,
        connectSocialAccount,
        error,
        handleError,
        isProcessing,
        setError,
        setIsProcessing,
    };
};
const removeDynamicOauthParamsFromUrl = (url) => {
    const urlObject = new URL(url);
    urlObject.searchParams.delete('dynamicOauthState');
    urlObject.searchParams.delete('dynamicOauthCode');
    return urlObject.toString();
};

exports.useSocialAuth = useSocialAuth;
