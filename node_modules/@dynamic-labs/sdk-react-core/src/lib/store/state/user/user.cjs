'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var hasPendingRequirements = require('../../../shared/utils/functions/hasPendingRequirements/hasPendingRequirements.cjs');
var createStoreState = require('../../internalImplementation/utils/createStoreState/createStoreState.cjs');

const { getUser, setUser, useUser: useUserRaw } = createStoreState.createStoreState('user');
const useUser = () => {
    // after user has fully logged in (user is defined), it should never go back to
    // not being fully logged in (userWithMissingInfo defined instead of user),
    // unless it's logged out (no user or userWithMissingInfo defined)
    const hasFullyLoggedIn = React.useRef(false);
    const userFromStore = useUserRaw();
    if (!userFromStore) {
        hasFullyLoggedIn.current = false;
        return {};
    }
    // adding userWithMissingInfo to avoid breaking changes for customer who consider that when we have a user,
    // it means that they are already fully authenticated.
    // since we won't have onboarding jwt anymore, the idea is to just store the user in LS and either use the user state
    // or userWithMissingInfo, depending on the value of missing fields or mfa required.
    // this is just following our existing logic of how we handle authToken vs onboardingOnlyToken.
    if (!hasFullyLoggedIn.current && hasPendingRequirements.hasPendingRequirements(userFromStore)) {
        return { userWithMissingInfo: userFromStore };
    }
    hasFullyLoggedIn.current = true;
    return { user: userFromStore };
};

exports.getUser = getUser;
exports.setUser = setUser;
exports.useUser = useUser;
