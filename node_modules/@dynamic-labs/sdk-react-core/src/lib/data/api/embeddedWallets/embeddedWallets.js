'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { EmbeddedWalletProviderEnum, EmbeddedWalletChainEnum } from '@dynamic-labs/sdk-api-core';
import { DynamicError } from '@dynamic-labs/utils';
import { logger } from '../../../shared/logger.js';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import 'react';
import '@dynamic-labs/wallet-book';
import '../../../utils/constants/colors.js';
import '../../../utils/constants/values.js';
import '../../../store/state/loadingAndLifecycle.js';
import '../../../shared/consts/index.js';
import { storeAuthTokenAndUser } from '../../../store/state/user/storeAuthTokenAndUser/storeAuthTokenAndUser.js';
import '../../../store/state/user/user.js';
import { sdkApi } from '../api.js';

const createTurnkeyEmbeddedWallet = (_a) => __awaiter(void 0, [_a], void 0, function* ({ attestation, challenge, environmentId, chains = [EmbeddedWalletChainEnum.Evm], passkeyAlias, }) {
    const embeddedWallets = [
        {
            chains,
            embeddedWalletProvider: EmbeddedWalletProviderEnum.Turnkeyhd,
            isAuthenticatorAttached: false,
            passkeyAlias,
        },
    ];
    if (attestation && challenge) {
        embeddedWallets[0] = Object.assign(Object.assign({}, embeddedWallets[0]), { embeddedWalletSpecificOpts: {
                attestation,
                challenge,
            }, isAuthenticatorAttached: true });
    }
    try {
        const response = yield sdkApi().createEmbeddedWallets({
            createEmbeddedWalletsRequest: {
                embeddedWallets,
            },
            environmentId,
        });
        const user = storeAuthTokenAndUser(response);
        return user;
    }
    catch (e) {
        logger.error('Error creating embedded wallet: ', e);
        return undefined;
    }
});
const initEmbeddedWalletSession = (_b) => __awaiter(void 0, [_b], void 0, function* ({ authenticatorType, walletId, publicKey, environmentId, }) {
    if (authenticatorType === 'passkey') {
        return sdkApi().initPasskeyRecovery({
            environmentId,
            initPasskeyRecoveryRequest: {
                turnkeyRecoveryTargetPublicKey: publicKey,
                walletId,
            },
        });
    }
    return sdkApi().initEmailAuth({
        environmentId,
        initEmailAuthRequest: {
            turnkeyEmailAuthTargetPublicKey: publicKey,
            walletId,
        },
    });
});
const completePasskeyRecovery = (_c) => __awaiter(void 0, [_c], void 0, function* ({ walletId, attestation, challenge, environmentId, }) {
    try {
        const response = yield sdkApi().completePasskeyRecovery({
            completePasskeyRecoveryRequest: {
                attestation,
                challenge,
                walletId,
            },
            environmentId,
        });
        return storeAuthTokenAndUser(response);
    }
    catch (e) {
        logger.error('Error completing passkey recovery: ', e);
        return undefined;
    }
});
const updatePasskeyRecoveryEmail = (_d) => __awaiter(void 0, [_d], void 0, function* ({ environmentId, updateRecoveryEmailRequest, }) {
    try {
        yield sdkApi().updateEmbeddedWalletRecoveryEmail({
            environmentId,
            updateRecoveryEmailRequest,
        });
    }
    catch (e) {
        logger.error('Error while trying to update recovery email: ', e);
        throw new DynamicError('Error updating recovery email');
    }
});
const getUserPasskeys = (_e) => __awaiter(void 0, [_e], void 0, function* ({ environmentId, }) {
    try {
        const data = yield sdkApi().getUserPasskeys({
            environmentId,
        });
        return data;
    }
    catch (e) {
        logger.error(e);
        return {
            count: 0,
            passkeys: [],
        };
    }
});
const updateUserPasskey = (_f) => __awaiter(void 0, [_f], void 0, function* ({ environmentId, id, alias, }) {
    try {
        const data = yield sdkApi().updatePasskey({
            environmentId,
            updateUserPasskeyRequest: { alias, id },
        });
        return data;
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
});
const exportEmbeddedWallet = (_g) => __awaiter(void 0, [_g], void 0, function* ({ environmentId, walletId, activityId, }) {
    try {
        const data = yield sdkApi().embeddedWalletExport({
            activityId,
            environmentId,
            walletId,
        });
        return data;
    }
    catch (e) {
        logger.error(e);
        return { exportBundle: '' };
    }
});
const getWalletAuthToken = (_h) => __awaiter(void 0, [_h], void 0, function* ({ environmentId, type, }) {
    try {
        const authToken = yield sdkApi().getAuthToken({
            environmentId,
            type,
        });
        return authToken.token;
    }
    catch (e) {
        return undefined;
    }
});
const getEmbeddedWalletBackup = (_j) => __awaiter(void 0, [_j], void 0, function* ({ environmentId, }) {
    try {
        const response = yield sdkApi().getEmbeddedWalletBackups({
            environmentId,
        });
        return response.secret;
    }
    catch (e) {
        return undefined;
    }
});
const getEmbeddedWalletPasscode = (_k) => __awaiter(void 0, [_k], void 0, function* ({ environmentId, }) {
    try {
        const response = yield sdkApi().getEmbeddedWalletPasscode({
            environmentId,
        });
        return response.secret;
    }
    catch (e) {
        return undefined;
    }
});
const claimEmbeddedWallet = (_l) => __awaiter(void 0, [_l], void 0, function* ({ environmentId, walletId, }) {
    var _m, _o;
    try {
        const response = yield sdkApi().claimEmbeddedWallet({
            embeddedWalletPasscodeClaimRequest: {
                walletId,
            },
            environmentId,
        });
        storeAuthTokenAndUser(response);
        return response;
    }
    catch (e) {
        logger.error(e);
        // request failed, return unknown error
        const data = yield ((_m = e === null || e === void 0 ? void 0 : e.json) === null || _m === void 0 ? void 0 : _m.call(e));
        if (!((_o = data === null || data === void 0 ? void 0 : data.error) === null || _o === void 0 ? void 0 : _o.code)) {
            return { code: 'unknown_error' };
        }
        throw e;
    }
});
const registerSessionKey = (_p) => __awaiter(void 0, [_p], void 0, function* ({ environmentId, publicKey, }) {
    try {
        yield sdkApi().registerSessionKey({
            environmentId,
            registerSessionKeyRequest: { publicKey },
        });
        return publicKey;
    }
    catch (e) {
        logger.error('Error registering session key', e);
        return undefined;
    }
});
const getCreateEmbeddedWalletAccountRequest = (_q) => __awaiter(void 0, [_q], void 0, function* ({ environmentId, chain, }) {
    try {
        const response = yield sdkApi().getCreateWalletAccountRequest({
            chain,
            environmentId,
        });
        return response;
    }
    catch (e) {
        logger.error('Error fetching create embedded wallet account request: ', e);
        throw new DynamicError('Error fetching create embedded wallet account request');
    }
});
const createEmbeddedWalletAccount = (_r) => __awaiter(void 0, [_r], void 0, function* ({ environmentId, createEmbeddedWalletAccountRequest, }) {
    try {
        const response = yield sdkApi().createWalletAccount({
            createWalletAccountRequest: {
                turnkeySignedRequest: createEmbeddedWalletAccountRequest,
            },
            environmentId,
        });
        return response;
    }
    catch (e) {
        logger.error('Error creating embedded wallet account: ', e);
        throw new DynamicError('Error creating embedded wallet account');
    }
});

export { claimEmbeddedWallet, completePasskeyRecovery, createEmbeddedWalletAccount, createTurnkeyEmbeddedWallet, exportEmbeddedWallet, getCreateEmbeddedWalletAccountRequest, getEmbeddedWalletBackup, getEmbeddedWalletPasscode, getUserPasskeys, getWalletAuthToken, initEmbeddedWalletSession, registerSessionKey, updatePasskeyRecoveryEmail, updateUserPasskey };
