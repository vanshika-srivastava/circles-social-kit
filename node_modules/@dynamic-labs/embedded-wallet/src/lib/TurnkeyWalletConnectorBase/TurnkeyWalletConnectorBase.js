'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { getTLD, PlatformService, DynamicError } from '@dynamic-labs/utils';
import { base64UrlEncode } from '../utils/base64UrlEncode/base64UrlEncode.js';
import { generateRandomBuffer } from '../utils/generateRandomBuffer/generateRandomBuffer.js';
import { convertAttestationTransports } from '../utils/convertAttestationTransports/convertAttestationTransports.js';
import { logger } from '../utils/logger/logger.js';
import { turnkeyAuthenticatorRecoveryHandler } from '../AuthenticatorHandler/TurnkeyAuthenticatorRecoveryHandler.js';
import { ExportHandler } from '../ExportHandler/ExportHandler.js';
import { PasskeyService } from '../utils/PasskeyService/PasskeyService.js';

class TurnkeyWalletConnectorBase extends WalletConnectorBase {
    constructor(nameAndKey, props) {
        super(props);
        // Public fields
        this.requiresNonDynamicEmailOtp = false;
        this.isEmbeddedWallet = true;
        this.removeSessionKeys = () => __awaiter(this, void 0, void 0, function* () {
            TurnkeyWalletConnectorBase.sessionKeys = undefined;
            TurnkeyWalletConnectorBase.apiKeyStamper = undefined;
            ExportHandler.apiKeyStamper = undefined;
            if (typeof (this === null || this === void 0 ? void 0 : this.removeSessionKeysFunction) === 'function') {
                this.removeSessionKeysFunction();
            }
        });
        if (!props.appName) {
            throw new Error('appName not set');
        }
        this.name = nameAndKey.name;
        this.overrideKey = nameAndKey.key;
        this.appName = props.appName;
        this.__authenticatorMethodHandler = turnkeyAuthenticatorRecoveryHandler;
        this.__exportHandler = new ExportHandler();
    }
    getWebAuthnAttestation() {
        return __awaiter(this, void 0, void 0, function* () {
            const challenge = generateRandomBuffer();
            const authenticatorUserId = generateRandomBuffer();
            const { email, passkeyIdentifier } = this;
            if (!email && !passkeyIdentifier) {
                throw new Error('Email or passkeyIdentifier must be set to register a webauthn credential.');
            }
            const displayName = email || `${this.appName} - ${passkeyIdentifier}`;
            const webAuthnCreateParams = {
                publicKey: {
                    authenticatorSelection: {
                        authenticatorAttachment: undefined,
                        requireResidentKey: false,
                        residentKey: 'preferred',
                        userVerification: 'discouraged',
                    },
                    challenge,
                    pubKeyCredParams: [
                        {
                            alg: -7,
                            type: 'public-key',
                        },
                    ],
                    rp: {
                        id: getTLD(),
                        name: this.appName,
                    },
                    user: {
                        displayName,
                        id: authenticatorUserId,
                        name: email || `${this.appName} - ${passkeyIdentifier}`,
                    },
                },
            };
            let attestation;
            try {
                attestation = yield PasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
            }
            catch (error) {
                logger.warn(`Unable to register webauthn credential on the current page's TLD ${getTLD()}. Falling back to using hostname. ${PlatformService.getHostname()}`, error);
                // Create the passkey on the hostname instead.
                webAuthnCreateParams.publicKey.rp.id = PlatformService.getHostname();
                attestation = yield PasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
            }
            return {
                attestation: {
                    attestationObject: attestation.attestationObject,
                    clientDataJson: attestation.clientDataJson,
                    credentialId: attestation.credentialId,
                    transports: convertAttestationTransports(attestation.transports),
                },
                challenge: base64UrlEncode(challenge),
                displayName,
            };
        });
    }
    getAuthenticatorHandler() {
        return this.__authenticatorMethodHandler;
    }
    getExportHandler() {
        return this.__exportHandler;
    }
    // Public methods
    get email() {
        return this._email;
    }
    setEmail(email) {
        this._email = email;
    }
    get phone() {
        return this._phone;
    }
    setPhone(phone) {
        this._phone = phone;
    }
    get passkeyIdentifier() {
        return this._passkeyIdentifier;
    }
    setPasskeyIdentifier(passkeyIdentifier) {
        this._passkeyIdentifier = passkeyIdentifier;
    }
    clearEmail() {
        this._email = null;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const verifiedCredentials = this.verifiedCredentials || [];
            const addresses = verifiedCredentials
                .map((vc) => vc === null || vc === void 0 ? void 0 : vc.address)
                .filter((a) => typeof a === 'string');
            return addresses;
        });
    }
    get turnkeyAddress() {
        var _a;
        const { address } = (_a = this.verifiedCredential) !== null && _a !== void 0 ? _a : {};
        return address;
    }
    get walletProperties() {
        const { walletProperties } = this.verifiedCredential || {};
        return walletProperties;
    }
    // Private methods
    set verifiedCredentials(verifiedCredentials) {
        this._verifiedCredentials = verifiedCredentials;
    }
    get verifiedCredentials() {
        return this._verifiedCredentials;
    }
    set verifiedCredential(verifiedCredential) {
        this._verifiedCredential = verifiedCredential;
    }
    get verifiedCredential() {
        return this._verifiedCredential;
    }
    setSessionKeyFetcher(func) {
        this.createOrRestoreSessionFetcherFunction = func;
    }
    setSessionKeyRemoveFunction(func) {
        this.removeSessionKeysFunction = func;
    }
    createOrRestoreSession() {
        return __awaiter(this, arguments, void 0, function* ({ ignoreRestore, } = {}) {
            if (!this.isSessionKeyCompatible() ||
                TurnkeyWalletConnectorBase.isLoadingSession) {
                return;
            }
            if (!this.createOrRestoreSessionFetcherFunction) {
                throw new DynamicError('Cannot register session key to init provider');
            }
            const { sessionKeys } = TurnkeyWalletConnectorBase;
            if (sessionKeys === null || sessionKeys === void 0 ? void 0 : sessionKeys.publicKey) {
                const isExpired = new Date() >= new Date(sessionKeys.expirationDate);
                if (!isExpired)
                    return sessionKeys.publicKey;
            }
            try {
                TurnkeyWalletConnectorBase.isLoadingSession = true;
                const sessionKeys = yield this.createOrRestoreSessionFetcherFunction({
                    ignoreRestore,
                });
                TurnkeyWalletConnectorBase.sessionKeys = sessionKeys;
                TurnkeyWalletConnectorBase.apiKeyStamper = new ApiKeyStamper({
                    apiPrivateKey: sessionKeys.privateKey,
                    apiPublicKey: sessionKeys.publicKey,
                });
                ExportHandler.apiKeyStamper = TurnkeyWalletConnectorBase.apiKeyStamper;
                logger.setMetaData('sessionApiPublicKey', sessionKeys.publicKey);
                return sessionKeys.publicKey;
            }
            catch (error) {
                throw new DynamicError('Failed to create or restore session');
            }
            finally {
                TurnkeyWalletConnectorBase.isLoadingSession = false;
            }
        });
    }
    isSessionKeyCompatible() {
        var _a;
        const walletProperties = (_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.walletProperties;
        const isSessionKeyCompatible = walletProperties === null || walletProperties === void 0 ? void 0 : walletProperties.isSessionKeyCompatible;
        return Boolean(isSessionKeyCompatible);
    }
    isSessionActive() {
        return __awaiter(this, void 0, void 0, function* () {
            const hasWallet = yield this.getAddress();
            return Boolean(hasWallet &&
                TurnkeyWalletConnectorBase.sessionKeys &&
                TurnkeyWalletConnectorBase.apiKeyStamper);
        });
    }
    get sessionKeys() {
        return TurnkeyWalletConnectorBase.sessionKeys;
    }
    setLoggerMetadata() {
        var _a, _b, _c;
        logger.setMetaData('turnkeySubOrganizationId', (_b = (_a = this._verifiedCredential) === null || _a === void 0 ? void 0 : _a.walletProperties) === null || _b === void 0 ? void 0 : _b.turnkeySubOrganizationId);
        logger.setMetaData('walletId', (_c = this._verifiedCredential) === null || _c === void 0 ? void 0 : _c.id);
        let authMethod = 'Unknown';
        if (this.isSessionKeyCompatible()) {
            authMethod = 'SessionKeys';
        }
        else if (this.__authenticatorMethodHandler.recoveryType === 'passkey') {
            authMethod = 'Passkey';
        }
        else if (this.__authenticatorMethodHandler.recoveryType === 'email') {
            authMethod = 'EmailAuth';
        }
        logger.setMetaData('authMethod', authMethod);
    }
}
TurnkeyWalletConnectorBase.isLoadingSession = false;

export { TurnkeyWalletConnectorBase };
