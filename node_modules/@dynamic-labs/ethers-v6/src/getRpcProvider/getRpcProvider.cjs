'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var ethers = require('ethers');
var ethereumCore = require('@dynamic-labs/ethereum-core');

/**
 * Gets the RPC provider of an ethereum wallet.
 *
 * If the wallet is NOT an Ethereum wallet, this will reject.
 */
const getRpcProvider = (wallet) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    if (!ethereumCore.isEthereumWallet(wallet))
        throw new Error(`getRpcProvider must be called with an Ethereum wallet, but wallet was of chain ${wallet.chain}`);
    const publicClient = yield wallet.getPublicClient();
    const { chain, transport } = publicClient;
    const network = {
        chainId: chain === null || chain === void 0 ? void 0 : chain.id,
        ensAddress: (_b = (_a = chain === null || chain === void 0 ? void 0 : chain.contracts) === null || _a === void 0 ? void 0 : _a.ensRegistry) === null || _b === void 0 ? void 0 : _b.address,
        name: chain === null || chain === void 0 ? void 0 : chain.name,
    };
    if (transport.type !== 'fallback') {
        return new ethers.JsonRpcProvider(transport.url, network);
    }
    const providers = transport.transports.map(({ value }) => new ethers.JsonRpcProvider(value === null || value === void 0 ? void 0 : value.url, network));
    if (providers.length === 1)
        return providers[0];
    return new ethers.FallbackProvider(providers);
});

exports.getRpcProvider = getRpcProvider;
