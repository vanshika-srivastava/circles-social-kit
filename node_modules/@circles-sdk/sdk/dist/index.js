import { Token__factory, Hub__factory } from '@circles-sdk/abi-v1';
import { crcToTc, cidV0ToUint8Array, addressToUInt256, tcToCrc } from '@circles-sdk/utils';
import { ethers, formatEther, parseEther, ZeroAddress } from 'ethers';
import { CirclesRpc, CirclesData } from '@circles-sdk/data';
export { Observable } from '@circles-sdk/data';
import { Migration__factory, Hub__factory as Hub__factory$1, NameRegistry__factory } from '@circles-sdk/abi-v2';
import { Profiles } from '@circles-sdk/profiles';

class V1Avatar {
    get address() {
        if (!this.avatarInfo) {
            throw new Error('Avatar is not initialized');
        }
        return this.avatarInfo.avatar;
    }
    // TODO: Empty stream makes no sense
    // readonly events: Observable<AvatarEvent> = Observable.create<AvatarEvent>().property;
    get v1Token() {
        return this._v1Token;
    }
    constructor(sdk, avatarInfo) {
        this.sdk = sdk;
        this.avatarInfo = avatarInfo;
        if (!this.avatarInfo.hasV1) {
            throw new Error('Avatar is not a v1 avatar');
        }
        if (this.avatarInfo.v1Token) {
            this._v1Token = Token__factory.connect(this.avatarInfo.v1Token, this.sdk.contractRunner);
        }
    }
    /**
     * Utilizes the pathfinder to find the max. transferable amount from the avatar to `to`.
     * @param to The recipient
     * @param tokenId The token to transfer (address). Leave empty to allow transitive transfers.
     * @returns The max. transferable amount at the time.
     */
    async getMaxTransferableAmount(to, tokenId) {
        this.throwIfNotInitialized();
        if (tokenId) {
            const tokenInfo = await this.sdk.data.getTokenInfo(tokenId);
            if (!tokenInfo) {
                throw new Error('Token not found');
            }
            const tokenBalances = await this.sdk.data.getTokenBalances(this.address);
            const tokenBalance = tokenBalances.filter(b => b.token === tokenId)[0]?.balance;
            return BigInt(tokenBalance ?? 0);
        }
        this.throwIfPathfinderIsNotAvailable();
        const largeAmount = BigInt('999999999999999999999999999999');
        const transferPath = await this.sdk.v1Pathfinder.getTransferPath(this.address, to, largeAmount);
        if (!transferPath.isValid) {
            return Promise.resolve(BigInt(0));
        }
        return transferPath.maxFlow;
    }
    /**
     * Utilizes the pathfinder to transitively send `amount` Circles to `to`.
     * @param to The recipient
     * @param amount The amount to send
     */
    async transfer(to, amount) {
        this.throwIfNotInitialized();
        this.throwIfPathfinderIsNotAvailable();
        const transferPath = await this.sdk.v1Pathfinder.getTransferPath(this.address, to, amount);
        if (!transferPath.isValid || transferPath.transferSteps.length === 0) {
            throw new Error(`Couldn't find a valid path from ${this.address} to ${to} for ${amount}.`);
        }
        const tokenOwners = transferPath.transferSteps.map(o => o.token_owner);
        const srcs = transferPath.transferSteps.map(o => o.from);
        const dests = transferPath.transferSteps.map(o => o.to);
        const wads = transferPath.transferSteps.map(o => BigInt(o.value));
        const tx = await this.sdk.v1Hub.transferThrough(tokenOwners, srcs, dests, wads);
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error(`The transferThrough call for '${this.address} -> ${to}: ${amount}' didn't yield a receipt.`);
        }
        return receipt;
    }
    async trust(avatar) {
        this.throwIfNotInitialized();
        const tx = await this.sdk.v1Hub.trust(avatar, BigInt(100));
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error(`The trust call for '${this.address} -> ${avatar}' didn't yield a receipt.`);
        }
        return receipt;
    }
    async untrust(avatar) {
        this.throwIfNotInitialized();
        const tx = await this.sdk.v1Hub.trust(avatar, BigInt(0));
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error(`The untrust call for '${this.address} -> ${avatar}' didn't yield a receipt.`);
        }
        return receipt;
    }
    async getMintableAmount() {
        if (!this.v1Token) {
            return 0;
        }
        const availableCrcToMint = await this.v1Token.look();
        return crcToTc(new Date(), availableCrcToMint);
    }
    async personalMint() {
        this.throwIfNotInitialized();
        if (!this.v1Token) {
            throw new Error('Avatar does not have a token to mint');
        }
        if (await this.v1Token.stopped()) {
            throw new Error('Avatar token is stopped');
        }
        const tx = await this.v1Token.update();
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('The update call didn\'t yield a receipt');
        }
        return receipt;
    }
    async stop() {
        this.throwIfNotInitialized();
        if (!this.v1Token) {
            throw new Error('Avatar does not have a token to stop');
        }
        if (await this.v1Token.stopped()) {
            throw new Error('Avatar token is already stopped');
        }
        const tx = await this.v1Token.stop();
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('The stop call didn\'t yield a receipt');
        }
        return receipt;
    }
    throwIfNotInitialized() {
        if (this.avatarInfo) {
            return;
        }
        throw new Error('Avatar is either not initialized or is not signed up at Circles.');
    }
    async getTrustRelations() {
        return this.sdk.data.getAggregatedTrustRelations(this.address);
    }
    async getTransactionHistory(pageSize) {
        const query = this.sdk.data.getTransactionHistory(this.address, pageSize);
        await query.queryNextPage();
        return query;
    }
    async getTotalBalance() {
        return parseFloat(await this.sdk.data.getTotalBalance(this.address, true));
    }
    async getGasTokenBalance() {
        return await this.sdk.contractRunner.provider?.getBalance(this.address) ?? 0n;
    }
    throwIfPathfinderIsNotAvailable() {
        if (!this.sdk.v1Pathfinder) {
            throw new Error('Pathfinder is not available');
        }
    }
}

let Pathfinder$1 = class Pathfinder {
    constructor(pathfinderURL) {
        this.pathfinderURL = pathfinderURL;
    }
    async getArgsForPath(from, to, value) {
        const query = {
            method: 'compute_transfer',
            params: { from, to, value: value.toString() }
        };
        try {
            const response = await fetch(this.pathfinderURL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(query)
            });
            if (!response.ok) {
                throw new Error(`Error calling API: ${response.status}`);
            }
            const parsed = await response.json();
            const transformedResponse = {
                data: {
                    directPath: {
                        requestedAmount: value,
                        flow: parsed.result.maxFlowValue,
                        transfers: parsed.result.transferSteps.map((step) => ({
                            from: step.from,
                            to: step.to,
                            tokenOwner: step.token_owner,
                            value: step.value
                        })),
                        isValid: parsed.result.final
                    }
                }
            };
            // todo: this is not great, I mangle the PathFinder response; should split these functions
            if (transformedResponse.data?.directPath) {
                const flowMatrix = createFlowMatrix(from, to, value, transformedResponse.data.directPath.transfers);
                return flowMatrix;
            }
            else {
                throw new Error('Invalid response from pathfinder');
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw error;
            }
            else {
                throw new Error('An unknown error occurred');
            }
        }
    }
    ;
};
function transformToFlowVertices(transfers, from, to) {
    // Normalize and extract all unique addresses from transfers
    const addressSet = new Set();
    addressSet.add(from.toLowerCase());
    addressSet.add(to.toLowerCase());
    for (const transfer of transfers) {
        addressSet.add(transfer.from.toLowerCase());
        addressSet.add(transfer.to.toLowerCase());
        addressSet.add(transfer.tokenOwner.toLowerCase());
    }
    // Convert addresses to uint160 and sort
    const sortedAddresses = Array.from(addressSet).sort((a, b) => {
        const uint160A = BigInt(a);
        const uint160B = BigInt(b);
        return uint160A < uint160B ? -1 : uint160A > uint160B ? 1 : 0;
    });
    // Create the lookup map
    const lookUpMap = {};
    sortedAddresses.forEach((address, index) => {
        lookUpMap[address] = index;
    });
    return {
        sortedAddresses: sortedAddresses,
        lookUpMap: lookUpMap
    };
}
function packCoordinates(coordinates) {
    const packedCoordinates = new Uint8Array(coordinates.length * 2);
    for (let i = 0; i < coordinates.length; i++) {
        packedCoordinates[2 * i] = coordinates[i] >> 8; // High byte
        packedCoordinates[2 * i + 1] = coordinates[i] & 0xFF; // Low byte
    }
    return packedCoordinates;
}
function createFlowMatrix(from, to, value, transfers) {
    // Transform transfers to flow matrix structure with normalized addresses
    const { sortedAddresses, lookUpMap } = transformToFlowVertices(transfers, from.toLowerCase(), to.toLowerCase());
    // Initialize flow edges
    const flowEdges = transfers.map((transfer, index) => ({
        streamSinkId: transfer.to.toLowerCase() === to.toLowerCase() ? 1 : 0, // Set streamSinkId to 1 if transfer.to matches the given 'to' address
        amount: BigInt(transfer.value) // Convert string value to bigint
    }));
    // If no terminal edge was found, set the last edge as terminal by default
    if (!flowEdges.some(edge => edge.streamSinkId === 1)) {
        flowEdges[flowEdges.length - 1].streamSinkId = 1;
    }
    // Check if the sum of terminal amounts matches the provided value
    const totalTerminalAmount = flowEdges
        .filter(edge => edge.streamSinkId === 1)
        .reduce((sum, edge) => sum + edge.amount, BigInt(0));
    if (totalTerminalAmount !== BigInt(value)) {
        throw new Error(`The total terminal amount (${totalTerminalAmount}) does not match the provided value (${value}).`);
    }
    // Initialize stream object
    const flowEdgeIds = flowEdges
        .map((edge, index) => (edge.streamSinkId === 1 ? index : -1))
        .filter(index => index !== -1);
    const stream = {
        sourceCoordinate: BigInt(lookUpMap[from.toLowerCase()]),
        flowEdgeIds: flowEdgeIds,
        data: new Uint8Array() // Empty bytes for now
    };
    // Get coordinates for each triple (tokenOwner, sender, receiver) and pack them
    const coordinates = [];
    for (const transfer of transfers) {
        coordinates.push(lookUpMap[transfer.tokenOwner.toLowerCase()]);
        coordinates.push(lookUpMap[transfer.from.toLowerCase()]);
        coordinates.push(lookUpMap[transfer.to.toLowerCase()]);
    }
    const packedCoordinates = packCoordinates(coordinates);
    return {
        flowVertices: sortedAddresses,
        flowEdges: flowEdges,
        streams: [stream],
        packedCoordinates: packedCoordinates,
        sourceCoordinate: lookUpMap[from.toLowerCase()] // Add sourceCoordinate using the lookup map
    };
}

class V2Avatar {
    get address() {
        return this.avatarInfo.avatar;
    }
    constructor(sdk, avatarInfo) {
        this.sdk = sdk;
        this.avatarInfo = avatarInfo;
        if (this.avatarInfo.version != 2) {
            throw new Error('Avatar is not a v2 avatar');
        }
    }
    async updateMetadata(cid) {
        this.throwIfNameRegistryIsNotAvailable();
        const digest = cidV0ToUint8Array(cid);
        const tx = await this.sdk.nameRegistry?.updateMetadataDigest(digest);
        const receipt = await tx?.wait();
        if (!receipt) {
            throw new Error('Transfer failed');
        }
        this.avatarInfo.cidV0 = cid;
        return receipt;
    }
    async getMaxTransferableAmount(to, tokenId) {
        this.throwIfV2IsNotAvailable();
        if (tokenId) {
            const tokenInfo = await this.sdk.data.getTokenInfo(tokenId);
            if (!tokenInfo) {
                throw new Error('Token not found');
            }
            const tokenBalances = await this.sdk.data.getTokenBalancesV2(this.address);
            const tokenBalance = tokenBalances.filter(b => b.tokenOwner.toString() === tokenInfo.tokenId.toString());
            console.log(`Token balance:`, tokenBalance);
            return !tokenBalance[0].balance ? 0n : ethers.parseEther(tokenBalance[0].balance.toString());
        }
        const largeAmount = BigInt('999999999999999999999999999999');
        const transferPath = await this.sdk.v2Pathfinder.getTransferPath(this.address, to, largeAmount);
        if (!transferPath.isValid) {
            return Promise.resolve(BigInt(0));
        }
        return transferPath.maxFlow;
    }
    async getMintableAmount() {
        this.throwIfV2IsNotAvailable();
        const [a, b, c] = await this.sdk.v2Hub.calculateIssuance(this.address);
        return parseFloat(formatEther(a));
    }
    async getTotalBalance() {
        return parseFloat(await this.sdk.data.getTotalBalanceV2(this.address, true));
    }
    async getGasTokenBalance() {
        return await this.sdk.contractRunner.provider?.getBalance(this.address) ?? 0n;
    }
    async getTransactionHistory(pageSize) {
        const query = this.sdk.data.getTransactionHistory(this.address, pageSize);
        await query.queryNextPage();
        return query;
    }
    async getTrustRelations() {
        return this.sdk.data.getAggregatedTrustRelations(this.address);
    }
    async personalMint() {
        this.throwIfV2IsNotAvailable();
        const tx = await this.sdk.v2Hub.personalMint();
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Personal mint failed');
        }
        return receipt;
    }
    async stop() {
        this.throwIfV2IsNotAvailable();
        const tx = await this.sdk.v2Hub.stop();
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Stop failed');
        }
        return receipt;
    }
    async transitiveTransfer(to, amount) {
        this.throwIfV2IsNotAvailable();
        const pathfinder = new Pathfinder$1(this.sdk.circlesConfig.v2PathfinderUrl);
        const flowMatrix = await pathfinder.getArgsForPath(this.address, to, amount.toString());
        const result = await this.sdk.v2Hub?.operateFlowMatrix(flowMatrix.flowVertices, flowMatrix.flowEdges, flowMatrix.streams, flowMatrix.packedCoordinates);
        const receipt = await result?.wait();
        if (!receipt) {
            throw new Error('Transfer failed');
        }
        return receipt;
    }
    async directTransfer(to, amount, tokenAddress) {
        const tokenInf = await this.sdk.data.getTokenInfo(tokenAddress);
        console.log(`Direct transfer - of: ${amount} - tokenId: ${tokenInf?.tokenId} - to: ${to}`);
        if (!tokenInf) {
            throw new Error('Token not found');
        }
        const numericTokenId = addressToUInt256(tokenInf.tokenId);
        console.log(`numericTokenId: ${numericTokenId}`);
        const tx = await this.sdk.v2Hub?.safeTransferFrom(this.address, to, numericTokenId, amount, new Uint8Array(0));
        const receipt = await tx?.wait();
        if (!receipt) {
            throw new Error('Transfer failed');
        }
        return receipt;
    }
    async transfer(to, amount, tokenAddress) {
        if (!tokenAddress) {
            const approvalStatus = await this.sdk.v2Hub.isApprovedForAll(this.address, this.address);
            if (!approvalStatus) {
                const tx = await this.sdk.v2Hub.setApprovalForAll(this.address, true);
                const receipt = await tx.wait();
                if (!receipt) {
                    throw new Error('Approval failed');
                }
            }
            console.log(`Approval by ${this.address} for ${this.address} successful`);
            return this.transitiveTransfer(to, amount);
        }
        else {
            return this.directTransfer(to, amount, tokenAddress);
        }
    }
    async trust(avatar) {
        this.throwIfV2IsNotAvailable();
        const tx = await this.sdk.v2Hub.trust(avatar, BigInt('79228162514264337593543950335'));
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Trust failed');
        }
        return receipt;
    }
    async untrust(avatar) {
        this.throwIfV2IsNotAvailable();
        const tx = await this.sdk.v2Hub.trust(avatar, BigInt('0'));
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Untrust failed');
        }
        return receipt;
    }
    async groupMint(group, collateral, amounts, data) {
        this.throwIfV2IsNotAvailable();
        const tx = await this.sdk.v2Hub.groupMint(group, collateral, amounts, data);
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Group mint failed');
        }
        return receipt;
    }
    async getProfile() {
        const profileCid = this.avatarInfo?.cidV0;
        if (this._cachedProfile && this._cachedProfileCid === profileCid) {
            return this._cachedProfile;
        }
        if (profileCid) {
            try {
                const profileData = await this.sdk?.profiles?.get(profileCid);
                if (profileData) {
                    this._cachedProfile = profileData;
                    this._cachedProfileCid = profileCid;
                    return this._cachedProfile;
                }
            }
            catch (e) {
                console.warn(`Couldn't load profile for CID ${profileCid}`, e);
            }
        }
        return undefined;
    }
    async updateProfile(profile) {
        const result = await this.sdk?.profiles?.create(profile);
        if (!result) {
            throw new Error('Failed to update profile. The profile service did not return a CID.');
        }
        const updateCidResult = await this.updateMetadata(result);
        if (!updateCidResult) {
            throw new Error('Failed to update profile. The CID was not updated.');
        }
        this.avatarInfo.cidV0 = result;
        return result;
    }
    async wrapDemurrageErc20(amount) {
        await this.sdk.v2Hub?.wrap(this.avatarInfo.avatar, amount, 0n /*Demurrage*/);
        throw new Error('Not implemented');
    }
    async wrapInflationErc20(amount) {
        this.sdk.v2Hub?.wrap(this.avatarInfo.avatar, amount, 1n /*Inflation*/);
        throw new Error('Not implemented');
    }
    /**
     * Invite a user to Circles.
     * @param avatar The address of the avatar to invite. Can be either a v1 address or an address that's not signed up yet.
     */
    async inviteHuman(avatar) {
        this.throwIfV2IsNotAvailable();
        const avatarInfo = await this.sdk.data.getAvatarInfo(avatar);
        if (avatarInfo?.version == 2) {
            throw new Error('Avatar is already a v2 avatar');
        }
        const receipt = await this.trust(avatar);
        if (!receipt) {
            throw new Error('Invite failed');
        }
        return receipt;
    }
    throwIfV2IsNotAvailable() {
        if (!this.sdk.circlesConfig.v2HubAddress) {
            throw new Error('V2 is not available');
        }
    }
    throwIfNameRegistryIsNotAvailable() {
        if (!this.sdk.nameRegistry) {
            throw new Error('Name registry is not available');
        }
    }
}

/**
 * An Avatar represents a user registered at Circles.
 * It provides methods to interact with the Circles protocol, such as minting, transferring and trusting other avatars.
 */
class Avatar {
    /**
     * After initialization, this property contains the avatar's basic information.
     */
    get avatarInfo() {
        return this._avatarInfo;
    }
    /**
     * Creates a new Avatar instance that controls a Circles avatar at the given address.
     * @param sdk The SDK instance to use.
     * @param avatarAddress The address of the avatar to control.
     */
    constructor(sdk, avatarAddress) {
        this._tokenEventSubscription = undefined;
        /**
         * Initializes the avatar.
         */
        this.initialize = async () => {
            if (this._tokenEventSubscription) {
                this._tokenEventSubscription();
            }
            this._avatarInfo = await this._sdk.data.getAvatarInfo(this.address);
            if (!this._avatarInfo) {
                throw new Error('Avatar is not signed up at Circles');
            }
            const { version, hasV1 } = this._avatarInfo;
            const v1Person = () => new V1Avatar(this._sdk, this._avatarInfo);
            const v2Person = () => new V2Avatar(this._sdk, this._avatarInfo);
            switch (version) {
                case 1:
                    this._avatar = v1Person();
                    break;
                case 2:
                    if (!hasV1) {
                        this._avatar = v2Person();
                    }
                    else {
                        const v1Avatar = v1Person();
                        const isStopped = await v1Avatar.v1Token?.stopped();
                        this._avatar = isStopped ? v2Person() : v1Person();
                        const avatarInfo = this._avatar.avatarInfo;
                        if (avatarInfo) {
                            avatarInfo.v1Stopped = isStopped;
                        }
                    }
                    break;
                default:
                    throw new Error('Unsupported avatar');
            }
            this._events = await this._sdk.data.subscribeToEvents(this._avatarInfo.avatar);
        };
        /**
         * `human` avatars can mint 24 personal Circles per day. This method returns the amount of Circles that can be minted.
         *
         * Note: v2 avatars can mint at max. 14 days * 24 Circles = 336 Circles.
         *       v1 avatars on the other hand will stop minting after 90 days without minting.
         * @returns The amount of Circles that can be minted.
         */
        this.getMintableAmount = () => this.onlyIfInitialized(() => this._avatar.getMintableAmount());
        /**
         * Mints the available personal Circles for the avatar. Check `getMintableAmount()` to see how many Circles can be minted.
         * @returns The transaction receipt.
         */
        this.personalMint = () => this.onlyIfInitialized(() => this._avatar.personalMint());
        /**
         * Stops the avatar's token. This will prevent any future `personalMint()` calls and is not reversible.
         */
        this.stop = () => this.onlyIfInitialized(() => this._avatar.stop());
        /**
         * Utilizes the pathfinder to find the maximum Circles amount that can be transferred from this Avatar to the other avatar.
         * @param to The address to transfer the Circles to.
         * @param tokenId The token ID to transfer. If not specified, a transitve transfer is calculated.
         * @returns The maximum Circles amount that can be transferred.
         */
        this.getMaxTransferableAmount = (to, tokenId) => this.onlyIfInitialized(() => this._avatar.getMaxTransferableAmount(to, tokenId));
        /**
         * Trusts another avatar. Trusting an avatar means you're willing to accept Circles that have been issued by this avatar.
         * @param avatar The address of the avatar to trust.
         * @returns The transaction receipt.
         */
        this.trust = (avatar) => this.onlyIfInitialized(() => this._avatar.trust(avatar));
        /**
         * Revokes trust from another avatar. This means you will no longer accept Circles issued by this avatar. This will not affect already received Circles.
         * @param avatar The address of the avatar to untrust.
         * @returns The transaction receipt.
         */
        this.untrust = (avatar) => this.onlyIfInitialized(() => this._avatar.untrust(avatar));
        /**
         * Gets the trust relations of the avatar.
         * @returns An array of trust relations in this form: avatar1 - [trusts|trustedBy|mutuallyTrusts] -> avatar2.
         */
        this.getTrustRelations = () => this.onlyIfInitialized(() => this._avatar.getTrustRelations());
        /**
         * Gets the Circles transaction history of the avatar. The history contains incoming/outgoing transactions and minting of personal Circles and Group Circles.
         * @param pageSize The maximum number of transactions per page.
         * @returns A query object that can be used to iterate over the transaction history.
         */
        this.getTransactionHistory = (pageSize) => this.onlyIfInitialized(() => this._avatar.getTransactionHistory(pageSize));
        /**
         * Gets the avatar's total Circles balance.
         *
         * Note: This queries either the v1 or the v2 balance of an avatar. Check the `avatarInfo` property to see which version your avatar uses.
         *       Token holdings in v1 can be migrated to v2. Check out `Sdk.migrateAvatar` or `Sdk.migrateAllV1Tokens` for more information.
         */
        this.getTotalBalance = () => this.onlyIfInitialized(() => this._avatar.getTotalBalance());
        /**
         * Gets the avatar's total balance of chain-native tokens.
         */
        this.getGasTokenBalance = () => this.onlyIfInitialized(() => this._avatar.getGasTokenBalance());
        /**
         * Use collateral, trusted by the group, to mint new Group Circles.
         * @param group The group which Circles to mint.
         * @param collateral The collateral tokens to use for minting.
         * @param amounts The amounts of the collateral tokens to use.
         * @param data Additional data for the minting operation.
         * @returns The transaction receipt.
         */
        this.groupMint = (group, collateral, amounts, data) => this.onlyIfV2((avatar) => avatar.groupMint(group, collateral, amounts, data));
        /**
         * Wraps the specified amount of personal Circles into demurraged ERC20 tokens for use outside the Circles protocol.
         * Note: This kind of token can be incompatible with services since it's demurraged and thus the balance changes over time.
         * @param amount The amount of Circles to wrap.
         */
        this.wrapDemurrageErc20 = (amount) => this.onlyIfV2((avatar) => avatar.wrapDemurrageErc20(amount));
        /**
         * Wraps the specified amount of inflation Circles into ERC20 tokens for use outside the Circles protocol.
         * In contrast to demurraged tokens, these token's balance does not change over time.
         * @param amount
         */
        this.wrapInflationErc20 = (amount) => this.onlyIfV2((avatar) => avatar.wrapInflationErc20(amount));
        /**
         * Invite a human avatar to join Circles.
         * @param avatar The address of any human controlled wallet.
         */
        this.inviteHuman = (avatar) => this.onlyIfV2((_avatar) => _avatar.inviteHuman(avatar));
        /**
         * Updates the avatar's metadata (profile).
         * @param cid The IPFS content identifier of the metadata (Qm....).
         */
        this.updateMetadata = (cid) => this.onlyIfV2((_avatar) => _avatar.updateMetadata(cid));
        /**
         * Gets the profile that's associated with the avatar or returns `undefined` if no profile is associated.
         * @returns The profile or `undefined`.
         */
        this.getProfile = () => this.onlyIfV2((_avatar) => _avatar.getProfile());
        /**
         * Updates the avatar's profile.
         * @param profile The new profile.
         * @returns The IPFS CID of the updated profile.
         */
        this.updateProfile = (profile) => this.onlyIfV2((_avatar) => _avatar.updateProfile(profile));
        this.address = avatarAddress.toLowerCase();
        this._sdk = sdk;
    }
    /**
     * The events observable for this avatar.
     */
    get events() {
        if (!this._events) {
            throw new Error('Not initialized');
        }
        return this._events;
    }
    onlyIfInitialized(func) {
        if (!this._avatar) {
            throw new Error('Avatar is not initialized');
        }
        return func();
    }
    onlyIfV2(func) {
        if (!this._avatar || this._avatarInfo?.version !== 2) {
            throw new Error('Avatar is not initialized or is not a v2 avatar');
        }
        return func(this._avatar);
    }
    transfer(to, amount, token) {
        if (typeof amount === 'number') {
            const sendValue = this?.avatarInfo?.version === 1
                ? tcToCrc(new Date(), amount)
                : parseEther(amount.toString());
            return this.onlyIfInitialized(() => this._avatar.transfer(to, sendValue, token));
        }
        return this.onlyIfInitialized(() => this._avatar.transfer(to, amount, token));
    }
}

class Pathfinder {
    constructor(pathfinderURL) {
        this.pathfinderURL = pathfinderURL;
    }
    async getTransferPath(from, to, value) {
        const query = {
            method: 'compute_transfer',
            params: { from, to, value: value.toString() }
        };
        const response = await fetch(this.pathfinderURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(query)
        });
        if (!response.ok) {
            throw new Error(`Error calling API: ${response.status}`);
        }
        const parsed = await response.json();
        if (!parsed.result) {
            throw new Error(`The pathfinder response didn't carry a result: ${JSON.stringify(parsed)}`);
        }
        return {
            requestedAmount: value,
            maxFlow: BigInt(parsed.result.maxFlowValue),
            transferSteps: parsed.result.transferSteps,
            isValid: parsed.result.final
        };
    }
}

/**
 * Wraps a contract runner with its address.
 */
/**
 * The SDK provides a high-level interface to interact with the Circles protocol.
 */
class Sdk {
    /**
     * Creates a new SDK instance.
     * @param circlesConfig The chain specific Circles configuration.
     * @param contractRunner A contract runner instance and its address.
     */
    constructor(circlesConfig, contractRunner) {
        /**
         * Gets an avatar by its address.
         * @param avatarAddress The avatar's address.
         * @returns The avatar instance.
         * @throws If the given avatar address is not signed up at Circles.
         */
        this.getAvatar = async (avatarAddress) => {
            const avatar = new Avatar(this, avatarAddress);
            await avatar.initialize();
            return avatar;
        };
        /**
         * Registers the connected wallet as a human avatar.
         * @returns The avatar instance.
         */
        this.registerHuman = async () => {
            const receipt = await this.v1Hub.signup();
            await receipt.wait();
            await this.waitForAvatarInfo(this.contractRunner.address);
            return this.getAvatar(this.contractRunner.address);
        };
        /**
         * Registers the connected wallet as an organization avatar.
         * @returns The avatar instance.
         */
        this.registerOrganization = async () => {
            const receipt = await this.v1Hub.organizationSignup();
            await receipt.wait();
            await this.waitForAvatarInfo(this.contractRunner.address);
            return this.getAvatar(this.contractRunner.address);
        };
        /**
         * Registers the connected wallet as an organization avatar in Circles v2.
         * @param profile The profile data of the organization.
         */
        this.registerOrganizationV2 = async (profile) => {
            if (!this.v2Hub) {
                throw new Error('V2 hub not available');
            }
            const metadataDigest = await this.createProfileIfNecessary(profile);
            const receipt = await this.v2Hub.registerOrganization(profile.name, metadataDigest);
            await receipt.wait();
            await this.waitForAvatarInfo(this.contractRunner.address);
            return this.getAvatar(this.contractRunner.address);
        };
        /**
         * Registers the connected wallet as a group avatar in Circles v2.
         * @param mint The address of the minting policy contract to use.
         * @param profile The profile data of the group.
         */
        this.registerGroupV2 = async (mint, profile) => {
            if (!this.v2Hub) {
                throw new Error('V2 hub not available');
            }
            const metadataDigest = await this.createProfileIfNecessary(profile);
            const receipt = await this.v2Hub.registerGroup(mint, profile.name, profile.symbol, metadataDigest);
            await receipt.wait();
            await this.waitForAvatarInfo(this.contractRunner.address);
            return this.getAvatar(this.contractRunner.address);
        };
        this.waitForAvatarInfo = async (address) => {
            let avatarRow;
            let retries = 0;
            do {
                avatarRow = await this.data.getAvatarInfo(address);
                await new Promise((resolve) => setTimeout(resolve, 500));
                retries++;
                if (retries > 120) {
                    throw new Error(`Timeout getting avatar info for ${address}`);
                }
            } while (!avatarRow);
            return avatarRow;
        };
        /**
         * Migrates a v1 avatar and all its Circles holdings to v2.
         * @param avatar The avatar's address.
         * @param profile The profile data of the avatar.
         */
        this.migrateAvatar = async (avatar, profile) => {
            if (!this.v2Hub) {
                throw new Error('V2 hub not available');
            }
            const avatarInfo = await this.data.getAvatarInfo(avatar);
            if (!avatarInfo) {
                throw new Error('Avatar not found');
            }
            if (avatarInfo.hasV1) {
                // 1. Stop V1 token if necessary
                if (avatarInfo.v1Token) {
                    const v1Avatar = new V1Avatar(this, avatarInfo);
                    const isStopped = await v1Avatar.v1Token?.stopped();
                    if (!isStopped) {
                        await v1Avatar.personalMint();
                        const stopTx = await v1Avatar.v1Token?.stop();
                        const stopTxReceipt = await stopTx?.wait();
                        if (!stopTxReceipt) {
                            throw new Error('Failed to stop V1 avatar');
                        }
                    }
                }
                // 2. Signup V2 avatar if necessary
                if (avatarInfo.version === 1) {
                    await this.registerHumanV2(profile);
                }
                // 3. Make sure the v1 token minting status is known to the v2 hub
                const calculateIssuanceTx = await this.v2Hub.calculateIssuanceWithCheck(avatar);
                await calculateIssuanceTx.wait();
                // 4. Migrate V1 tokens
                await this.migrateAllV1Tokens(avatar);
            }
            else {
                throw new Error('Avatar is not a V1 avatar');
            }
        };
        /**
         * Migrates all V1 tokens of an avatar to V2.
         * @param avatar The avatar's address.
         */
        /**
         * Migrates all V1 token holdings of an avatar to V2.
         * @param avatar The avatar whose tokens to migrate.
         */
        this.migrateAllV1Tokens = async (avatar) => {
            if (!this.circlesConfig.migrationAddress) {
                throw new Error('Migration address not set');
            }
            const balances = await this.data.getTokenBalances(avatar, false);
            const tokensToMigrate = balances
                .filter(o => BigInt(o.balance) > 0);
            // TODO: Send in one transaction if sent to Safe
            await Promise.all(tokensToMigrate.map(async (t, i) => {
                const balance = BigInt(t.balance);
                const token = Token__factory.connect(t.token, this.contractRunner);
                const allowance = await token.allowance(avatar, this.circlesConfig.migrationAddress);
                if (allowance < balance) {
                    const increase = balance - allowance;
                    const tx = await token.increaseAllowance(this.circlesConfig.migrationAddress, increase);
                    await tx.wait();
                }
            }));
            const migrationContract = Migration__factory.connect(this.circlesConfig.migrationAddress, this.contractRunner);
            const migrateTx = await migrationContract.migrate(tokensToMigrate.map(o => o.tokenOwner), tokensToMigrate.map(o => BigInt(o.balance)));
            await migrateTx.wait();
        };
        this.circlesConfig = circlesConfig;
        this.contractRunner = contractRunner;
        if (!this.contractRunner.address) {
            throw new Error('Contract runner is not initialized');
        }
        this.circlesRpc = new CirclesRpc(circlesConfig.circlesRpcUrl);
        this.data = new CirclesData(this.circlesRpc);
        this.v1Hub = Hub__factory.connect(circlesConfig.v1HubAddress ?? '0x29b9a7fBb8995b2423a71cC17cf9810798F6C543', this.contractRunner);
        if (circlesConfig.v2HubAddress) {
            this.v2Hub = Hub__factory$1.connect(circlesConfig.v2HubAddress, this.contractRunner);
        }
        if (circlesConfig.pathfinderUrl) {
            this.v1Pathfinder = new Pathfinder(circlesConfig.pathfinderUrl);
        }
        if (circlesConfig.v2PathfinderUrl) {
            this.v2Pathfinder = new Pathfinder(circlesConfig.v2PathfinderUrl);
        }
        if (circlesConfig.nameRegistryAddress) {
            this.nameRegistry = NameRegistry__factory.connect(circlesConfig.nameRegistryAddress, this.contractRunner);
        }
        if (circlesConfig.profileServiceUrl) {
            this.profiles = new Profiles(circlesConfig.profileServiceUrl);
        }
    }
    /**
     * Registers the connected wallet as a human avatar in Circles v2.
     * @param profile The profile data of the avatar.
     */
    async registerHumanV2(profile) {
        return this._registerHuman(ZeroAddress, profile);
    }
    ;
    async acceptInvitation(inviter, profile) {
        return this._registerHuman(inviter, profile);
    }
    async _registerHuman(inviter, profile) {
        if (!this.v2Hub) {
            throw new Error('V2 hub not available');
        }
        let metadataDigest = await this.createProfileIfNecessary(profile);
        const tx = await this.v2Hub.registerHuman(inviter, metadataDigest);
        const receipt = await tx.wait();
        if (!receipt) {
            throw new Error('Transaction failed');
        }
        await this.waitForAvatarInfo(this.contractRunner.address);
        return this.getAvatar(this.contractRunner.address);
    }
    /**
     * Checks if the profile argument is a string or a Profile object and creates the profile if necessary.
     * If the profile is a string, it must be a CIDv0 string (Qm...).
     * @param profile The profile data or CIDv0 of the avatar.
     * @private
     */
    async createProfileIfNecessary(profile) {
        if (typeof profile === 'string') {
            if (!profile.startsWith('Qm')) {
                throw new Error('Invalid profile CID. Must be a CIDv0 string (Qm...).');
            }
            return cidV0ToUint8Array(profile);
        }
        else if (this.profiles) {
            const profileCid = await this.profiles?.create(profile);
            return cidV0ToUint8Array(profileCid);
        }
        else {
            throw new Error('Profiles service is not configured');
        }
    }
}

const errorAbis = [
    'error CirclesHubOnlyDuringBootstrap(uint8 code)',
    'error CirclesHubRegisterAvatarV1MustBeStopped(address avatar, uint8 code)',
    'error CirclesHubAvatarAlreadyRegistered(address avatar, uint8 code)',
    'error CirclesHubMustBeHuman(address avatar, uint8 code)',
    'error CirclesHubGroupIsNotRegistered(address group, uint8 code)',
    'error CirclesHubInvalidTrustReceiver(address trustReceiver, uint8 code)',
    'error CirclesHubGroupMintPolicyRejectedMint(address minter, address group, uint256[] collateral, uint256[] amounts, bytes data, uint8 code)',
    'error CirclesHubGroupMintPolicyRejectedBurn(address burner, address group, uint256 amount, bytes data, uint8 code)',
    'error CirclesHubOperatorNotApprovedForSource(address operator, address source, uint16 streamId, uint8 code)',
    'error CirclesHubFlowEdgeIsNotPermitted(address receiver, uint256 circlesId, uint8 code)',
    'error CirclesHubOnClosedPathOnlyPersonalCirclesCanReturnToAvatar(address failedReceiver, uint256 circlesId)',
    'error CirclesHubFlowVerticesMustBeSorted()',
    'error CirclesHubFlowEdgeStreamMismatch(uint16 flowEdgeId, uint16 streamId, uint8 code)',
    'error CirclesHubStreamMismatch(uint16 streamId, uint8 code)',
    'error CirclesHubNettedFlowMismatch(uint16 vertexPosition, int256 matrixNettedFlow, int256 streamNettedFlow)',
    'error CirclesERC1155MintBlocked(address human, address mintV1Status)',
    'error CirclesDemurrageAmountExceedsMaxUint190(address account, uint256 circlesId, uint256 amount, uint8 code)',
    'error CirclesDemurrageDayBeforeLastUpdatedDay(address account, uint256 circlesId, uint64 day, uint64 lastUpdatedDay, uint8 code)',
    'error CirclesERC1155CannotReceiveBatch(uint8 code)',
    'error CirclesAvatarMustBeRegistered(address avatar, uint8 code)',
    'error CirclesAddressCannotBeZero(uint8 code)',
    'error CirclesInvalidFunctionCaller(address caller, address expectedCaller, uint8 code)',
    'error CirclesInvalidCirclesId(uint256 id, uint8 code)',
    'error CirclesInvalidString(string str, uint8 code)',
    'error CirclesInvalidParameter(uint256 parameter, uint8 code)',
    'error CirclesAmountOverflow(uint256 amount, uint8 code)',
    'error CirclesArraysLengthMismatch(uint256 lengthArray1, uint256 lengthArray2, uint8 code)',
    'error CirclesArrayMustNotBeEmpty(uint8 code)',
    'error CirclesAmountMustNotBeZero(uint8 code)',
    'error CirclesProxyAlreadyInitialized()',
    'error CirclesLogicAssertion(uint8 code)',
    'error CirclesIdMustBeDerivedFromAddress(uint256 providedId, uint8 code)',
    'error CirclesReentrancyGuard(uint8 code)',
    'error CirclesStandardTreasuryGroupHasNoVault(address group)',
    'error CirclesStandardTreasuryRedemptionCollateralMismatch(uint256 circlesId, uint256[] redemptionIds, uint256[] redemptionValues, uint256[] burnIds, uint256[] burnValues)',
    'error CirclesStandardTreasuryInvalidMetadataType(bytes32 metadataType, uint8 code)',
    'error CirclesStandardTreasuryInvalidMetadata(bytes metadata, uint8 code)',
    'error CirclesNamesInvalidName(address avatar, string name, uint8 code)',
    'error CirclesNamesShortNameAlreadyAssigned(address avatar, uint72 shortName, uint8 code)',
    'error CirclesNamesShortNameWithNonceTaken(address avatar, uint256 nonce, uint72 shortName, address takenByAvatar)',
    'error CirclesNamesAvatarAlreadyHasCustomNameOrSymbol(address avatar, string nameOrSymbol, uint8 code)',
    'error CirclesNamesOrganizationHasNoSymbol(address organization, uint8 code)'
];
const iface = new ethers.Interface(errorAbis);
function parseError(errorData) {
    return iface.parseError(errorData);
}

export { Avatar, Pathfinder, Sdk, V1Avatar, parseError };
//# sourceMappingURL=index.js.map
