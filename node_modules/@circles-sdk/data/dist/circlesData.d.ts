import { CirclesQuery } from './pagedQuery/circlesQuery';
import { TransactionHistoryRow } from './rows/transactionHistoryRow';
import { TrustListRow } from './rows/trustListRow';
import { TokenBalanceRow } from './rows/tokenBalanceRow';
import { CirclesRpc } from './circlesRpc';
import { AvatarRow } from './rows/avatarRow';
import { TrustRelationRow } from './rows/trustRelationRow';
import { CirclesDataInterface, GroupQueryParams } from './circlesDataInterface';
import { Observable } from './observable';
import { CirclesEvent } from './events/events';
import { InvitationRow } from './rows/invitationRow';
import { GroupMembershipRow } from './rows/groupMembershipRow';
import { GroupRow } from './rows/groupRow';
import { TokenInfoRow } from './rows/tokenInfoRow';
export type TrustEvent = {
    blockNumber: number;
    timestamp: number;
    transactionIndex: number;
    logIndex: number;
    transactionHash: string;
    trustee: string;
    truster: string;
    expiryTime: number;
};
export declare class CirclesData implements CirclesDataInterface {
    readonly rpc: CirclesRpc;
    constructor(rpc: CirclesRpc);
    /**
     * Gets the total CRC v1 balance of an address.
     * @param avatar The address to get the CRC balance for.
     * @param asTimeCircles Whether to return the balance as TimeCircles or not (default: true).
     */
    getTotalBalance(avatar: string, asTimeCircles?: boolean): Promise<string>;
    /**
     * Gets the total CRC v2 balance of an address.
     * @param avatar The address to get the CRC balance for.
     * @param asTimeCircles Whether to return the balance as TimeCircles or not (default: true).
     */
    getTotalBalanceV2(avatar: string, asTimeCircles?: boolean): Promise<string>;
    /**
     * Gets the detailed CRC v1 token balances of an address.
     * @param avatar The address to get the token balances for.
     * @param asTimeCircles Whether to return the balances as TimeCircles or not (default: true).
     */
    getTokenBalances(avatar: string, asTimeCircles?: boolean): Promise<TokenBalanceRow[]>;
    /**
     * Gets the detailed CRC v2 token balances of an address.
     * @param avatar The address to get the token balances for.
     * @param asTimeCircles Whether to return the balances as TimeCircles or not (default: true).
     */
    getTokenBalancesV2(avatar: string, asTimeCircles?: boolean): Promise<TokenBalanceRow[]>;
    /**
     * Gets the transaction history of an address.
     * This contains incoming/outgoing transactions and minting of CRC.
     * @param avatar The address to get the transaction history for.
     * @param pageSize The maximum number of transactions per page.
     */
    getTransactionHistory(avatar: string, pageSize: number): CirclesQuery<TransactionHistoryRow>;
    getIncomingTrustEvents(avatar: string, pageSize: number): CirclesQuery<TrustEvent>;
    /**
     * Gets the current incoming and outgoing trust relations of an address.
     * Expired or revoked trust relations are not included.
     * @param avatar The address to get the trust list for.
     * @param pageSize The maximum number of trust relations per page.
     */
    getTrustRelations(avatar: string, pageSize: number): CirclesQuery<TrustListRow>;
    /**
     * Gets all trust relations of an avatar and groups mutual trust relations together.
     * @param avatarAddress The address to get the trust relations for.
     */
    getAggregatedTrustRelations(avatarAddress: string): Promise<TrustRelationRow[]>;
    /**
     * Gets basic information about an avatar.
     * This includes the signup timestamp, circles version, avatar type and token address/id.
     * @param avatar The address to check.
     * @returns The avatar info or undefined if the avatar is not found.
     */
    getAvatarInfo(avatar: string): Promise<AvatarRow | undefined>;
    /**
     * Gets basic information about multiple avatars.
     * @param avatars The addresses to check.
     * @returns An array of avatar info objects.
     */
    getAvatarInfos(avatars: string[]): Promise<AvatarRow[]>;
    /**
     * Gets the token info for a given token address.
     * @param address The address of the token.
     * @returns The token info or undefined if the token is not found.
     */
    getTokenInfo(address: string): Promise<TokenInfoRow | undefined>;
    /**
     * Subscribes to Circles events.
     * @param avatar The avatar to subscribe to. If not provided, all events are subscribed to.
     */
    subscribeToEvents(avatar?: string): Promise<Observable<CirclesEvent>>;
    /**
     * Gets the events for a given avatar in a block range.
     * @param avatar The avatar to get the events for.
     * @param fromBlock The block number to start from.
     * @param toBlock The block number to end at. If not provided, the latest block is used.
     */
    getEvents(avatar: string, fromBlock: number, toBlock?: number): Promise<CirclesEvent[]>;
    /**
     * Gets the invitations sent by an avatar.
     * @param avatar The avatar to get the invitations for.
     * @param pageSize The maximum number of invitations per page.
     * @returns A CirclesQuery object to fetch the invitations.
     */
    getInvitations(avatar: string, pageSize: number): CirclesQuery<InvitationRow>;
    /**
     * Gets the avatar that invited the given avatar.
     * @param avatar The address of the invited avatar.
     * @returns The address of the inviting avatar or undefined if not found.
     */
    getInvitedBy(avatar: string): Promise<string | undefined>;
    /**
     * Gets the list of groups.
     * @param pageSize The maximum number of groups per page.
     * @param params The query parameters to filter the groups.
     */
    findGroups(pageSize: number, params?: GroupQueryParams): CirclesQuery<GroupRow>;
    /**
     * Gets the group memberships of an avatar.
     * @param avatar The avatar to get the group memberships for.
     * @param pageSize The maximum number of group memberships per page.
     */
    getGroupMemberships(avatar: string, pageSize: number): CirclesQuery<GroupMembershipRow>;
}
//# sourceMappingURL=circlesData.d.ts.map