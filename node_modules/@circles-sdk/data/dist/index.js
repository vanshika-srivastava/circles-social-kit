import { crcToTc, hexStringToUint8Array, uint8ArrayToCidV0 } from '@circles-sdk/utils';
import { ethers } from 'ethers';

/**
 * A class for querying Circles RPC nodes with pagination.
 * The class maintains the state of the current page and provides methods for querying the next pages.
 *
 * Usage:
 * 1. Create a new instance of CirclesQuery with the CirclesRpc instance and the query parameters.
 * 2. Call queryNextPage() to get the next page of results.
 * 3. Access the results and cursors from the currentPage property.
 * 4. Repeat step 2 until there are no more results.
 *
 * @typeParam TRow The type of the rows returned by the query.
 */
class CirclesQuery {
    /**
     * The current page of the query (or undefined).
     */
    get currentPage() {
        return this._currentPage;
    }
    constructor(rpc, params, calculatedColumns) {
        this._calculatedColumns = {};
        this.params = params;
        this.rpc = rpc;
        if (!calculatedColumns) {
            return;
        }
        calculatedColumns.forEach(column => {
            this._calculatedColumns[column.name] = column;
        });
    }
    /**
     * Builds the order by clause for a paged query.
     * Always orders by blockNumber, transactionIndex, and logIndex.
     * If the table is TransferBatch, also orders by batchIndex.
     * @param params The query parameters.
     * @private
     */
    buildOrderBy(params) {
        const order = [{
                Column: 'blockNumber',
                SortOrder: params.sortOrder
            }, {
                Column: 'transactionIndex',
                SortOrder: params.sortOrder
            }, {
                Column: 'logIndex',
                SortOrder: params.sortOrder
            }];
        if (params.table === 'TransferBatch') {
            // TODO: Find a better way to handle this.
            order.push({
                Column: 'batchIndex',
                SortOrder: params.sortOrder
            });
        }
        return order;
    }
    /**
     * Builds the cursor filter for a paged query.
     * Depending on the sort order, the cursor filter will be either greater than or less than the existing cursor.
     * @param params The query parameters.
     * @param cursor The cursor to use or undefined to start from the beginning/end depending on the sort order.
     * @private
     */
    buildCursorFilter(params, cursor) {
        if (!cursor) {
            return undefined;
        }
        const sortOrder = params.sortOrder === 'ASC' ? 'GreaterThan' : 'LessThan';
        // Add primary filter for blockNumber
        const blockNumberFilter = {
            Type: 'FilterPredicate',
            FilterType: sortOrder,
            Column: 'blockNumber',
            Value: cursor.blockNumber
        };
        // Create compound filter for transactionIndex, logIndex, and batchIndex
        const subFilters = [];
        // Filter for transactionIndex if blockNumber is equal
        subFilters.push({
            Type: 'Conjunction',
            ConjunctionType: 'And',
            Predicates: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'blockNumber',
                    Value: cursor.blockNumber
                },
                {
                    Type: 'FilterPredicate',
                    FilterType: sortOrder,
                    Column: 'transactionIndex',
                    Value: cursor.transactionIndex
                }
            ]
        });
        // Filter for logIndex if blockNumber and transactionIndex are equal
        subFilters.push({
            Type: 'Conjunction',
            ConjunctionType: 'And',
            Predicates: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'blockNumber',
                    Value: cursor.blockNumber
                },
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'transactionIndex',
                    Value: cursor.transactionIndex
                },
                {
                    Type: 'FilterPredicate',
                    FilterType: sortOrder,
                    Column: 'logIndex',
                    Value: cursor.logIndex
                }
            ]
        });
        // Filter for batchIndex if applicable and all previous columns are equal
        if (params.table === 'TransferBatch') {
            subFilters.push({
                Type: 'Conjunction',
                ConjunctionType: 'And',
                Predicates: [
                    {
                        Type: 'FilterPredicate',
                        FilterType: 'Equals',
                        Column: 'blockNumber',
                        Value: cursor.blockNumber
                    },
                    {
                        Type: 'FilterPredicate',
                        FilterType: 'Equals',
                        Column: 'transactionIndex',
                        Value: cursor.transactionIndex
                    },
                    {
                        Type: 'FilterPredicate',
                        FilterType: 'Equals',
                        Column: 'logIndex',
                        Value: cursor.logIndex
                    },
                    {
                        Type: 'FilterPredicate',
                        FilterType: sortOrder,
                        Column: 'batchIndex',
                        Value: cursor.batchIndex
                    }
                ]
            });
        }
        // Combine the primary and compound filters into a single filter
        const combinedFilter = {
            Type: 'Conjunction',
            ConjunctionType: 'Or',
            Predicates: [
                blockNumberFilter,
                ...subFilters
            ]
        };
        return [combinedFilter];
    }
    /**
     * Combines two filters into a single filter.
     * The filters are always combined with an 'And' conjunction.
     * @param filter1 The first filter or undefined.
     * @param filter2 The second filter or undefined.
     * @returns The combined filter or an empty array if both filters are undefined or empty.
     * @private
     */
    combineFilters(filter1, filter2) {
        if (!filter1 && !filter2) {
            return [];
        }
        if (!filter1) {
            return filter2 ?? [];
        }
        if (!filter2) {
            return filter1;
        }
        return [{
                Type: 'Conjunction',
                ConjunctionType: 'And',
                Predicates: [
                    ...filter1,
                    ...filter2
                ]
            }];
    }
    /**
     * Sends a `circles_query` call to a Circles Rpc node and returns the result as an array of objects.
     * @param method The method to call.
     * @param param The request parameters.
     * @private
     */
    async request(method, param) {
        const jsonResponse = await this.rpc.call(method, [param]);
        return await this.rowsToObjects(jsonResponse);
    }
    /**
     * Converts the rows from a Circles RPC response to an array of objects.
     * @param jsonResponse The JSON-RPC response.
     * @private
     */
    async rowsToObjects(jsonResponse) {
        const { columns, rows } = jsonResponse.result;
        const calculatedColumns = Object.entries(this._calculatedColumns);
        if (calculatedColumns.length > 0) {
            calculatedColumns.forEach(col => columns.push(col[0]));
        }
        const rowObjects = await Promise.all(rows.map(async (row) => {
            const rowObj = {};
            row.forEach((value, index) => {
                rowObj[columns[index]] = value;
            });
            for (const [name, column] of calculatedColumns) {
                rowObj[name] = await column.generator(rowObj);
            }
            return rowObj;
        }));
        return rowObjects;
    }
    /**
     * Converts a row from a query result to a cursor.
     * The cursor is an object with the blockNumber, transactionIndex, logIndex, and optional batchIndex properties.
     * @param resultElement The row from the query result.
     * @private
     */
    rowToCursor(resultElement) {
        return {
            blockNumber: resultElement.blockNumber,
            transactionIndex: resultElement.transactionIndex,
            logIndex: resultElement.logIndex,
            batchIndex: !resultElement.batchIndex ? undefined : resultElement.batchIndex
        };
    }
    /**
     * Builds a cursor from the first or last row of a query result.
     * If the result is empty, returns null.
     * @param result The query result.
     * @private
     */
    getFirstAndLastCursor(result) {
        if (result.length === 0) {
            return null;
        }
        const first = this.rowToCursor(result[0]);
        const last = this.rowToCursor(result[result.length - 1]);
        return { first, last };
    }
    /**
     * Queries the next page of a paged query.
     * @returns True if the query returned rows, false if there are no more results.
     */
    async queryNextPage() {
        const orderBy = this.buildOrderBy(this.params);
        const filter = this.buildCursorFilter(this.params, this._currentPage?.lastCursor);
        const combinedFilter = this.combineFilters(this.params.filter, filter);
        const queryParams = {
            Namespace: this.params.namespace,
            Table: this.params.table,
            Columns: this.params.columns,
            Filter: combinedFilter,
            Order: orderBy,
            Limit: this.params.limit
        };
        const result = await this.request('circles_query', queryParams);
        const cursors = this.getFirstAndLastCursor(result);
        this._currentPage = {
            limit: this.params.limit,
            size: result.length,
            firstCursor: cursors?.first,
            lastCursor: cursors?.last,
            sortOrder: this.params.sortOrder,
            results: result
        };
        return result.length > 0;
    }
    /**
     * Queries a single row from the Circles RPC node.
     */
    async getSingleRow() {
        const orderBy = this.buildOrderBy(this.params);
        const filter = this.buildCursorFilter(this.params, this._currentPage?.lastCursor);
        const combinedFilter = this.combineFilters(this.params.filter, filter);
        const queryParams = {
            Namespace: this.params.namespace,
            Table: this.params.table,
            Columns: this.params.columns,
            Filter: combinedFilter,
            Order: orderBy,
            Limit: 1
        };
        const result = await this.request('circles_query', queryParams);
        return result.length > 0 ? result[0] : undefined;
    }
}

class Observable {
    subscribe(subscriber) {
        this._subscribers.push(subscriber);
        return () => {
            this._subscribers.splice(this._subscribers.indexOf(subscriber), 1);
        };
    }
    constructor() {
        this._subscribers = [];
        this._subscribers = [];
    }
    emit(value) {
        this._subscribers.forEach(sub => sub(value));
    }
    static create() {
        const prop = new Observable();
        return {
            property: prop,
            emit: (e) => prop.emit(e)
        };
    }
}

const hexToBigInt = (hex) => BigInt(hex);
const hexToNumber = (hex) => parseInt(hex, 16);
const hexToUint8Array = (hex) => {
    if (hex.length % 2 !== 0)
        throw new Error('Invalid hex string');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        array[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return array;
};
const parseEventValues = (event, values) => {
    const baseEvent = {
        $event: event,
        blockNumber: hexToNumber(values.blockNumber),
        timestamp: values.timestamp ? hexToNumber(values.timestamp) : undefined,
        transactionIndex: hexToNumber(values.transactionIndex),
        logIndex: hexToNumber(values.logIndex),
        transactionHash: values.transactionHash
    };
    switch (event) {
        case 'CrcV1_HubTransfer':
            return {
                ...baseEvent,
                $event: "CrcV1_HubTransfer",
                from: values.from,
                to: values.to,
                amount: values.amount ? hexToBigInt(values.amount) : undefined
            };
        case 'CrcV1_Signup':
            return {
                ...baseEvent,
                $event: "CrcV1_Signup",
                user: values.user,
                token: values.token
            };
        case 'CrcV1_OrganizationSignup':
            return {
                ...baseEvent,
                $event: "CrcV1_OrganizationSignup",
                organization: values.organization
            };
        case 'CrcV1_Trust':
            return {
                ...baseEvent,
                $event: "CrcV1_Trust",
                canSendTo: values.canSendTo,
                user: values.user,
                limit: values.limit ? hexToBigInt(values.limit) : undefined
            };
        case 'CrcV1_Transfer':
            return {
                ...baseEvent,
                $event: "CrcV1_Transfer",
                tokenAddress: values.tokenAddress,
                from: values.from,
                to: values.to,
                amount: values.amount ? hexToBigInt(values.amount) : undefined
            };
        case 'CrcV2_InviteHuman':
            return {
                ...baseEvent,
                $event: "CrcV2_InviteHuman",
                inviter: values.inviter,
                invited: values.invited
            };
        case 'CrcV2_PersonalMint':
            return {
                ...baseEvent,
                $event: "CrcV2_PersonalMint",
                human: values.human,
                amount: values.amount ? hexToBigInt(values.amount) : undefined,
                startPeriod: values.startPeriod ? hexToBigInt(values.startPeriod) : undefined,
                endPeriod: values.endPeriod ? hexToBigInt(values.endPeriod) : undefined
            };
        case 'CrcV2_RegisterGroup':
            return {
                ...baseEvent,
                $event: "CrcV2_RegisterGroup",
                group: values.group,
                mint: values.mint,
                treasury: values.treasury,
                name: values.name,
                symbol: values.symbol
            };
        case 'CrcV2_RegisterHuman':
            return {
                ...baseEvent,
                $event: "CrcV2_RegisterHuman",
                avatar: values.avatar
            };
        case 'CrcV2_RegisterOrganization':
            return {
                ...baseEvent,
                $event: "CrcV2_RegisterOrganization",
                organization: values.organization,
                name: values.name
            };
        case 'CrcV2_Stopped':
            return {
                ...baseEvent,
                $event: "CrcV2_Stopped",
                avatar: values.avatar
            };
        case 'CrcV2_Trust':
            return {
                ...baseEvent,
                $event: "CrcV2_Trust",
                truster: values.truster,
                trustee: values.trustee,
                expiryTime: values.expiryTime ? hexToBigInt(values.expiryTime) : undefined
            };
        case 'CrcV2_TransferSingle':
            return {
                ...baseEvent,
                $event: "CrcV2_TransferSingle",
                operator: values.operator,
                from: values.from,
                to: values.to,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined
            };
        case 'CrcV2_URI':
            return {
                ...baseEvent,
                $event: "CrcV2_URI",
                value: values.value,
                id: values.id ? hexToBigInt(values.id) : undefined
            };
        case 'CrcV2_ApprovalForAll':
            return {
                ...baseEvent,
                $event: "CrcV2_ApprovalForAll",
                account: values.account,
                operator: values.operator,
                approved: values.approved === 'true'
            };
        case 'CrcV2_TransferBatch':
            return {
                ...baseEvent,
                $event: "CrcV2_TransferBatch",
                batchIndex: hexToNumber(values.batchIndex),
                operator: values.operator,
                from: values.from,
                to: values.to,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined
            };
        case 'CrcV2_RegisterShortName':
            return {
                ...baseEvent,
                $event: "CrcV2_RegisterShortName",
                avatar: values.avatar,
                shortName: values.shortName ? hexToBigInt(values.shortName) : undefined,
                nonce: values.nonce ? hexToBigInt(values.nonce) : undefined
            };
        case 'CrcV2_UpdateMetadataDigest':
            return {
                ...baseEvent,
                $event: "CrcV2_UpdateMetadataDigest",
                avatar: values.avatar,
                metadataDigest: values.metadataDigest ? hexToUint8Array(values.metadataDigest) : undefined
            };
        case 'CrcV2_CidV0':
            return {
                ...baseEvent,
                $event: "CrcV2_CidV0",
                avatar: values.avatar,
                cidV0Digest: values.cidV0Digest ? hexToUint8Array(values.cidV0Digest) : undefined
            };
        case "CrcV2_CreateVault":
            return {
                ...baseEvent,
                $event: "CrcV2_CreateVault",
                group: values.group,
                vault: values.vault
            };
        case "CrcV2_StreamCompleted":
            return {
                ...baseEvent,
                $event: "CrcV2_StreamCompleted",
                operator: values.operator,
                from: values.from,
                to: values.to,
                id: values.id ? hexToBigInt(values.id) : undefined,
                amount: values.amount ? hexToBigInt(values.amount) : undefined
            };
        case "CrcV2_GroupMintBatch":
            return {
                ...baseEvent,
                $event: "CrcV2_GroupMintBatch",
                batchIndex: parseInt(values.batchIndex),
                group: values.group,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined,
                userData: values.userData ? hexToUint8Array(values.userData) : undefined
            };
        case "CrcV2_GroupMintSingle":
            return {
                ...baseEvent,
                $event: "CrcV2_GroupMintSingle",
                group: values.group,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined,
                userData: values.userData ? hexToUint8Array(values.userData) : undefined,
            };
        case "CrcV2_GroupRedeem":
            return {
                ...baseEvent,
                $event: "CrcV2_GroupRedeem",
                group: values.group,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined,
                data: values.data ? hexToUint8Array(values.data) : undefined
            };
        case "CrcV2_GroupRedeemCollateralBurn":
            return {
                ...baseEvent,
                $event: "CrcV2_GroupRedeemCollateralBurn",
                batchIndex: parseInt(values.batchIndex),
                group: values.group,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined
            };
        case "CrcV2_GroupRedeemCollateralReturn":
            return {
                ...baseEvent,
                $event: "CrcV2_GroupRedeemCollateralReturn",
                batchIndex: parseInt(values.batchIndex),
                group: values.group,
                id: values.id ? hexToBigInt(values.id) : undefined,
                value: values.value ? hexToBigInt(values.value) : undefined
            };
        default:
            throw new Error(`Unknown event type: ${event}`);
    }
};
const parseRpcSubscriptionMessage = (message) => {
    return message.map(result => parseEventValues(result.event, result.values));
};

class CirclesData {
    constructor(rpc) {
        this.rpc = rpc;
    }
    /**
     * Gets the total CRC v1 balance of an address.
     * @param avatar The address to get the CRC balance for.
     * @param asTimeCircles Whether to return the balance as TimeCircles or not (default: true).
     */
    async getTotalBalance(avatar, asTimeCircles = true) {
        const response = await this.rpc.call('circles_getTotalBalance', [avatar, asTimeCircles]);
        return response.result;
    }
    /**
     * Gets the total CRC v2 balance of an address.
     * @param avatar The address to get the CRC balance for.
     * @param asTimeCircles Whether to return the balance as TimeCircles or not (default: true).
     */
    async getTotalBalanceV2(avatar, asTimeCircles = true) {
        const response = await this.rpc.call('circlesV2_getTotalBalance', [avatar, asTimeCircles]);
        return response.result;
    }
    /**
     * Gets the detailed CRC v1 token balances of an address.
     * @param avatar The address to get the token balances for.
     * @param asTimeCircles Whether to return the balances as TimeCircles or not (default: true).
     */
    async getTokenBalances(avatar, asTimeCircles = true) {
        const response = await this.rpc.call('circles_getTokenBalances', [avatar, asTimeCircles]);
        return response.result;
    }
    /**
     * Gets the detailed CRC v2 token balances of an address.
     * @param avatar The address to get the token balances for.
     * @param asTimeCircles Whether to return the balances as TimeCircles or not (default: true).
     */
    async getTokenBalancesV2(avatar, asTimeCircles = true) {
        const response = await this.rpc.call('circlesV2_getTokenBalances', [avatar, asTimeCircles]);
        return response.result;
    }
    /**
     * Gets the transaction history of an address.
     * This contains incoming/outgoing transactions and minting of CRC.
     * @param avatar The address to get the transaction history for.
     * @param pageSize The maximum number of transactions per page.
     */
    getTransactionHistory(avatar, pageSize) {
        return new CirclesQuery(this.rpc, {
            namespace: 'V_Crc',
            table: 'Transfers',
            sortOrder: 'DESC',
            limit: pageSize,
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'batchIndex',
                'transactionHash',
                'version',
                'operator',
                'from',
                'to',
                'id',
                'value'
            ],
            filter: [
                {
                    Type: 'Conjunction',
                    ConjunctionType: 'Or',
                    Predicates: [
                        {
                            Type: 'FilterPredicate',
                            FilterType: 'Equals',
                            Column: 'from',
                            Value: avatar.toLowerCase()
                        },
                        {
                            Type: 'FilterPredicate',
                            FilterType: 'Equals',
                            Column: 'to',
                            Value: avatar.toLowerCase()
                        }
                    ]
                }
            ]
        }, [{
                name: 'timeCircles',
                generator: async (row) => {
                    if (row.version === 1) {
                        const timestamp = new Date(row.timestamp * 1000);
                        return crcToTc(timestamp, BigInt(row.value)).toFixed(2);
                    }
                    else {
                        return parseFloat(ethers.formatEther(row.value)).toFixed(2);
                    }
                }
            }, {
                name: 'tokenAddress',
                generator: async (row) => {
                    // If the id isset, doesn't start with 0x and only consists of digits, it's a BigInt that
                    // needs to be converted to a ethereum address. The BigInt is actually an encoded byte[20]
                    // that represents the address.
                    if (row.id && !row.id.startsWith('0x') && /^\d+$/.test(row.id)) {
                        // UInt256 to ethereum address (use native BigInt)
                        const hexString = BigInt(row.id).toString(16).padStart(40, '0');
                        return ethers.getAddress('0x' + hexString).toLowerCase();
                    }
                    else if (row.id && row.id.startsWith('0x')) {
                        return row.id.toLowerCase();
                    }
                }
            }]);
    }
    getIncomingTrustEvents(avatar, pageSize) {
        return new CirclesQuery(this.rpc, {
            namespace: 'V_Crc',
            table: 'TrustRelations',
            sortOrder: 'DESC',
            limit: pageSize,
            columns: [
                "blockNumber",
                "timestamp",
                "transactionIndex",
                "logIndex",
                "transactionHash",
                "trustee",
                "truster",
                "expiryTime"
            ],
            filter: [
                {
                    Type: 'Conjunction',
                    ConjunctionType: 'And',
                    Predicates: [{
                            Type: 'FilterPredicate',
                            FilterType: 'Equals',
                            Column: 'trustee',
                            Value: avatar.toLowerCase()
                        }, {
                            Type: 'FilterPredicate',
                            FilterType: 'IsNotNull',
                            Column: 'expiryTime',
                            Value: true
                        }]
                }
            ]
        });
    }
    /**
     * Gets the current incoming and outgoing trust relations of an address.
     * Expired or revoked trust relations are not included.
     * @param avatar The address to get the trust list for.
     * @param pageSize The maximum number of trust relations per page.
     */
    getTrustRelations(avatar, pageSize) {
        return new CirclesQuery(this.rpc, {
            namespace: 'V_Crc',
            table: 'TrustRelations',
            sortOrder: 'DESC',
            limit: pageSize,
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'transactionHash',
                'version',
                'trustee',
                'truster',
                'expiryTime',
                'limit'
            ],
            filter: [
                {
                    Type: 'Conjunction',
                    ConjunctionType: 'Or',
                    Predicates: [
                        {
                            Type: 'FilterPredicate',
                            FilterType: 'Equals',
                            Column: 'trustee',
                            Value: avatar.toLowerCase()
                        },
                        {
                            Type: 'FilterPredicate',
                            FilterType: 'Equals',
                            Column: 'truster',
                            Value: avatar.toLowerCase()
                        }
                    ]
                }
            ]
        });
    }
    /**
     * Gets all trust relations of an avatar and groups mutual trust relations together.
     * @param avatarAddress The address to get the trust relations for.
     */
    async getAggregatedTrustRelations(avatarAddress) {
        const pageSize = 1000;
        const trustsQuery = this.getTrustRelations(avatarAddress, pageSize);
        const trustListRows = [];
        // Fetch all trust relations
        while (await trustsQuery.queryNextPage()) {
            const resultRows = trustsQuery.currentPage?.results ?? [];
            if (resultRows.length === 0)
                break;
            trustListRows.push(...resultRows);
            if (resultRows.length < pageSize)
                break;
        }
        // Group trust list rows by truster and trustee
        const trustBucket = {};
        trustListRows.forEach(row => {
            if (row.truster !== avatarAddress) {
                trustBucket[row.truster] = trustBucket[row.truster] || [];
                trustBucket[row.truster].push(row);
            }
            if (row.trustee !== avatarAddress) {
                trustBucket[row.trustee] = trustBucket[row.trustee] || [];
                trustBucket[row.trustee].push(row);
            }
        });
        // Determine trust relations
        return Object.entries(trustBucket)
            .filter(([avatar]) => avatar !== avatarAddress)
            .map(([avatar, rows]) => {
            const maxTimestamp = Math.max(...rows.map(o => o.timestamp));
            let relation;
            if (rows.length === 2) {
                relation = 'mutuallyTrusts';
            }
            else if (rows[0].trustee === avatarAddress) {
                relation = 'trustedBy';
            }
            else if (rows[0].truster === avatarAddress) {
                relation = 'trusts';
            }
            else {
                throw new Error(`Unexpected trust list row. Couldn't determine trust relation.`);
            }
            return {
                subjectAvatar: avatarAddress,
                relation: relation,
                objectAvatar: avatar,
                timestamp: maxTimestamp
            };
        });
    }
    /**
     * Gets basic information about an avatar.
     * This includes the signup timestamp, circles version, avatar type and token address/id.
     * @param avatar The address to check.
     * @returns The avatar info or undefined if the avatar is not found.
     */
    async getAvatarInfo(avatar) {
        const avatarInfos = await this.getAvatarInfos([avatar]);
        return avatarInfos.length > 0 ? avatarInfos[0] : undefined;
    }
    /**
     * Gets basic information about multiple avatars.
     * @param avatars The addresses to check.
     * @returns An array of avatar info objects.
     */
    async getAvatarInfos(avatars) {
        if (avatars.length === 0) {
            return [];
        }
        const circlesQuery = new CirclesQuery(this.rpc, {
            namespace: 'V_Crc',
            table: 'Avatars',
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'transactionHash',
                'version',
                'type',
                'avatar',
                'tokenId',
                'cidV0Digest'
            ],
            filter: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'In',
                    Column: 'avatar',
                    Value: avatars.map(a => a.toLowerCase())
                }
            ],
            sortOrder: 'ASC',
            limit: 1000
        }, [{
                name: 'cidV0',
                generator: async (row) => {
                    try {
                        if (!row.cidV0Digest) {
                            return undefined;
                        }
                        const dataFromHexString = hexStringToUint8Array(row.cidV0Digest.substring(2));
                        return uint8ArrayToCidV0(dataFromHexString);
                    }
                    catch (error) {
                        console.error('Failed to convert cidV0Digest to CIDv0 string:', error);
                        return undefined;
                    }
                }
            }]);
        const results = [];
        while (await circlesQuery.queryNextPage()) {
            const resultRows = circlesQuery.currentPage?.results ?? [];
            if (resultRows.length === 0)
                break;
            results.push(...resultRows);
            if (resultRows.length < 1000)
                break;
        }
        const avatarMap = {};
        results.forEach(avatarRow => {
            if (!avatarMap[avatarRow.avatar]) {
                avatarMap[avatarRow.avatar] = avatarRow;
            }
            if (avatarRow.version === 1) {
                avatarMap[avatarRow.avatar].hasV1 = true;
                avatarMap[avatarRow.avatar].v1Token = avatarRow.tokenId;
            }
            else {
                avatarMap[avatarRow.avatar] = {
                    ...avatarMap[avatarRow.avatar],
                    ...avatarRow
                };
            }
        });
        return avatars.map(avatar => avatarMap[avatar.toLowerCase()]).filter(row => row !== undefined);
    }
    /**
     * Gets the token info for a given token address.
     * @param address The address of the token.
     * @returns The token info or undefined if the token is not found.
     */
    async getTokenInfo(address) {
        const circlesQuery = new CirclesQuery(this.rpc, {
            namespace: 'V_Crc',
            table: 'Avatars',
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'transactionHash',
                'version',
                'type',
                'avatar',
                'tokenId'
            ],
            filter: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'tokenId',
                    Value: address.toLowerCase()
                }
            ],
            sortOrder: 'ASC',
            limit: 1
        });
        return await circlesQuery.getSingleRow();
    }
    /**
     * Subscribes to Circles events.
     * @param avatar The avatar to subscribe to. If not provided, all events are subscribed to.
     */
    subscribeToEvents(avatar) {
        return this.rpc.subscribe(avatar);
    }
    /**
     * Gets the events for a given avatar in a block range.
     * @param avatar The avatar to get the events for.
     * @param fromBlock The block number to start from.
     * @param toBlock The block number to end at. If not provided, the latest block is used.
     */
    async getEvents(avatar, fromBlock, toBlock) {
        const response = await this.rpc.call('circles_events', [avatar, fromBlock, toBlock]);
        return parseRpcSubscriptionMessage(response.result);
    }
    /**
     * Gets the invitations sent by an avatar.
     * @param avatar The avatar to get the invitations for.
     * @param pageSize The maximum number of invitations per page.
     * @returns A CirclesQuery object to fetch the invitations.
     */
    getInvitations(avatar, pageSize) {
        return new CirclesQuery(this.rpc, {
            namespace: 'CrcV2',
            table: 'InviteHuman',
            columns: [
                'blockNumber',
                'transactionIndex',
                'logIndex',
                'timestamp',
                'transactionHash',
                'inviter',
                'invited'
            ],
            filter: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'inviter',
                    Value: avatar.toLowerCase()
                }
            ],
            sortOrder: 'DESC',
            limit: pageSize
        });
    }
    /**
     * Gets the avatar that invited the given avatar.
     * @param avatar The address of the invited avatar.
     * @returns The address of the inviting avatar or undefined if not found.
     */
    async getInvitedBy(avatar) {
        const circlesQuery = new CirclesQuery(this.rpc, {
            namespace: 'CrcV2',
            table: 'InviteHuman',
            columns: [
                'inviter'
            ],
            filter: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'invited',
                    Value: avatar.toLowerCase()
                }
            ],
            sortOrder: 'DESC',
            limit: 1
        });
        const page = await circlesQuery.queryNextPage();
        if (!page) {
            return undefined;
        }
        return circlesQuery.currentPage?.results[0].inviter;
    }
    /**
     * Gets the list of groups.
     * @param pageSize The maximum number of groups per page.
     * @param params The query parameters to filter the groups.
     */
    findGroups(pageSize, params) {
        const queryDefintion = {
            namespace: 'V_CrcV2',
            table: 'Groups',
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'transactionHash',
                'group',
                'mint',
                'treasury',
                'name',
                'symbol',
                'cidV0Digest',
            ],
            sortOrder: 'DESC',
            limit: pageSize
        };
        if (!params) {
            return new CirclesQuery(this.rpc, queryDefintion);
        }
        let filter = [];
        if (params.nameStartsWith) {
            filter.push({
                Type: 'FilterPredicate',
                FilterType: 'Like',
                Column: 'name',
                Value: params.symbolStartsWith + '%'
            });
        }
        if (params.symbolStartsWith) {
            filter.push({
                Type: 'FilterPredicate',
                FilterType: 'Like',
                Column: 'symbol',
                Value: params.symbolStartsWith + '%'
            });
        }
        if (params.groupAddressIn) {
            filter.push({
                Type: 'FilterPredicate',
                FilterType: 'In',
                Column: 'group',
                Value: params.groupAddressIn
            });
        }
        if (filter.length > 1) {
            filter = [{
                    Type: 'Conjunction',
                    Predicates: filter,
                    ConjunctionType: 'And'
                }];
        }
        queryDefintion.filter = filter;
        return new CirclesQuery(this.rpc, queryDefintion);
    }
    /**
     * Gets the group memberships of an avatar.
     * @param avatar The avatar to get the group memberships for.
     * @param pageSize The maximum number of group memberships per page.
     */
    getGroupMemberships(avatar, pageSize) {
        return new CirclesQuery(this.rpc, {
            namespace: 'V_CrcV2',
            table: 'GroupMemberships',
            columns: [
                'blockNumber',
                'timestamp',
                'transactionIndex',
                'logIndex',
                'transactionHash',
                'group',
                'member',
                'expiryTime'
            ],
            filter: [
                {
                    Type: 'FilterPredicate',
                    FilterType: 'Equals',
                    Column: 'member',
                    Value: avatar.toLowerCase()
                }
            ],
            sortOrder: 'DESC',
            limit: pageSize
        });
    }
}

class CirclesRpc {
    constructor(rpcUrl) {
        this.idCounter = 0;
        this.websocket = null;
        this.websocketConnected = false;
        this.pendingResponses = {};
        this.subscriptionListeners = {};
        this.rpcUrl = rpcUrl;
    }
    async call(method, params) {
        const requestBody = {
            jsonrpc: '2.0',
            id: this.idCounter++,
            method: method,
            params: params
        };
        const response = await fetch(this.rpcUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        const jsonResponse = await response.json();
        if (!jsonResponse.result) {
            throw new Error(`RPC Error: ${JSON.stringify(jsonResponse)}`);
        }
        return jsonResponse;
    }
    connect() {
        return new Promise((resolve, reject) => {
            let wsUrl = this.rpcUrl.replace('http', 'ws');
            if (wsUrl.endsWith('/')) {
                wsUrl += 'ws';
            }
            else {
                wsUrl += '/ws';
            }
            this.websocket = new WebSocket(wsUrl);
            this.websocket.onopen = () => {
                resolve();
            };
            this.websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                const { id, method, params } = message;
                if (id !== undefined && this.pendingResponses[id]) {
                    this.pendingResponses[id].resolve(message);
                    delete this.pendingResponses[id];
                }
                if (method === 'eth_subscription' && params) {
                    const { subscription, result } = params;
                    if (this.subscriptionListeners[subscription]) {
                        this.subscriptionListeners[subscription].forEach(listener => listener(result));
                    }
                }
            };
            this.websocket.onclose = () => {
                this.websocketConnected = false;
            };
            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                reject(error);
            };
        });
    }
    sendMessage(method, params, timeout = 5000) {
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            return Promise.reject('WebSocket is not connected');
        }
        const id = this.idCounter++;
        const message = { jsonrpc: '2.0', method, params, id };
        return new Promise((resolve, reject) => {
            this.pendingResponses[id] = { resolve, reject };
            this.websocket.send(JSON.stringify(message));
            setTimeout(() => {
                if (this.pendingResponses[id]) {
                    this.pendingResponses[id].reject('Request timed out');
                    delete this.pendingResponses[id];
                }
            }, timeout);
        });
    }
    async subscribe(address) {
        if (!this.websocketConnected) {
            await this.connect();
            this.websocketConnected = true;
        }
        const observable = Observable.create();
        const subscriptionArgs = JSON.stringify(address ? { address } : {});
        const response = await this.sendMessage('eth_subscribe', ['circles', subscriptionArgs]);
        const subscriptionId = response.result;
        if (!this.subscriptionListeners[subscriptionId]) {
            this.subscriptionListeners[subscriptionId] = [];
        }
        this.subscriptionListeners[subscriptionId].push((events) => {
            parseRpcSubscriptionMessage(events).forEach(event => observable.emit(event));
        });
        // TODO: Add unsubscribe method to observable
        return observable.property;
    }
}

export { CirclesData, CirclesQuery, CirclesRpc, Observable };
//# sourceMappingURL=index.js.map
