import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common";
export declare namespace TypeDefinitions {
    type FlowEdgeStruct = {
        streamSinkId: BigNumberish;
        amount: BigNumberish;
    };
    type FlowEdgeStructOutput = [streamSinkId: bigint, amount: bigint] & {
        streamSinkId: bigint;
        amount: bigint;
    };
    type StreamStruct = {
        sourceCoordinate: BigNumberish;
        flowEdgeIds: BigNumberish[];
        data: BytesLike;
    };
    type StreamStructOutput = [
        sourceCoordinate: bigint,
        flowEdgeIds: bigint[],
        data: string
    ] & {
        sourceCoordinate: bigint;
        flowEdgeIds: bigint[];
        data: string;
    };
}
export interface HubInterface extends Interface {
    getFunction(nameOrSignature: "advancedUsageFlags" | "avatars" | "balanceOf" | "balanceOfBatch" | "balanceOfOnDay" | "burn" | "calculateIssuance" | "calculateIssuanceWithCheck" | "convertDemurrageToInflationaryValue" | "convertInflationaryToDemurrageValue" | "day" | "groupMint" | "inflationDayZero" | "isApprovedForAll" | "isGroup" | "isHuman" | "isOrganization" | "isPermittedFlow" | "isTrusted" | "migrate" | "mintPolicies" | "operateFlowMatrix" | "personalMint" | "registerCustomGroup" | "registerGroup" | "registerHuman" | "registerOrganization" | "safeBatchTransferFrom" | "safeTransferFrom" | "setAdvancedUsageFlag" | "setApprovalForAll" | "stop" | "stopped" | "supportsInterface" | "toTokenId" | "totalSupply" | "treasuries" | "trust" | "trustMarkers" | "uri" | "wrap"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "ApprovalForAll" | "PersonalMint" | "RegisterGroup" | "RegisterHuman" | "RegisterOrganization" | "Stopped" | "StreamCompleted" | "TransferBatch" | "TransferSingle" | "Trust" | "URI"): EventFragment;
    encodeFunctionData(functionFragment: "advancedUsageFlags", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "avatars", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "balanceOfBatch", values: [AddressLike[], BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "balanceOfOnDay", values: [AddressLike, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "burn", values: [BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "calculateIssuance", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "calculateIssuanceWithCheck", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "convertDemurrageToInflationaryValue", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "convertInflationaryToDemurrageValue", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "day", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "groupMint", values: [AddressLike, AddressLike[], BigNumberish[], BytesLike]): string;
    encodeFunctionData(functionFragment: "inflationDayZero", values?: undefined): string;
    encodeFunctionData(functionFragment: "isApprovedForAll", values: [AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "isGroup", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isHuman", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isOrganization", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isPermittedFlow", values: [AddressLike, AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "isTrusted", values: [AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "migrate", values: [AddressLike, AddressLike[], BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "mintPolicies", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "operateFlowMatrix", values: [
        AddressLike[],
        TypeDefinitions.FlowEdgeStruct[],
        TypeDefinitions.StreamStruct[],
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "personalMint", values?: undefined): string;
    encodeFunctionData(functionFragment: "registerCustomGroup", values: [AddressLike, AddressLike, string, string, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerGroup", values: [AddressLike, string, string, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerHuman", values: [AddressLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerOrganization", values: [string, BytesLike]): string;
    encodeFunctionData(functionFragment: "safeBatchTransferFrom", values: [
        AddressLike,
        AddressLike,
        BigNumberish[],
        BigNumberish[],
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "safeTransferFrom", values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "setAdvancedUsageFlag", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "setApprovalForAll", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "stop", values?: undefined): string;
    encodeFunctionData(functionFragment: "stopped", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "toTokenId", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "totalSupply", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "treasuries", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "trust", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "trustMarkers", values: [AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "uri", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "wrap", values: [AddressLike, BigNumberish, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "advancedUsageFlags", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "avatars", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOfBatch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOfOnDay", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateIssuance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateIssuanceWithCheck", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "convertDemurrageToInflationaryValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "convertInflationaryToDemurrageValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "day", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "groupMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inflationDayZero", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isApprovedForAll", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isGroup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isHuman", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isOrganization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPermittedFlow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isTrusted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "migrate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintPolicies", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "operateFlowMatrix", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "personalMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerCustomGroup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerGroup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerHuman", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerOrganization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safeBatchTransferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safeTransferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAdvancedUsageFlag", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setApprovalForAll", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stop", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stopped", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "toTokenId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "treasuries", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "trust", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "trustMarkers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrap", data: BytesLike): Result;
}
export declare namespace ApprovalForAllEvent {
    type InputTuple = [
        account: AddressLike,
        operator: AddressLike,
        approved: boolean
    ];
    type OutputTuple = [
        account: string,
        operator: string,
        approved: boolean
    ];
    interface OutputObject {
        account: string;
        operator: string;
        approved: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace PersonalMintEvent {
    type InputTuple = [
        human: AddressLike,
        amount: BigNumberish,
        startPeriod: BigNumberish,
        endPeriod: BigNumberish
    ];
    type OutputTuple = [
        human: string,
        amount: bigint,
        startPeriod: bigint,
        endPeriod: bigint
    ];
    interface OutputObject {
        human: string;
        amount: bigint;
        startPeriod: bigint;
        endPeriod: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace RegisterGroupEvent {
    type InputTuple = [
        group: AddressLike,
        mint: AddressLike,
        treasury: AddressLike,
        name: string,
        symbol: string
    ];
    type OutputTuple = [
        group: string,
        mint: string,
        treasury: string,
        name: string,
        symbol: string
    ];
    interface OutputObject {
        group: string;
        mint: string;
        treasury: string;
        name: string;
        symbol: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace RegisterHumanEvent {
    type InputTuple = [avatar: AddressLike];
    type OutputTuple = [avatar: string];
    interface OutputObject {
        avatar: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace RegisterOrganizationEvent {
    type InputTuple = [organization: AddressLike, name: string];
    type OutputTuple = [organization: string, name: string];
    interface OutputObject {
        organization: string;
        name: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace StoppedEvent {
    type InputTuple = [avatar: AddressLike];
    type OutputTuple = [avatar: string];
    interface OutputObject {
        avatar: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace StreamCompletedEvent {
    type InputTuple = [
        operator: AddressLike,
        from: AddressLike,
        to: AddressLike,
        ids: BigNumberish[],
        amounts: BigNumberish[]
    ];
    type OutputTuple = [
        operator: string,
        from: string,
        to: string,
        ids: bigint[],
        amounts: bigint[]
    ];
    interface OutputObject {
        operator: string;
        from: string;
        to: string;
        ids: bigint[];
        amounts: bigint[];
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TransferBatchEvent {
    type InputTuple = [
        operator: AddressLike,
        from: AddressLike,
        to: AddressLike,
        ids: BigNumberish[],
        values: BigNumberish[]
    ];
    type OutputTuple = [
        operator: string,
        from: string,
        to: string,
        ids: bigint[],
        values: bigint[]
    ];
    interface OutputObject {
        operator: string;
        from: string;
        to: string;
        ids: bigint[];
        values: bigint[];
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TransferSingleEvent {
    type InputTuple = [
        operator: AddressLike,
        from: AddressLike,
        to: AddressLike,
        id: BigNumberish,
        value: BigNumberish
    ];
    type OutputTuple = [
        operator: string,
        from: string,
        to: string,
        id: bigint,
        value: bigint
    ];
    interface OutputObject {
        operator: string;
        from: string;
        to: string;
        id: bigint;
        value: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TrustEvent {
    type InputTuple = [
        truster: AddressLike,
        trustee: AddressLike,
        expiryTime: BigNumberish
    ];
    type OutputTuple = [
        truster: string,
        trustee: string,
        expiryTime: bigint
    ];
    interface OutputObject {
        truster: string;
        trustee: string;
        expiryTime: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace URIEvent {
    type InputTuple = [value: string, id: BigNumberish];
    type OutputTuple = [value: string, id: bigint];
    interface OutputObject {
        value: string;
        id: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface Hub extends BaseContract {
    connect(runner?: ContractRunner | null): Hub;
    waitForDeployment(): Promise<this>;
    interface: HubInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    advancedUsageFlags: TypedContractMethod<[
        arg0: AddressLike
    ], [
        string
    ], "view">;
    avatars: TypedContractMethod<[arg0: AddressLike], [string], "view">;
    balanceOf: TypedContractMethod<[
        _account: AddressLike,
        _id: BigNumberish
    ], [
        bigint
    ], "view">;
    balanceOfBatch: TypedContractMethod<[
        _accounts: AddressLike[],
        _ids: BigNumberish[]
    ], [
        bigint[]
    ], "view">;
    balanceOfOnDay: TypedContractMethod<[
        _account: AddressLike,
        _id: BigNumberish,
        _day: BigNumberish
    ], [
        [bigint, bigint] & {
            balanceOnDay_: bigint;
            discountCost_: bigint;
        }
    ], "view">;
    burn: TypedContractMethod<[
        _id: BigNumberish,
        _amount: BigNumberish,
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    calculateIssuance: TypedContractMethod<[
        _human: AddressLike
    ], [
        [bigint, bigint, bigint]
    ], "view">;
    calculateIssuanceWithCheck: TypedContractMethod<[
        _human: AddressLike
    ], [
        [bigint, bigint, bigint]
    ], "nonpayable">;
    convertDemurrageToInflationaryValue: TypedContractMethod<[
        _demurrageValue: BigNumberish,
        _dayUpdated: BigNumberish
    ], [
        bigint
    ], "view">;
    convertInflationaryToDemurrageValue: TypedContractMethod<[
        _inflationaryValue: BigNumberish,
        _day: BigNumberish
    ], [
        bigint
    ], "view">;
    day: TypedContractMethod<[_timestamp: BigNumberish], [bigint], "view">;
    groupMint: TypedContractMethod<[
        _group: AddressLike,
        _collateralAvatars: AddressLike[],
        _amounts: BigNumberish[],
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    inflationDayZero: TypedContractMethod<[], [bigint], "view">;
    isApprovedForAll: TypedContractMethod<[
        _account: AddressLike,
        _operator: AddressLike
    ], [
        boolean
    ], "view">;
    isGroup: TypedContractMethod<[_group: AddressLike], [boolean], "view">;
    isHuman: TypedContractMethod<[_human: AddressLike], [boolean], "view">;
    isOrganization: TypedContractMethod<[
        _organization: AddressLike
    ], [
        boolean
    ], "view">;
    isPermittedFlow: TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _circlesAvatar: AddressLike
    ], [
        boolean
    ], "view">;
    isTrusted: TypedContractMethod<[
        _truster: AddressLike,
        _trustee: AddressLike
    ], [
        boolean
    ], "view">;
    migrate: TypedContractMethod<[
        _owner: AddressLike,
        _avatars: AddressLike[],
        _amounts: BigNumberish[]
    ], [
        void
    ], "nonpayable">;
    mintPolicies: TypedContractMethod<[arg0: AddressLike], [string], "view">;
    operateFlowMatrix: TypedContractMethod<[
        _flowVertices: AddressLike[],
        _flow: TypeDefinitions.FlowEdgeStruct[],
        _streams: TypeDefinitions.StreamStruct[],
        _packedCoordinates: BytesLike
    ], [
        void
    ], "nonpayable">;
    personalMint: TypedContractMethod<[], [void], "nonpayable">;
    registerCustomGroup: TypedContractMethod<[
        _mint: AddressLike,
        _treasury: AddressLike,
        _name: string,
        _symbol: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    registerGroup: TypedContractMethod<[
        _mint: AddressLike,
        _name: string,
        _symbol: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    registerHuman: TypedContractMethod<[
        _inviter: AddressLike,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    registerOrganization: TypedContractMethod<[
        _name: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    safeBatchTransferFrom: TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _ids: BigNumberish[],
        _values: BigNumberish[],
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    safeTransferFrom: TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _id: BigNumberish,
        _value: BigNumberish,
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    setAdvancedUsageFlag: TypedContractMethod<[
        _flag: BytesLike
    ], [
        void
    ], "nonpayable">;
    setApprovalForAll: TypedContractMethod<[
        _operator: AddressLike,
        _approved: boolean
    ], [
        void
    ], "nonpayable">;
    stop: TypedContractMethod<[], [void], "nonpayable">;
    stopped: TypedContractMethod<[_human: AddressLike], [boolean], "view">;
    supportsInterface: TypedContractMethod<[
        _interfaceId: BytesLike
    ], [
        boolean
    ], "view">;
    toTokenId: TypedContractMethod<[_avatar: AddressLike], [bigint], "view">;
    totalSupply: TypedContractMethod<[_id: BigNumberish], [bigint], "view">;
    treasuries: TypedContractMethod<[arg0: AddressLike], [string], "view">;
    trust: TypedContractMethod<[
        _trustReceiver: AddressLike,
        _expiry: BigNumberish
    ], [
        void
    ], "nonpayable">;
    trustMarkers: TypedContractMethod<[
        arg0: AddressLike,
        arg1: AddressLike
    ], [
        [string, bigint] & {
            previous: string;
            expiry: bigint;
        }
    ], "view">;
    uri: TypedContractMethod<[arg0: BigNumberish], [string], "view">;
    wrap: TypedContractMethod<[
        _avatar: AddressLike,
        _amount: BigNumberish,
        _type: BigNumberish
    ], [
        string
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "advancedUsageFlags"): TypedContractMethod<[arg0: AddressLike], [string], "view">;
    getFunction(nameOrSignature: "avatars"): TypedContractMethod<[arg0: AddressLike], [string], "view">;
    getFunction(nameOrSignature: "balanceOf"): TypedContractMethod<[
        _account: AddressLike,
        _id: BigNumberish
    ], [
        bigint
    ], "view">;
    getFunction(nameOrSignature: "balanceOfBatch"): TypedContractMethod<[
        _accounts: AddressLike[],
        _ids: BigNumberish[]
    ], [
        bigint[]
    ], "view">;
    getFunction(nameOrSignature: "balanceOfOnDay"): TypedContractMethod<[
        _account: AddressLike,
        _id: BigNumberish,
        _day: BigNumberish
    ], [
        [bigint, bigint] & {
            balanceOnDay_: bigint;
            discountCost_: bigint;
        }
    ], "view">;
    getFunction(nameOrSignature: "burn"): TypedContractMethod<[
        _id: BigNumberish,
        _amount: BigNumberish,
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "calculateIssuance"): TypedContractMethod<[
        _human: AddressLike
    ], [
        [bigint, bigint, bigint]
    ], "view">;
    getFunction(nameOrSignature: "calculateIssuanceWithCheck"): TypedContractMethod<[
        _human: AddressLike
    ], [
        [bigint, bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "convertDemurrageToInflationaryValue"): TypedContractMethod<[
        _demurrageValue: BigNumberish,
        _dayUpdated: BigNumberish
    ], [
        bigint
    ], "view">;
    getFunction(nameOrSignature: "convertInflationaryToDemurrageValue"): TypedContractMethod<[
        _inflationaryValue: BigNumberish,
        _day: BigNumberish
    ], [
        bigint
    ], "view">;
    getFunction(nameOrSignature: "day"): TypedContractMethod<[_timestamp: BigNumberish], [bigint], "view">;
    getFunction(nameOrSignature: "groupMint"): TypedContractMethod<[
        _group: AddressLike,
        _collateralAvatars: AddressLike[],
        _amounts: BigNumberish[],
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "inflationDayZero"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "isApprovedForAll"): TypedContractMethod<[
        _account: AddressLike,
        _operator: AddressLike
    ], [
        boolean
    ], "view">;
    getFunction(nameOrSignature: "isGroup"): TypedContractMethod<[_group: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isHuman"): TypedContractMethod<[_human: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isOrganization"): TypedContractMethod<[_organization: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isPermittedFlow"): TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _circlesAvatar: AddressLike
    ], [
        boolean
    ], "view">;
    getFunction(nameOrSignature: "isTrusted"): TypedContractMethod<[
        _truster: AddressLike,
        _trustee: AddressLike
    ], [
        boolean
    ], "view">;
    getFunction(nameOrSignature: "migrate"): TypedContractMethod<[
        _owner: AddressLike,
        _avatars: AddressLike[],
        _amounts: BigNumberish[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "mintPolicies"): TypedContractMethod<[arg0: AddressLike], [string], "view">;
    getFunction(nameOrSignature: "operateFlowMatrix"): TypedContractMethod<[
        _flowVertices: AddressLike[],
        _flow: TypeDefinitions.FlowEdgeStruct[],
        _streams: TypeDefinitions.StreamStruct[],
        _packedCoordinates: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "personalMint"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "registerCustomGroup"): TypedContractMethod<[
        _mint: AddressLike,
        _treasury: AddressLike,
        _name: string,
        _symbol: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "registerGroup"): TypedContractMethod<[
        _mint: AddressLike,
        _name: string,
        _symbol: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "registerHuman"): TypedContractMethod<[
        _inviter: AddressLike,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "registerOrganization"): TypedContractMethod<[
        _name: string,
        _metadataDigest: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "safeBatchTransferFrom"): TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _ids: BigNumberish[],
        _values: BigNumberish[],
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "safeTransferFrom"): TypedContractMethod<[
        _from: AddressLike,
        _to: AddressLike,
        _id: BigNumberish,
        _value: BigNumberish,
        _data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setAdvancedUsageFlag"): TypedContractMethod<[_flag: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setApprovalForAll"): TypedContractMethod<[
        _operator: AddressLike,
        _approved: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "stop"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "stopped"): TypedContractMethod<[_human: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "supportsInterface"): TypedContractMethod<[_interfaceId: BytesLike], [boolean], "view">;
    getFunction(nameOrSignature: "toTokenId"): TypedContractMethod<[_avatar: AddressLike], [bigint], "view">;
    getFunction(nameOrSignature: "totalSupply"): TypedContractMethod<[_id: BigNumberish], [bigint], "view">;
    getFunction(nameOrSignature: "treasuries"): TypedContractMethod<[arg0: AddressLike], [string], "view">;
    getFunction(nameOrSignature: "trust"): TypedContractMethod<[
        _trustReceiver: AddressLike,
        _expiry: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "trustMarkers"): TypedContractMethod<[
        arg0: AddressLike,
        arg1: AddressLike
    ], [
        [string, bigint] & {
            previous: string;
            expiry: bigint;
        }
    ], "view">;
    getFunction(nameOrSignature: "uri"): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
    getFunction(nameOrSignature: "wrap"): TypedContractMethod<[
        _avatar: AddressLike,
        _amount: BigNumberish,
        _type: BigNumberish
    ], [
        string
    ], "nonpayable">;
    getEvent(key: "ApprovalForAll"): TypedContractEvent<ApprovalForAllEvent.InputTuple, ApprovalForAllEvent.OutputTuple, ApprovalForAllEvent.OutputObject>;
    getEvent(key: "PersonalMint"): TypedContractEvent<PersonalMintEvent.InputTuple, PersonalMintEvent.OutputTuple, PersonalMintEvent.OutputObject>;
    getEvent(key: "RegisterGroup"): TypedContractEvent<RegisterGroupEvent.InputTuple, RegisterGroupEvent.OutputTuple, RegisterGroupEvent.OutputObject>;
    getEvent(key: "RegisterHuman"): TypedContractEvent<RegisterHumanEvent.InputTuple, RegisterHumanEvent.OutputTuple, RegisterHumanEvent.OutputObject>;
    getEvent(key: "RegisterOrganization"): TypedContractEvent<RegisterOrganizationEvent.InputTuple, RegisterOrganizationEvent.OutputTuple, RegisterOrganizationEvent.OutputObject>;
    getEvent(key: "Stopped"): TypedContractEvent<StoppedEvent.InputTuple, StoppedEvent.OutputTuple, StoppedEvent.OutputObject>;
    getEvent(key: "StreamCompleted"): TypedContractEvent<StreamCompletedEvent.InputTuple, StreamCompletedEvent.OutputTuple, StreamCompletedEvent.OutputObject>;
    getEvent(key: "TransferBatch"): TypedContractEvent<TransferBatchEvent.InputTuple, TransferBatchEvent.OutputTuple, TransferBatchEvent.OutputObject>;
    getEvent(key: "TransferSingle"): TypedContractEvent<TransferSingleEvent.InputTuple, TransferSingleEvent.OutputTuple, TransferSingleEvent.OutputObject>;
    getEvent(key: "Trust"): TypedContractEvent<TrustEvent.InputTuple, TrustEvent.OutputTuple, TrustEvent.OutputObject>;
    getEvent(key: "URI"): TypedContractEvent<URIEvent.InputTuple, URIEvent.OutputTuple, URIEvent.OutputObject>;
    filters: {
        "ApprovalForAll(address,address,bool)": TypedContractEvent<ApprovalForAllEvent.InputTuple, ApprovalForAllEvent.OutputTuple, ApprovalForAllEvent.OutputObject>;
        ApprovalForAll: TypedContractEvent<ApprovalForAllEvent.InputTuple, ApprovalForAllEvent.OutputTuple, ApprovalForAllEvent.OutputObject>;
        "PersonalMint(address,uint256,uint256,uint256)": TypedContractEvent<PersonalMintEvent.InputTuple, PersonalMintEvent.OutputTuple, PersonalMintEvent.OutputObject>;
        PersonalMint: TypedContractEvent<PersonalMintEvent.InputTuple, PersonalMintEvent.OutputTuple, PersonalMintEvent.OutputObject>;
        "RegisterGroup(address,address,address,string,string)": TypedContractEvent<RegisterGroupEvent.InputTuple, RegisterGroupEvent.OutputTuple, RegisterGroupEvent.OutputObject>;
        RegisterGroup: TypedContractEvent<RegisterGroupEvent.InputTuple, RegisterGroupEvent.OutputTuple, RegisterGroupEvent.OutputObject>;
        "RegisterHuman(address)": TypedContractEvent<RegisterHumanEvent.InputTuple, RegisterHumanEvent.OutputTuple, RegisterHumanEvent.OutputObject>;
        RegisterHuman: TypedContractEvent<RegisterHumanEvent.InputTuple, RegisterHumanEvent.OutputTuple, RegisterHumanEvent.OutputObject>;
        "RegisterOrganization(address,string)": TypedContractEvent<RegisterOrganizationEvent.InputTuple, RegisterOrganizationEvent.OutputTuple, RegisterOrganizationEvent.OutputObject>;
        RegisterOrganization: TypedContractEvent<RegisterOrganizationEvent.InputTuple, RegisterOrganizationEvent.OutputTuple, RegisterOrganizationEvent.OutputObject>;
        "Stopped(address)": TypedContractEvent<StoppedEvent.InputTuple, StoppedEvent.OutputTuple, StoppedEvent.OutputObject>;
        Stopped: TypedContractEvent<StoppedEvent.InputTuple, StoppedEvent.OutputTuple, StoppedEvent.OutputObject>;
        "StreamCompleted(address,address,address,uint256[],uint256[])": TypedContractEvent<StreamCompletedEvent.InputTuple, StreamCompletedEvent.OutputTuple, StreamCompletedEvent.OutputObject>;
        StreamCompleted: TypedContractEvent<StreamCompletedEvent.InputTuple, StreamCompletedEvent.OutputTuple, StreamCompletedEvent.OutputObject>;
        "TransferBatch(address,address,address,uint256[],uint256[])": TypedContractEvent<TransferBatchEvent.InputTuple, TransferBatchEvent.OutputTuple, TransferBatchEvent.OutputObject>;
        TransferBatch: TypedContractEvent<TransferBatchEvent.InputTuple, TransferBatchEvent.OutputTuple, TransferBatchEvent.OutputObject>;
        "TransferSingle(address,address,address,uint256,uint256)": TypedContractEvent<TransferSingleEvent.InputTuple, TransferSingleEvent.OutputTuple, TransferSingleEvent.OutputObject>;
        TransferSingle: TypedContractEvent<TransferSingleEvent.InputTuple, TransferSingleEvent.OutputTuple, TransferSingleEvent.OutputObject>;
        "Trust(address,address,uint256)": TypedContractEvent<TrustEvent.InputTuple, TrustEvent.OutputTuple, TrustEvent.OutputObject>;
        Trust: TypedContractEvent<TrustEvent.InputTuple, TrustEvent.OutputTuple, TrustEvent.OutputObject>;
        "URI(string,uint256)": TypedContractEvent<URIEvent.InputTuple, URIEvent.OutputTuple, URIEvent.OutputObject>;
        URI: TypedContractEvent<URIEvent.InputTuple, URIEvent.OutputTuple, URIEvent.OutputObject>;
    };
}
//# sourceMappingURL=Hub.d.ts.map