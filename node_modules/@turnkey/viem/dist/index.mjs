import { isAddress, serializeTransaction, hashMessage, hashTypedData, signatureToHex } from 'viem';
import { toAccount } from 'viem/accounts';
import { TurnkeyActivityError, TurnkeyClient } from '@turnkey/http';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';

async function createAccount(input) {
    const { client, organizationId, signWith } = input;
    let { ethereumAddress } = input;
    if (!signWith) {
        throw new TurnkeyActivityError({
            message: `Missing signWith parameter`,
        });
    }
    if (isAddress(signWith)) {
        // override provided `ethereumAddress`
        ethereumAddress = signWith;
    }
    else if (!ethereumAddress) {
        // we have a private key ID, but not an ethereumAddress
        const data = await client.getPrivateKey({
            privateKeyId: signWith,
            organizationId: organizationId,
        });
        ethereumAddress = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")?.address;
        if (typeof ethereumAddress !== "string" || !ethereumAddress) {
            throw new TurnkeyActivityError({
                message: `Unable to find Ethereum address for key ${signWith} under organization ${organizationId}`,
            });
        }
    }
    return toAccount({
        address: ethereumAddress,
        signMessage: function ({ message, }) {
            return signMessage(client, message, organizationId, signWith);
        },
        signTransaction: function (transaction, args) {
            const serializer = !args?.serializer
                ? serializeTransaction
                : args.serializer;
            return signTransaction(client, transaction, serializer, organizationId, signWith);
        },
        signTypedData: function (typedData) {
            return signTypedData(client, typedData, organizationId, signWith);
        },
    });
}
/**
 * Creates a new Custom Account backed by a Turnkey API key.
 * @deprecated use {@link createAccount} instead.
 */
async function createApiKeyAccount(config) {
    const { apiPublicKey, apiPrivateKey, baseUrl, organizationId, privateKeyId } = config;
    const stamper = new ApiKeyStamper({
        apiPublicKey: apiPublicKey,
        apiPrivateKey: apiPrivateKey,
    });
    const client = new TurnkeyClient({
        baseUrl: baseUrl,
    }, stamper);
    const data = await client.getPrivateKey({
        privateKeyId: privateKeyId,
        organizationId: organizationId,
    });
    const ethereumAddress = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")?.address;
    if (typeof ethereumAddress !== "string" || !ethereumAddress) {
        throw new TurnkeyActivityError({
            message: `Unable to find Ethereum address for key ${privateKeyId} under organization ${organizationId}`,
        });
    }
    return toAccount({
        address: ethereumAddress,
        signMessage: function ({ message, }) {
            return signMessage(client, message, organizationId, privateKeyId);
        },
        signTransaction: function (transaction, args) {
            const serializer = !args?.serializer
                ? serializeTransaction
                : args.serializer;
            return signTransaction(client, transaction, serializer, organizationId, privateKeyId);
        },
        signTypedData: function (typedData) {
            return signTypedData(client, typedData, organizationId, privateKeyId);
        },
    });
}
async function signMessage(client, message, organizationId, signWith) {
    const hashedMessage = hashMessage(message);
    const signedMessage = await signMessageWithErrorWrapping(client, hashedMessage, organizationId, signWith);
    return `${signedMessage}`;
}
async function signTransaction(client, transaction, serializer, organizationId, signWith) {
    const serializedTx = serializer(transaction);
    const nonHexPrefixedSerializedTx = serializedTx.replace(/^0x/, "");
    return await signTransactionWithErrorWrapping(client, nonHexPrefixedSerializedTx, organizationId, signWith);
}
async function signTypedData(client, data, organizationId, signWith) {
    const hashToSign = hashTypedData(data);
    return await signMessageWithErrorWrapping(client, hashToSign, organizationId, signWith);
}
async function signTransactionWithErrorWrapping(client, unsignedTransaction, organizationId, signWith) {
    let signedTx;
    try {
        signedTx = await signTransactionImpl(client, unsignedTransaction, organizationId, signWith);
    }
    catch (error) {
        if (error instanceof TurnkeyActivityError) {
            throw error;
        }
        throw new TurnkeyActivityError({
            message: `Failed to sign transaction: ${error.message}`,
            cause: error,
        });
    }
    return `0x${signedTx}`;
}
async function signTransactionImpl(client, unsignedTransaction, organizationId, signWith) {
    if (client instanceof TurnkeyClient) {
        const { activity } = await client.signTransaction({
            type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
            organizationId: organizationId,
            parameters: {
                signWith,
                type: "TRANSACTION_TYPE_ETHEREUM",
                unsignedTransaction: unsignedTransaction,
            },
            timestampMs: String(Date.now()), // millisecond timestamp
        });
        const { id, status, type } = activity;
        if (activity.status !== "ACTIVITY_STATUS_COMPLETED") {
            throw new TurnkeyActivityError({
                message: `Invalid activity status: ${activity.status}`,
                activityId: id,
                activityStatus: status,
                activityType: type,
            });
        }
        return assertNonNull(activity?.result?.signTransactionResult?.signedTransaction);
    }
    else {
        // Want to get additional activity details here
        const activity = await client.signTransaction({
            signWith,
            type: "TRANSACTION_TYPE_ETHEREUM",
            unsignedTransaction: unsignedTransaction,
        });
        return assertNonNull(activity?.signedTransaction);
    }
}
async function signMessageWithErrorWrapping(client, message, organizationId, signWith) {
    let signedMessage;
    try {
        signedMessage = await signMessageImpl(client, message, organizationId, signWith);
    }
    catch (error) {
        if (error instanceof TurnkeyActivityError) {
            throw error;
        }
        throw new TurnkeyActivityError({
            message: `Failed to sign: ${error.message}`,
            cause: error,
        });
    }
    return signedMessage;
}
async function signMessageImpl(client, message, organizationId, signWith) {
    let result;
    if (client instanceof TurnkeyClient) {
        const { activity } = await client.signRawPayload({
            type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
            organizationId: organizationId,
            parameters: {
                signWith,
                payload: message,
                encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                hashFunction: "HASH_FUNCTION_NO_OP",
            },
            timestampMs: String(Date.now()), // millisecond timestamp
        });
        const { id, status, type } = activity;
        if (status !== "ACTIVITY_STATUS_COMPLETED") {
            throw new TurnkeyActivityError({
                message: `Invalid activity status: ${activity.status}`,
                activityId: id,
                activityStatus: status,
                activityType: type,
            });
        }
        result = assertNonNull(activity?.result?.signRawPayloadResult);
    }
    else {
        // Want to get ID and status back as well in the result (we won't get an error)
        // Maybe do a try/catch?
        result = await client.signRawPayload({
            signWith,
            payload: message,
            encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
            hashFunction: "HASH_FUNCTION_NO_OP",
        });
    }
    let assembled = signatureToHex({
        r: `0x${result.r}`,
        s: `0x${result.s}`,
        v: result.v === "00" ? 27n : 28n,
    });
    // Assemble the hex
    return assertNonNull(assembled);
}
function assertNonNull(input) {
    if (input == null) {
        throw new Error(`Got unexpected ${JSON.stringify(input)}`);
    }
    return input;
}

export { createAccount, createApiKeyAccount, signMessage, signTransaction, signTypedData };
//# sourceMappingURL=index.mjs.map
